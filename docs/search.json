[
  {
    "objectID": "manuals/package_installation/index.html",
    "href": "manuals/package_installation/index.html",
    "title": "ExESS Package Installation",
    "section": "",
    "text": "Manuals"
  },
  {
    "objectID": "manuals/package_installation/index.html#installation",
    "href": "manuals/package_installation/index.html#installation",
    "title": "ExESS Package Installation",
    "section": "Installation",
    "text": "Installation\nThis simulation tool was created as a custom package for the computer language Julia. Please refer to the official guide to installing Julia on your machine. To be able to use the ExESS package, the entire repository has to be downloaded from LRZ-GitLab. Afterward, the code can be used in several different ways. The entire module can be included directly by specifying the path of the downloaded package in the include call.\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS"
  },
  {
    "objectID": "manuals/package_installation/index.html#required-packages",
    "href": "manuals/package_installation/index.html#required-packages",
    "title": "ExESS Package Installation",
    "section": "Required Packages",
    "text": "Required Packages\nThe ExESS package relies on multiple other packages that have to be added and installed by the user. They can be added using Julia’s package-manager Pkg:\nusing Pkg\nPkg.add(\"Interpolations\")\nPkg.add(\"NearestNeighbors\")\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"SpecialFunctions\")"
  },
  {
    "objectID": "manuals/git_workflow/index.html",
    "href": "manuals/git_workflow/index.html",
    "title": "DRAFT! Git Workflow",
    "section": "",
    "text": "Manuals\nIn order to use and work with the ExESS.jl package, you need to have access to the code and be able to download it. You can find the repository with all files on GitLab. Only the developers of the package have full access to the code and are able to edit them directly, though Git and GitLab offer wonderful collaboration tools for you to work with code, even if you do not own it, and even to suggest changes to it. This manual page will go through some of the usual workflow steps for working with ExESS.jl and Git.\nhttps://www.atlassian.com/git/tutorials/comparing-workflows?section=forking-workflow is a great and more extended tutorial/manual on how to use Git."
  },
  {
    "objectID": "manuals/git_workflow/index.html#forking-the-repository",
    "href": "manuals/git_workflow/index.html#forking-the-repository",
    "title": "DRAFT! Git Workflow",
    "section": "Forking the Repository",
    "text": "Forking the Repository\nWhile you can see the repository with the code, you cannot download and use it yet. To be able to do so, you need to create an online copy of the repository and put it in your name space, where you have full access to, a process called forking. This is done by clicking the Fork button on the top right corner of the repository page on GitLab. Once you click the button, GitLab will ask you about the Project name, Project URL (i.e., the name space), the Project slug, and an optional Project description of the forked repository. Note that the default values are copied from the original ExESS.jl repository, but since this is your personal copy, you can change anything to whatever you want. Here are a couple of hints to make your life easier: * Use your own user-name name-space in the Project URL (e.g., https://gitlab.lrz.de/&lt;username&gt;/) * The Project slug is the name of the online repository and will be the default value for your local copies (i.e., the folder name on your computer). Make it short and fit for a folder name (e.g., exess).\nAt the bottom of the Fork Project page, you can also choose the Visibility Level; please leave the default value of Internal for me to be able to see your work.\nWhy did you have to go through all this trouble to copy some files from the internet? Couldn’t you just download them plain and simple? Well, yes, but doing it “The Git Way” has a couple of advantages: * You do not just have the code; you now have a connected copy of the code. This means that anytime there is a change in the original repository, your fork will notice that instantly and give you the option to update your copy to match the newest original version. * You can make changes to the original code without actually changing the original code. Nonetheless, if you want to make your change a part of the original code, you can suggest your version to the original code’s author, and they can decide whether to accept your suggestion. This is done through a Merge Request (see below). * Should at any time in your work you want to go back to the original code, you can do so with a single click."
  },
  {
    "objectID": "manuals/git_workflow/index.html#cloning-the-repository",
    "href": "manuals/git_workflow/index.html#cloning-the-repository",
    "title": "DRAFT! Git Workflow",
    "section": "Cloning the Repository",
    "text": "Cloning the Repository\nNow that you have a forked copy of the repository, you can download it to your computer. This is called cloning the repository. To do so, you need to copy the Project URL of your forked repository (e.g., https://gitlab.lrz.de/&lt;username&gt;/exess). You can find a blue Clone button on your forked repository page; expanding it shows you the option to Clone with HTTPS where you can simply copy the URL from. Use it in the following command:\ngit clone &lt;project_url&gt;\nThis will create a folder with the name of the Project slug (e.g., exess) in your current directory. This folder is your local copy of the repository, and you can now work with it as you wish. Note that you can clone the repository to any directory you want, and you can clone it as many times as you want."
  },
  {
    "objectID": "manuals/git_workflow/index.html#updating-the-repository",
    "href": "manuals/git_workflow/index.html#updating-the-repository",
    "title": "DRAFT! Git Workflow",
    "section": "Updating the Repository",
    "text": "Updating the Repository\nAs mentioned above, you can update your local copy of the repository to match the newest version of the original repository. This is done by pulling the changes from the original repository.\ngit pull"
  },
  {
    "objectID": "manuals/git_workflow/index.html#working-with-branches",
    "href": "manuals/git_workflow/index.html#working-with-branches",
    "title": "DRAFT! Git Workflow",
    "section": "Working with Branches",
    "text": "Working with Branches\nBranches are a convenient way to work on different versions of the code at the same time. For example, you can have a branch for the newest version of the code and another branch for a version that you are working on. You can switch between branches at any time, and you can merge branches together. The default branch is called main, which contains the current version of the code that is ready to be used. A second branch, called dev is used for development purposes, and it contains the newest version of the code that is currently under development, which means there can still be (even more) bugs there. The general rule is that if you work with the code, you should use the main branch, and if you work on the code, you should use the dev branch.\nShould you want to create a new branch, you can either do it online, using the little plus button on the top left (drop-down to New Branch), or you can do so with the following command:\ngit branch &lt;branch_name&gt;\nIf you created the branch online, do not forget to pull the online changes to your local copy! If you created the branch locally, you can push it to the online repository with the following command:\ngit push --set-upstream origin &lt;branch_name&gt;\nTo switch between branches, use the following command:\ngit checkout &lt;branch_name&gt;"
  },
  {
    "objectID": "manuals/git_workflow/index.html#working-with-the-repository",
    "href": "manuals/git_workflow/index.html#working-with-the-repository",
    "title": "DRAFT! Git Workflow",
    "section": "Working with the Repository",
    "text": "Working with the Repository\nYou now have your local version of ExESS.jl and want to fork with/on it. While there are many files in the repository, the main Julia files, containing the functions you’re are most likely interested in, are located in the src folder.\nIf you write and add your own functions, please create another directory inside of the home or the src folder and give it a fitting name. You can now work directly in the local repository, on your or on the original functions.\nIf you have added your changes to the code, you can add and, thus, stage your changes to be uploaded and synchronized with the online repository. This is done with the following commands:\ngit add &lt;file&gt; # chose a or multiple, specific files\ngit add --all  # stage ALL changed/added files\nYour changes are now ready for commit. This is done with the following command:\ngit commit -m \"&lt;commit_message&gt;\"\nThis command will finalize your updates and prepare them to be uploaded to the online repository. Note that you can add and commit as many times as you want before you push your changes to the online repository. For both documentation and debugging purposes, it is recommended to regularly add and commit your changes and always write a meaningful and short commit_message that describes the changes you have made.\nTo upload your changes to the online repository, use the following command:\ngit push\nNow your local and online versions are synchronized again (at least regarding the files that have been pushed). These online changes, including the commit_message, can be seen on the online repository page."
  },
  {
    "objectID": "manuals/git_workflow/index.html#merging-code",
    "href": "manuals/git_workflow/index.html#merging-code",
    "title": "DRAFT! Git Workflow",
    "section": "Merging Code",
    "text": "Merging Code\nAny time you want Git to synchronize a local and an online version of a repository, Git will change all touched files and put them to their newest version. While this usually goes smoothly, it can happen that both the online as well as the local version of a file have been changed, making it impossible for Git to know which of the versions to use. In this case, Git will ask you to merge the two versions. You, as the user and author of the changes, are to decide which version to use or how to combine the two versions into a new one.\nYou should generally always make these kinds of merges on your local repository and then push the merged version with all conflicts resolved to the online repository. Depending on the editor you use, it will ask you to write a message describing your merge (e.g., Merge two versions of src/grids.jl). This message is not the same as the commit_message and is used for documentation purposes. Always resolve your merge conflicts and keep a clean repository!"
  },
  {
    "objectID": "manuals/git_workflow/index.html#merge-requests",
    "href": "manuals/git_workflow/index.html#merge-requests",
    "title": "DRAFT! Git Workflow",
    "section": "Merge Requests",
    "text": "Merge Requests\nThe same merge conflict can happen between your forked code and the original ExESS.jl repository. Either the authors have updated the original code and you want to include it in your own forked version where you have already made some changes yourself, or maybe you have made some changes to your forked version and want to suggest them to the original authors. In the former case, you simply have to resolve all conflicts in your own online and local version yourself, which has no influence on the original code. In the latter cases, you can create a Merge Request to suggest your changes to the original repository.\nOn the top of the GitLab page, the repository will track how many commits your version is further (or behind) the original code. It then suggests a Merge Request to you, where you can suggest your changes to the original code. The request will then arrive at the authors to review all changes and to make sure that they are compatible with the original code. If they accept your request, your changes will be included in the original code. If they reject your request, you can either try to resolve the conflicts yourself and make a new request, or you can keep your changes in your own forked version."
  },
  {
    "objectID": "manuals/git_workflow/index.html#working-with-vscode",
    "href": "manuals/git_workflow/index.html#working-with-vscode",
    "title": "DRAFT! Git Workflow",
    "section": "Working with VSCode",
    "text": "Working with VSCode\nSee the documentation for both the already installed Source Contro with Git and the GitLens extensions."
  },
  {
    "objectID": "documentation/math_num_comp/numerical_grids.html",
    "href": "documentation/math_num_comp/numerical_grids.html",
    "title": "Numerical Grids",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/math_num_comp/numerical_grids.html#global-structured-two-dimensional-grids",
    "href": "documentation/math_num_comp/numerical_grids.html#global-structured-two-dimensional-grids",
    "title": "Numerical Grids",
    "section": "Global, Structured, Two-Dimensional Grids",
    "text": "Global, Structured, Two-Dimensional Grids\nThe global, structured, two-dimensional grid is discretizing the surface of a perfectly spherical body of fixed radius \\(r\\) using a regular, structured grid with a fixed angular resolution \\(\\Delta\\vartheta\\times \\Delta\\varphi\\), in azimuth and elevation direction, respectively. Since the definition includes spherical elements, the grid is created in global spherical coordinates \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\), see 2.1.1 - Cartesian and Spherical Coordinates.\nThe spherical coordinates, the azimuth \\(\\vartheta\\) and elevation \\(\\varphi\\), are created as follows: \\[\\begin{alignat}{4}\n    \\vartheta_i &= - \\pi + \\frac{\\pi}{N_\\vartheta} + (i-1)\\Delta\\vartheta& \\quad\\text{for } i \\in \\{1, \\dots, N_\\vartheta\\} & \\quad\\text{with } \\Delta\\vartheta= \\frac{2\\pi}{N_\\vartheta} \\label{eq:gs2dgrid_azimuth} \\\\\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi& \\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\} & \\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi} \\label{eq:gs2dgrid_elevation}\n\\end{alignat}\\] where \\(N_\\vartheta\\) and \\(N_\\varphi\\) define the number of elements in the azimuth and elevation direction, respectively. The created points of the grid are located in the center of each rectangular grid cell, i.e., at \\(\\Delta\\vartheta/ 2 = \\pi /N_\\vartheta\\) and \\(\\Delta\\varphi/ 2 = \\pi / \\left(2N_\\varphi\\right)\\) of each elements sides. Let \\(k\\) be a common index with \\(k = (i-1)N_\\varphi+ j\\), then every grid element’s coordinate can be written as \\(\\boldsymbol{\\mathbf{r}}_k = \\left(r, \\vartheta_i, \\varphi_j\\right)\\).\n\n\n\n\n\n\nAzimuth Periodicity\n\n\n\n\n\nDue to the \\(2\\pi\\)-periodicity of the azimuth angle \\(\\vartheta\\), the structure, which is the constant \\(\\Delta\\vartheta\\) angular distance between elements, has to be shown across its periodic boundaries: \\[\\begin{align*}\n    \\vartheta_1 + 2\\pi - \\vartheta_{N_\\vartheta} &= \\left(- \\pi + \\frac{\\pi}{N_\\vartheta}\\right) + 2\\pi - \\left(- \\pi + \\frac{\\pi}{N_\\vartheta} + (N_\\vartheta-1)\\frac{2\\pi}{N_\\vartheta} \\right) = \\frac{2\\pi}{N_\\vartheta} = \\Delta\\vartheta\n\\end{align*}\\]\n\n\n\nWith the same index notation, the area of each spherical grid element can be calculated as the integral over its angles at each angular position: \\[\\begin{align}\n    A_k &= \\int_{\\vartheta_i-\\frac{\\Delta\\vartheta}{2}}^{\\vartheta_i+\\frac{\\Delta\\vartheta}{2}} \\int_{\\varphi_j-\\frac{\\Delta\\varphi}{2}}^{\\varphi_j+\\frac{\\Delta\\varphi}{2}} r^2 \\cos \\left( \\varphi\\right) d\\varphi d\\vartheta\\\\\n    \\Rightarrow\\qquad A_k &= r^2 \\cdot \\Delta\\vartheta\\cdot \\left(\\sin\\left(\\varphi_j + \\frac{\\Delta\\varphi}{2}\\right) - \\sin\\left(\\varphi_j - \\frac{\\Delta\\varphi}{2}\\right)\\right).\n    \\label{eq:area_gs2dgrid}\n\\end{align}\\] Note that the definition for the area is independent of the azimuth angle \\(\\vartheta\\), thus equal across all \\(N_\\vartheta\\) elements in the azimuth direction.\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 1: Global, structured, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e. radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_2d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_proj(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_3d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if abs(theta) &gt;= 90; continue; end\n        theta -= 180/N_theta\n        x = [cosd(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [sind(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        z = [sin(x) for x in range(-pi/2,pi/2,100)]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all()\n    gs2dgrid_2d(20,10)\n    gs2dgrid_proj(20,10)\n    gs2dgrid_3d(20,10)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$) ;\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190) ;\n\n\\end{tikzpicture}\n\n\n\n figure.svg \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\nFigure 1 shows an example of a spherical surface discretization based on the global, structured, two-dimensional grid. Elements were created based on Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\) with \\(N_\\vartheta= 20\\) elements in azimuth and \\(N_\\varphi= 10\\) elements in elevation, leading to a total of \\(200\\) grid elements and, thus, coordinates \\(\\boldsymbol{\\mathbf{r}}_k\\) for \\(k\\in\\{1,\\dots,200\\}\\). The grid resolution is \\(\\Delta\\vartheta\\times\\Delta\\varphi= 18\\,\\mathrm{\\degree}\\times18\\,\\mathrm{\\degree}\\). The figure shows three different views of the same numerical discretization. The top left in a conventional axis making use of the two-dimensionality of the grid, with the azimuth angle \\(\\vartheta\\) on the horizontal axis and the elevation angle \\(\\varphi\\) on the vertical axis. This view highlights the structured nature of the discretization scheme with equally resolved angular elements across the entire domain. The centered graph is a projected view of the spherical coordinates, visualized on a flattened spherical surface based on a projection method . While this flattened surface is neither a conformal nor an equal-area projection of an actual sphere, it provides a good and easily understandable visual representation of the spherical nature of the grid. The structure of the discretization scheme is still visible, while the accumulation of grid elements in the polar region becomes apparent. This accumulation is a direct result of the spherical nature of the grid, where the same angular resolution \\(\\Delta\\vartheta\\times\\Delta\\varphi\\) leads to a smaller area of the grid elements in the polar region. The bottom right graph depicts the same discretization scheme in a conventional, cartesian coordinate system, which shows the grid in its physical, three-dimensional form, where the polar grid elements are undistorted. Note that this last representation of the grid only shows half of the sphere (\\(x&gt; 0\\)) since the other half is identical due to the symmetry of the spherical coordinate system.\nThe transformation from one of the visualizations to another is termed either a or a in Figure 1, depending on the type of coordinate system of the destination. The compilation of the three shown views helps to understand both the structural nature of the grid and the general downside of using such a simple discretization scheme, i.e., the clumping of elements around the poles. As already apparent from the area calculation seen in Eq. \\(\\eqref{eq:area_gs2dgrid}\\), the surface coverage of each element on the same elevation is equal, while it decreases with \\(\\sin\\varphi\\rightarrow 0\\) towards the poles.\nIn many applications of numerical grids, it is necessary to map coordinates in the continuous domain to the discrete grid points, i.e., to find the grid element the continuous coordinate is located in. For the structural grid, the problem can be defined in terms of the shared index \\(k\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\boldsymbol{\\mathbf{r}}_k = \\left[r, \\vartheta_k, \\varphi_k\\right]^T\\), or in terms of the individual indices \\(i\\) and \\(j\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\left[r, \\vartheta_i, \\varphi_j\\right]\\) with \\(k = (i-1)N_\\varphi+ j\\). The latter approach can be analytically solved for the azimuth and elevation indices using the function, \\(\\lceil\\bullet\\rceil\\), to round the floating-point calculations to the next higher integer index: \\[\\begin{align}\n    i &= \\left\\lceil \\frac{\\left(\\vartheta+\\pi\\right)N_\\vartheta}{2\\pi} \\right\\rceil = \\left\\lceil \\frac{\\vartheta+\\pi}{\\Delta\\vartheta} \\right\\rceil, \\label{eq:gs2dgrid_coord2idx_azimuth}\\\\\n    j &= \\left\\lceil \\frac{\\left(\\varphi+\\pi/2\\right)N_\\varphi}{\\pi} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil. \\label{eq:gs2dgrid_coord2idx_elevation}\n\\end{align}\\] Numerical problems can arise around the boundaries of the numerical grid due to \\(\\lceil 0 \\rceil = 0\\). As no zeroth grid element exists, the inputs must be pretreated to avoid this problem. For the azimuth angle, the angle is mapped to the half-open interval \\(\\left(-\\pi, \\pi\\right]\\), thus if \\(\\vartheta=-\\pi\\) then \\(\\vartheta\\mapsto \\vartheta+ 2\\pi\\). The elevation is mapped to the open interval \\(\\left(-\\pi/2, \\pi/2\\right)\\) and should \\(|\\varphi| = \\pi/2\\) then \\(\\varphi\\mapsto \\varphi- \\mathop{\\mathrm{sgn}}\\left(\\varphi\\right)\\epsilon\\), with the machine accuracy \\(\\epsilon\\) being the smallest floating point number available to the machine.\nFor some applications, equatorial symmetry of the underlying problem can be assumed, which can be exploited to reduce the number of grid elements. In this case, the grid is only defined for \\(\\varphi\\in \\left[0, \\pi/2\\right)\\), and the elevation is subsequently calculated similar to Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\): \\[\\begin{equation}\n    \\varphi_j = \\frac{\\pi}{4N_\\varphi} + (j-1)\\Delta\\varphi\\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\}  \\quad\\text{with}\\quad \\Delta\\varphi= \\frac{\\pi}{2N_\\varphi}\n    \\label{eq:gs2dgrid_eqsim_elevation}\n\\end{equation}\\] This also changes the function mapping continuous coordinates to specific and discrete grid elements; see Eq. \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\): \\[\\begin{equation}\n    j = \\left\\lceil \\frac{\\left|\\varphi\\right| \\cdot N_\\varphi}{\\pi/2} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil.\n    \\label{eq:gs2dgrid_eqsim_coord2idx_elevation}\n\\end{equation}\\] Taking the absolute value of the elevation angle in the equation above ensures that the function is defined for the entire sphere. Still, the mapping always projects the coordinate onto the upper hemisphere.\n\n\n\n\n\n\nExESS API - Two-Dimensional Global Structured Grids\n\n\n\n\n\n\nGlobalStructuredGrid: global, structured grids, see Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\) - \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\nGlobalStructuredGrid_EqSim: global, structured, equatorially symmetric grids, additionally see Eqs. \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\) - \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)\n\nUtility functions:\n\nareas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)\ncoords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\), and \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\)\ncoord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\), and \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)\nsurfacecoords: identical to coords\nvolumes: zero, since only two-dimensions"
  },
  {
    "objectID": "documentation/math_num_comp/numerical_grids.html#global-structured-reduced-two-dimensional-grids",
    "href": "documentation/math_num_comp/numerical_grids.html#global-structured-reduced-two-dimensional-grids",
    "title": "Numerical Grids",
    "section": "Global, Structured, Reduced, Two-Dimensional Grids",
    "text": "Global, Structured, Reduced, Two-Dimensional Grids\nIn order to counter the disadvantages of the full grid, the reduced, structured grid was introduced. The main goal of this discretization scheme is to keep the advantages of the structured grid as much as possible while reducing the number of elements, especially those at high elevation angles. Mathematically speaking, during the creation of the grid, the individual elements are as close as possible to equal area squares with a constant, physical resolution of \\(\\left(r\\cdot\\cos\\varphi\\cdot\\Delta\\vartheta\\right)\\times\\left(r\\cdot\\Delta\\varphi\\right)\\).\nThe coordinates for the grid are calculated by iterating over the fixed number \\(N_\\varphi\\) of elevation angles (which calculation is equal to the standard, structured grid, see Eq.~(\\(\\ref{eq:gs2dgrid_elevation}\\))), which lead to a variable number \\(\\left(N_\\vartheta\\right)_j\\) of azimuth angles for each elevation angle \\(\\varphi_j\\): \\[\\begin{alignat}{3}\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi&&\\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi}  \\label{eq:gs2dgrid_reduced_elevation} \\\\\n    &\\Rightarrow\\quad \\left(N_\\vartheta\\right)_j = \\left\\lceil \\frac{2\\pi\\varphi_j}{\\pi N_\\varphi} \\right\\rceil \\label{eq:gs2dgrid_reduced_azimuth_elements} \\\\\n    \\vartheta_{i,j} &= - \\pi + \\frac{\\pi}{\\left(N_\\vartheta\\right)_j} + (i-1)\\Delta\\vartheta_j &&\\quad\\text{with } \\Delta\\vartheta_j = \\frac{2\\pi}{\\left(N_\\vartheta\\right)_j} \\label{eq:gs2dgrid_reduced_azimuth}\n\\end{alignat}\\] for \\(j \\in \\{1, \\dots, N_\\varphi\\}\\) and \\(i \\in \\{1, \\dots, \\left(N_\\vartheta\\right)_j\\}\\), respectively.\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 2: Global, structured, reduced, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e. radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_reduced_2d(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n    ylims!(ax, -90, 90)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_proj(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_3d(N_phi=10;)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            if abs(theta) &gt;= 90; continue; end\n            phi0, phi1 = -90 + (i-1)*180/length(grid.N_theta), -90 + i*180/length(grid.N_theta)\n            \n            x = [cosd(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            y = [sind(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            z = [sind(x) for x in range(phi0,phi1,100)]\n\n            lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all(N=10)\n    gs2dgrid_reduced_2d(N)\n    gs2dgrid_reduced_proj(N)\n    gs2dgrid_reduced_3d(N)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_reduced_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$) ;\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190) ;\n\n\\end{tikzpicture}\n\n\n\n figure.svg \n  2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png"
  },
  {
    "objectID": "documentation/math_num_comp/numerical_grids.html#global-healpix-two-dimensional-grids",
    "href": "documentation/math_num_comp/numerical_grids.html#global-healpix-two-dimensional-grids",
    "title": "Numerical Grids",
    "section": "Global, HEALPix, Two-Dimensional Grids",
    "text": "Global, HEALPix, Two-Dimensional Grids"
  },
  {
    "objectID": "documentation/introduction.html",
    "href": "documentation/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Introduction\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, Alexander. 2023. “ExESS - Extraterrestrial Exosphere and\nSurface Simulations.” 2023. https://smolkaa.github.io."
  },
  {
    "objectID": "documentation/fundamentals/moon.html",
    "href": "documentation/fundamentals/moon.html",
    "title": "The Moon",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#lunar-surface-temperatures",
    "href": "documentation/fundamentals/moon.html#lunar-surface-temperatures",
    "title": "The Moon",
    "section": "Lunar Surface Temperatures",
    "text": "Lunar Surface Temperatures\nAboard the LRO the DLRE gathered infrared data of the lunar surface to create temperatures maps of the Moon.\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Based on a Diviner measurement snapshot.\n\n\n\n\n\n\n\n(b) Based on the average Diviner measurements.\n\n\n\n\n\n\n\n\n\n(c) Based on the analytic function of Butler (1997).\n\n\n\n\n\n\n\n(d) Based on the analytic function of Hurley et al. (2015)\n\n\n\n\nFigure 1: Global, stationary lunar surface temperature maps. Coordinates given with respect to the subsolar point at \\((\\Theta_{ss}, \\Phi_{ss}) = (0,0)\\), presented in local time and subsolar latitude.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes\n    \ncmap = ColorSchemes.lipari\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = MyLTGeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction lunarSurfaceTemperaturesDivinerAverage(name=\"lunarSurfaceTemperatureDivinerAverage\")\n    fig, ga, theta, phi = _default_()\n    \n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner_avg(theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\")\n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesDiviner(name=\"lunarSurfaceTemperatureDiviner\")\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesBUTLER(name=\"lunarSurfaceTemperatureBUTLER\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_BUTLER1997(theta, phi)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesHURLEY(name=\"lunarSurfaceTemperatureHURLEY\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_HURLEY2015(theta, phi)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction run_all()\n    lunarSurfaceTemperaturesDivinerAverage()\n    lunarSurfaceTemperaturesDiviner()\n    lunarSurfaceTemperaturesBUTLER()\n    lunarSurfaceTemperaturesHURLEY()\nend\n\n\n\n diviner.png \n diviner_average.png \n butler.png \n hurley.png \n\n\n\n\nButler (1997) proposed an analytical surface temperature distribution based on the solar zenith angle \\(\\psi_s\\) with regard to the local surface normal, assuming a perfectly spherical Moon, see Figure 1. Given the subsolar position \\(\\left(\\Theta_{ss}, \\Phi_{ss}\\right)\\), longitude and latitude respectively, the cosine of the zenith angle can be calculate as \\(\\cos\\psi_s = \\cos\\Theta_{ss} \\cdot \\cos\\Phi_{ss}\\). All measurements of the lunar surface temperatures on the dayside suggest a \\(\\cos^{1/4}\\) shape with regard to the solar zenith angle (Vasavada et al. 2012; Hurley et al. 2015), though such models break down on the nightside. By introducing a cutoff at the terminators alongside a defined nightside temperature shifting the distribution up, Butler (1997) arrived at \\[\\begin{equation}\n    T(\\psi_s) = \\begin{cases}\n        250\\,\\mathrm{K} \\cdot \\cos^{1/4} (\\psi_s) + 100\\,\\mathrm{K}, \\qquad & \\text{ if } \\psi_s \\leq 90\\,\\mathrm{\\degree}, \\\\\n        100\\,\\mathrm{K}, & \\text{ if } \\psi_s &gt; 90\\,\\mathrm{\\degree}.\n    \\end{cases} \\label{eq:lunar_surface_temperatures_BUTLER}\n\\end{equation}\\]\nHurley et al. (2015) proposed another model to further improve the analytical description of the lunar surface temperatures, which included a combination of a cosine-law dependence on the dayside and a 6-term polynomial fitted cooling function for the nightside: \\[\\begin{equation}\n    T(\\Theta_{ss}, \\Phi_{ss}) = \\begin{cases}\n        262\\,\\mathrm{K} \\cdot \\cos^{1/2} \\left( \\psi_s \\right) + 130\\,\\mathrm{K}, \\qquad & \\text{ if } \\left|\\Theta_{ss}\\right| &lt; 90\\,\\mathrm{\\degree}, \\\\\n        \\left( \\sum_{i=0}^5 a_i \\Theta_{ss}^i \\right) + 35\\,\\mathrm{K} \\left( \\sin \\overline{\\Phi_{ss}} - 1\\right), \\qquad & \\text{ else.}\n    \\end{cases} \\label{eq:lunar_surface_temperatures_HURLEY}\n\\end{equation}\\] with the longitude \\(\\Theta_{ss}\\) and the subsolar co-latitude \\(\\overline{\\Phi_{ss}} = \\pi/2 - \\Phi_{ss}\\). The coefficients of the polynomial fit are \\(a = \\left[444.738,\\; -448.937,\\; 239.668,\\; -63.8844,\\; 8.34064,\\; -0.423502 \\right]\\) in kelvin. Note that the longitude has to be used in radians and must be positively defined on the range of \\(\\Theta_{ss} \\in \\left(\\pi/2, 3\\pi/2\\right)\\) for the nightside.\n\n Figure Julia - Mean Julia - RMS Downloads\n\n\n\n\n\n\n\n\n\n(a) Statistical temperature difference mean.\n\n\n\n\n\n\n\n(b) Root mean squared error of temperature differences.\n\n\n\n\nFigure 2: Statistical comparison of the lunar surface temperatures models with Diviner measurements. Temperature difference based on analytical functions by Butler (1997), Eq. \\(\\eqref{eq:lunar_surface_temperatures_BUTLER}\\), and Hurley et al. (2015), Eq. \\(\\eqref{eq:lunar_surface_temperatures_HURLEY}\\), compared to the averaged Diviner measurements and evaluated on grid points, equally distributed and weighted with their respective surface area. Comparisons are represented by their statistical mean (a) and their root mean squared error (b), applied globally (circles), on the dayside (squares), and on the nightside (diamonds).\n\n\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_rms(N=18, name=\"temperature_comparison_rms\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, sqrt(mean(dTBlat.^2)))  \n        push!(eBd, sqrt(mean(dTBlatd.^2)))\n        push!(eBn, sqrt(mean(dTBlatn.^2)))\n        push!(eH, sqrt(mean(dTHlat.^2)))  \n        push!(eHd, sqrt(mean(dTHlatd.^2)))\n        push!(eHn, sqrt(mean(dTHlatn.^2)))\n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"RMS Temperature Differences [K]\",\n        yticks=0:20:70,)\n    ylims!(0, 70)\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n        [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false,\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_mean(N=18, name=\"temperature_comparison_mean\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, mean(dTBlat))   \n        push!(eBd, mean(dTBlatd)) \n        push!(eBn, mean(dTBlatn)) \n        push!(eH, mean(dTHlat))   \n        push!(eHd, mean(dTHlatd)) \n        push!(eHn, mean(dTHlatn)) \n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"Mean Temperature Differences [K]\")\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n    [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\n\n mean.pdf   mean.svg   mean.png \n rms.pdf   rms.svg   rms.png \n\n\n\n\nThe two presented analytical models of the lunar surface temperatures have been compared with the averaged DLRE measurements. Figure 2 shows this statistical analysis of the temperatures difference of the Butler (1997) and Hurley et al. (2015) calculated as \\(\\Delta T_i = T_i - T_\\text{Diviner}\\) for each analytical model \\(i\\), evaluated on surface points, globally distributed using the HEALPix method.\nThe left side shows the statistical mean of said temperature differences as a function of subsolar latitude for both models, both globally as well as exclusively on the dayside and nightside of the Moon. Up to \\(\\Phi_{ss}=60\\,\\mathrm{\\degree}\\), the Hurley et al. (2015) model has global means very close to zero, with slight deviations for the exclusive day- and nightside. Closer to the poles, the model tends towards positive temperature differences, peaking at around above the Diviner model on the sunlit side. Using the model by Butler (1997) this effect is even more pronounced with the means starting below zero at the equator and continuously increasing with higher latitudes. Final values close to the poles reach temperature differences of more than on the dayside.\nTo further investigate the two models, the [rms}$ value of the temperature differences \\[\\begin{equation}\n    \\Delta T_{\\text{rms}, i} = \\sqrt{\\frac{1}{N_j} \\cdot \\sum_j^{N_j} \\left(\\Delta T_{i,j}\\right)^2},\n\\end{equation}\\] for \\(N_j\\) applicable positions \\(j\\) is shown on the right side of Figure 2. In comparison with the previously shown statistical mean, the rms shows the spread of the temperatures around the mean. For all cases, globally, dayside, and nightside, the Hurley et al. (2015) model has lower rms values, which are less than for latitude uo to . Closer to the poles and similar to the mean value, the dayside temperatures tend to deviate the most, peaking at at . Generally, a steadily increasing behaviour with higher latitudes can be observed. For the Butler (1997) model, the rms values start out considerably higher with the worst deviations on the dayside of the Moon. For roughly from the equator, the values are decreasing to a lowest value of before sharply increasing polewards of it."
  },
  {
    "objectID": "documentation/acronyms.html#latex---glossary-acronyms-definition",
    "href": "documentation/acronyms.html#latex---glossary-acronyms-definition",
    "title": "Acronyms",
    "section": "LaTeX - Glossary Acronyms Definition",
    "text": "LaTeX - Glossary Acronyms Definition\n\\newacronym{ALSEP}{ALSEP}{Apollo Lunar Surface Experiments Package}\n\n\\newacronym{cdf}{cdf}{cumulative distribution function}\n\n\\newacronym{DLRE}{DLRE}{Diviner Lunar Radiometer Experiment}\n\n\\newacronym{ESA}{ESA}{European Space Agency}\n\n\\newacronym{LACE}{LACE}{Lunar Atmospheric Composition Experiment}\n\\newacronym{LADEE}{LADEE}{Lunar Atmosphere and Dust Environment Explorer}\n\\newacronym{LRO}{LRO}{Lunar Reconnaissance Orbiter}\n\n\\newacronym{HEALPix}{HEALPix}{Hierarchical Equal Area iso-Latitude Pixelization}\n\n\\newacronym{MBD}{MBD}{Maxwell-Boltzmann Distribution}\n\\newacronym{MBFD}{MBFD}{Maxwell-Boltzmann Flux Distribution}\n\n\\newacronym{NASA}{NASA}{National Aeronautis and Space Administration}\n\\newacronym{NMS}{NMS}{Neutral Mass Spectrometer}\n\n\\newacronym{pdf}{pdf}{probability density function}\n\\newacronym{PDS}{PDS}{Planetary Data System}\n\n\\newacronym{rms}{rms}{root mean squared}\n\n\\newacronym{SSE}{SSE}{Selenocentric Solar Ecliptic}\n\n\\newacronym{TUM}{TUM}{Technical University of Munich}"
  },
  {
    "objectID": "api/grids/utility.html",
    "href": "api/grids/utility.html",
    "title": "Utility",
    "section": "",
    "text": "ExESS: areas - Struct\n\n\n\n\n\n[1] areas([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns the surface area of each grid element. For 3D grids, returns the base area of each grid element.\n\n\n\n\n\n\n\n\n\n\nExESS: coords - Struct\n\n\n\n\n\n[1] coords([T::Type,] grid::AbstractGrid)\nReturns the coordinates of each grid element.\n\n\n\n\n\n\n\n\n\n\nExESS: coord2idx - Struct\n\n\n\n\n\n[1] coord2idx(grid::AbstractGlobalGrid, [r::Real,] theta::Real, phi::Real)\n[2] coord2idx(grid::AbstractGlobalGrid, [r::AbstractVector,] theta::AbstractVector, phi::AbstractVector)\n[3] coord2idx(grid::AbstractGlobalGrid, coords::AbstractPosition)\n[4] coord2idx(grid::AbstractGlobalGrid, coords::Vector{AbstractPosition})\nCalculates the index of the grid element containing the given coordinates.\n\n\n\n\n\n\n\n\n\n\nExESS: surfacecoords - Struct\n\n\n\n\n\n[1] surfacecoords([T::Type,] grid::AbstractGrid)\nReturns only the coordinates of the surface (i.e. the base) of the discretized geometry.\n\n\n\n\n\n\n\n\n\n\nExESS: volume - Struct\n\n\n\n\n\nNo documentation found.\nBinding Main.ExESS.volume does not exist."
  },
  {
    "objectID": "api/base/cs.html",
    "href": "api/base/cs.html",
    "title": "Coordinate Systems",
    "section": "",
    "text": "Coordinates in ExESS are implemented as their custom, three-dimensional vectors, which are based on their scope, the coordinate system, and their physical type. The scope can either be Global[...] or Local[...], which is referring to a fixed planetary system or a local reference frame, respectively. The coordinate system is either [...]Cartesian[...] or [...]Spherical[...], which is referring to a Cartesian or spherical coordinate system, respectively. The physical type is either [...]Position or [...]Velocity, which is referring to a position or velocity vector, respectively."
  },
  {
    "objectID": "api/base/cs.html#type-structure",
    "href": "api/base/cs.html#type-structure",
    "title": "Coordinate Systems",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractCoordinates\n    │\n    ├─ AbstractPosition\n    │  ├─ GlobalCartesianPosition{T&lt;:Real}\n    │  └─ GlobalSphericalPosition{T&lt;:Real}\n    │\n    └─ AbstractVelocity\n       ├─ GlobalCartesianVelocity{T&lt;:Real}\n       ├─ LocalCartesianVelocity{T&lt;:Real}\n       └─ GlobalSphericalVelocity{T&lt;:Real}\nMore information on the mathematical description of the different coordinate vectors and the mathematical foundation for the conversion functions are presented in Cartesian and Spherical Coordinates."
  },
  {
    "objectID": "api/base/cs.html#api",
    "href": "api/base/cs.html#api",
    "title": "Coordinate Systems",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nExESS: GlobalCartesianPosition - Struct\n\n\n\n\n\n[1] GlobalCartesianPosition(x::Real, y::Real, z::Real)\n[2] GlobalCartesianPosition(X::AbstractVector)\n[3] GlobalCartesianPosition(x::AbstractPosition)\nThree dimensional, global, cartesian position vector [1]. Converts vector or other position type into GlobalCartesianPosition [2,3].\n[1] GlobalCartesianPosition(sol::ODESolution, [idx::Integer])\n[2] GlobalCartesianPosition(sol::ODESolution, t::Real)\n[3] GlobalCartesianPosition(sol::ODESolution, t::AbstractVector)\nExtracts GlobalCartesianPosition from ODESolution at given index, all indexes, time or times. Note that this constructor assumes the solution object to be from a SecondOrderODEProblem, where the components of the solution vector are ordered as [vx, vy, vz, x, y, z].\n\n\n\n\n\n\n\n\n\n\nExESS: GlobalSphericalPosition - Struct\n\n\n\n\n\n[1] GlobalSphericalPosition(r::Real, theta::Real, phi::Real)\n[2] GlobalSphericalPosition(X::AbstractVector)\n[3] GlobalSphericalPosition(x::AbstractPosition)"
  },
  {
    "objectID": "api/api.html",
    "href": "api/api.html",
    "title": "Code",
    "section": "",
    "text": "The ExESS package is structured into four main parts, which are the four main folders in the /src directory:\n\n/base contains basic functionality that is used at multiple places in the code, e.g., physical constants, coordinate system definitions, utility functions, and some probability distributions.\n/grids contains all numerical discretization methods used in this package. While most functions can be called with AbstractVector inputs, their main use is meant to be in conjunction with the previously defined custom coordinate systems.\n/exospheres contains all scripts that define functions that have something to do with simulating the exosphere. Due to the assumption of surface-bounded exospheres, Monte-Carlo methods are the preferred simulation tool as each individual particle of the exosphere can be simulated independently. Implemented functionalities are mostly based on ballistic trajectory calculations.\n/surfaces contains all functions that are used to calculate surface properties, e.g., surface temperatures, reaction kinetics, thermal conductivities, and diffusion coefficients."
  },
  {
    "objectID": "api/base/constants.html",
    "href": "api/base/constants.html",
    "title": "Constants",
    "section": "",
    "text": "Constants\n\n\n\n\n\n\n\n\nBase - Constants\n\n\n\n\n\nAVOGADRO_CONSTANT:         6.022141e+23 [mol-1]\nBOLTZMANN_CONSTANT:        1.380650e-23 [m2 kg s-2 K-1]\nELEMENTARY_CHARGE:         1.602177e-19 [C]\nGRAVITATIONAL_CONSTANT:    6.674080e-11 [m3 kg-1 s-2]\nPLANCK_CONSTANT:           6.626070e-34 [m2 kg s-1]\nSTEFAN_BOLTZMANN_CONSTANT: 5.670000e-08 [W m-2 K-4]\nUNIVERSAL_GAS_CONSTANT:    8.314463e+00 [J K-1 mol-1]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - The Moon\n\n\n\n\n\nLUNAR_DAY:                 2.548800e+06 [s]\nLUNAR_MASS:                7.247673e+22 [kg]\nLUNAR_RADIUS:              1.737400e+06 [m]\nLUNAR_g0:                  1.602472e+00 [m s-2]\nLUNAR_vesc:                2.359718e+03 [m s-1]"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html",
    "href": "api/grids/global_structured_2d_grids.html",
    "title": "Global Structured Two-Dimensional Grids",
    "section": "",
    "text": "ExESS: GlobalStructured2DGrid - Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over a sphere of radius r.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nExESS: GlobalStructured2DGrid_EqSim - Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_EqSim([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2]."
  },
  {
    "objectID": "bibliography/bibliography.html#references",
    "href": "bibliography/bibliography.html#references",
    "title": "Biblography",
    "section": "References",
    "text": "References"
  },
  {
    "objectID": "documentation/documentation.html",
    "href": "documentation/documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Documentation\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, Alexander. 2023. “ExESS - Extraterrestrial Exosphere and\nSurface Simulations.” 2023. https://smolkaa.github.io."
  },
  {
    "objectID": "documentation/fundamentals/planetary_bodies.html",
    "href": "documentation/fundamentals/planetary_bodies.html",
    "title": "3.1 - Planetary Bodies with Surface-Bounded Exospheres",
    "section": "",
    "text": "CitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander and Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, Alexander, and Alexander Smolka. 2023. “ExESS -\nExtraterrestrial Exosphere and Surface Simulations.” 2023. https://smolkaa.github.io."
  },
  {
    "objectID": "documentation/math_num_comp/coordinate_systems.html",
    "href": "documentation/math_num_comp/coordinate_systems.html",
    "title": "Coordinate Systems",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/math_num_comp/coordinate_systems.html#cartesian-and-spherical-coordinates",
    "href": "documentation/math_num_comp/coordinate_systems.html#cartesian-and-spherical-coordinates",
    "title": "Coordinate Systems",
    "section": "Cartesian and Spherical Coordinates",
    "text": "Cartesian and Spherical Coordinates\nA clear distinction has been made between cartesian and spherical coordinates and cartesian and spherical elements. The former are used to describe the domain in which the vector is defined, while the latter are used to describe the vector and its components itself. For example, a position vector in a cartesian coordinate system, \\(\\boldsymbol{\\mathbf{x}}\\), can be expressed in cartesian elements \\(\\left(x, y, z\\right)\\), which are the x-, y-, and z-components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}= \\begin{bmatrix}\n        x\\\\\n        y\\\\\n        z\n    \\end{bmatrix} \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n    \\label{eq:cartesian_coordinate}\n\\end{equation}\\]\n\n\n\n\n\n\nExESS API - Cartesian Coordinates\n\n\n\n\n\nVectors defining a position or a velocity in a cartesian coordinate system and in cartesian elements, like the one shown in Eq. \\(\\eqref{eq:cartesian_coordinate}\\) are implemented as GlobalCartesianPosition and GlobalCartesianVelocity.\n\n\n\nThe same vector in the same coordinate system and, thus, the same domain, can also be expressed used spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\), which are the radial, azimuthal, and elevation components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}_s = \\begin{bmatrix}\n        r\\cos\\vartheta\\cos\\varphi\\\\\n        r\\sin\\vartheta\\cos\\varphi\\\\\n        r\\sin\\varphi\n    \\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n\\end{equation}\\] Note that the subscript \\(s\\) indicates that the vector is expressed in spherical elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s\\). On the other hand, a coordinate can also be projected into a spherical coordiante system, \\(\\boldsymbol{\\mathbf{r}}\\), which is a different domain, and expressed in spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}= \\begin{bmatrix}r\\\\ \\vartheta\\\\ \\varphi\\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n    \\label{eq:spherical_coordinate}\n\\end{equation}\\]\n\n\n\n\n\n\nExESS API – Spherical Coordinates\n\n\n\n\n\nVectors defining a position or a velocity in a spherical coordinate system and in spherical elements, like the one shown in Eq. \\(\\eqref{eq:spherical_coordinate}\\) are implemented as GlobalSphericalPosition and GlobalSphericalVelocity.\n\n\n\nThe same coordinate can also be expressed in cartesian elements \\(\\left(x, y, z\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}_c = \\begin{bmatrix}\n        \\sqrt{x^2 + y^2 + z^2} \\\\\n        \\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\\\\n        \\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\n    \\end{bmatrix}  \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n\\end{equation}\\] Note that the subscript \\(c\\) indicates that the vector is expressed in cartesian elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). Even though, physically speaking, all four coordinate vectors can describe the same position in physical space, mathematically speaking, they are different vectors, thus: \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s \\neq \\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). The following sections will go into more detail about the differences of these coordinate systems, where the names and are used to describe the domain and not the elements.\nAll coordinate vectors can also be written as a sum of scaled base vectors, where the base vectors are the unit vectors of the respective coordinate system. The base vectors of any cartesian coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_x= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_y= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the cartesian coordinate vector, for both in cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{x}}&= x\\hat{\\boldsymbol{\\mathbf{e}}}_x+ y\\hat{\\boldsymbol{\\mathbf{e}}}_y+ z\\hat{\\boldsymbol{\\mathbf{e}}}_z\\nonumber \\\\\n    &= \\left(r\\cos\\vartheta\\cos\\varphi\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\left(r\\sin\\vartheta\\cos\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\left(r\\sin\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\boldsymbol{\\mathbf{x}}_s.\n\\end{align}\\] Similarly, the base vectors of any spherical coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_r= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the spherical coordinate vector, for both in cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{r}}&= r\\hat{\\boldsymbol{\\mathbf{e}}}_r+ \\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ \\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\nonumber \\\\\n    &= \\left(\\sqrt{x^2 + y^2 + z^2}\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_r+ \\left(\\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ \\left(\\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\\\\n    &= \\boldsymbol{\\mathbf{r}}_c.\\nonumber\n\\end{align}\\]\nDue to the equalities of the vectors in their respective same coordinate system, the rest of this work will only use \\(\\boldsymbol{\\mathbf{x}}\\) and \\(\\boldsymbol{\\mathbf{r}}\\) without their indexed counterparts. The element type will be indicated by the context of the equation."
  },
  {
    "objectID": "documentation/math_num_comp/coordinate_systems.html#spacial-differentials",
    "href": "documentation/math_num_comp/coordinate_systems.html#spacial-differentials",
    "title": "Coordinate Systems",
    "section": "Spacial Differentials",
    "text": "Spacial Differentials\nThis work is regularly relying on vector calculus which includes a substantial use of differentials and derivatives. The former uses two kinds of notations, depending on the use case of the differential. First, mathematical differentials of vectors are the vectorized form of the differentials of the vector components. In the following, the differentials will be set up for stationary conditions with constant base vectors, i.e.\n\\[\\begin{align}\n    \\frac{\\partial}{\\partial t} &= 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial r} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\varphi} = 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial x} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial z} = 0.\n\\end{align}\\]\nFor example, the differential of a stationary cartesian coordinate vector and cartesian elements is\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{x}}= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial z}dz= dx\\hat{\\boldsymbol{\\mathbf{e}}}_x+ dy\\hat{\\boldsymbol{\\mathbf{e}}}_y+ dz\\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix} dx\\\\ dy\\\\ dz\\end{bmatrix},\n\\end{equation}\\]\nand for spherical coordinates and elements\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\varphi}d\\varphi= dr\\hat{\\boldsymbol{\\mathbf{e}}}_r+ d\\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ d\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}.\n\\end{equation}\\]\nThe above total differentials are relatively simple to set up since their respective partial differentials cancel out to only contain one variable each. However, the differentials for the cartesian vector in spherical elements and the spherical vector in cartesian elements are more complicated, with the former differential given by\n\\[\\begin{align}\n    d\\boldsymbol{\\mathbf{x}}&= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\varphi}d\\varphi\\\\\n    &= \\left(\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) dr\\nonumber \\\\\n    &+ \\left(-r\\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ r\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y\\right) d\\vartheta\\nonumber \\\\\n    &+ \\left(-r\\cos\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x- r\\sin\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ r\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) d\\varphi\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi&  -r\\sin\\vartheta\\cos\\varphi& -r\\cos\\vartheta\\sin\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi& r\\cos\\vartheta\\cos\\varphi& - r\\sin\\vartheta\\sin\\varphi\\\\\n        \\sin\\varphi& 0 & r\\cos\\varphi\n    \\end{bmatrix} \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}  \\label{eq:total_cartesian_spherical_differential_matrix}\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi dr-r\\sin\\vartheta\\cos\\varphi d\\vartheta-r\\cos\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi dr+ r\\cos\\vartheta\\cos\\varphi d\\vartheta- r\\sin\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\varphi dr+ r\\cos\\varphi d\\varphi\n    \\end{bmatrix}. \\label{eq:total_cartesian_spherical_differential}\n\\end{align}\\]\nThe resulting vector in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential}\\) contains the scalar differentials of the spherical elements in each of its entries, which can also be pulled out of the vector and written as a linear combination using a matrix notation, shown in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\). While the differential of a spherical vector in cartesian elements can be calculated in the same way, which is \\(d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial z}dz\\), its trigonometric functions and subsequent differentiations make it less common and inefficient to use, which is why it is not shown here for brevity.\nThese vectorized total differentials are regularly used in vector calculus. A prime example is calculating the gradient \\(\\nabla\\) of a scalar function \\(f\\), which is given by \\[\\begin{equation}\n    \\frac{df}{d\\boldsymbol{\\mathbf{x}}} = \\nabla f = \\begin{bmatrix}\n        \\frac{\\partial f}{\\partial x} \\\\\n        \\frac{\\partial f}{\\partial y} \\\\\n        \\frac{\\partial f}{\\partial z}\n    \\end{bmatrix},\n\\end{equation}\\] as an example in a cartesian coordinate system and with cartesian elements. Many problems feature the second-order derivatives of a scalar function, which is called the Laplacian \\(\\nabla^2\\) and is given by \\[\\begin{equation}\n    \\nabla \\cdot \\nabla f = \\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}.\n\\end{equation}\\]\nBoth the gradient and the laplacian can also be expressed in spherical coordinates. The former makes use of the chain rule of differentiation, which evaluates to the inverse matrix of the coordinate projection of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\): \\[\\begin{align}\n    \\begin{bmatrix}\n        \\frac{\\partial}{\\partial x} \\\\\n        \\frac{\\partial}{\\partial y} \\\\\n        \\frac{\\partial}{\\partial z}\n    \\end{bmatrix} &= \\begin{bmatrix}\n        \\frac{\\partial r}{\\partial x} & \\frac{\\partial\\vartheta}{\\partial x} & \\frac{\\partial\\varphi}{\\partial x} \\\\\n        \\frac{\\partial r}{\\partial y} & \\frac{\\partial\\vartheta}{\\partial y} & \\frac{\\partial\\varphi}{\\partial y} \\\\\n        \\frac{\\partial r}{\\partial z} & \\frac{\\partial\\vartheta}{\\partial z} & \\frac{\\partial\\varphi}{\\partial z}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix} \\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi& -\\frac{\\sin\\vartheta}{r\\cos\\varphi} & -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\vartheta\\cos\\varphi& \\frac{\\cos\\vartheta}{r\\cos\\varphi} & -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\varphi& 0 & \\frac{\\cos\\varphi}{r}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial x} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_x}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial y} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_y}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial z} &= \\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}. \\label{eq:spherical_gradient_z}\n\\end{align}\\] The latter can be derived by applying the chain rule twice, which is a tedious but straightforward calculation, leading to: \\[\\begin{align}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right). \\label{eq:laplace_spherical}\n\\end{align}\\]\n\n\n\n\n\n\nDerivation of spherical Laplace operator.\n\n\n\n\n\nThe laplacian is the linear summation of the second-order cartesian partial derivative \\(\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\). The spherical laplacian can be derived by applying the chain rule of partial derivatives, shown in the gradient derivation in Eqs. \\(\\eqref{eq:spherical_gradient_x}\\), \\(\\eqref{eq:spherical_gradient_y}\\), \\(\\eqref{eq:spherical_gradient_z}\\) twice: \\[\\begin{align*}\n    \\frac{\\partial^2}{\\partial x^2} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial x} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial x} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial x} \\\\\n    &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\right) \\\\\n    &- \\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial y^2} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial y} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial y} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial y} \\\\\n    &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &+ \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial z^2} &= \\sin\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial z} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial z} \\\\\n    &= \\sin\\varphi\\frac{\\partial}{\\partial r} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right).\n\\end{align*}\\] Evaluating all partial derivatives and summing up all terms leads to a miraculous cancellation of terms, finally arriving at the following expression of Eq.~(\\(\\ref{eq:laplace_spherical}\\)) for the Laplacian in spherical coordinates: \\[\\begin{align*}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right).\n\\end{align*}\\]\n\n\n\nAnother example of the use of differentials is in integration, where it is used to represent an infinitesimal change in the variable. Shorthand versions of multi-dimensional integrals are often written using vector variables, such as \\[\\begin{equation}\n    \\int_X \\int_Y \\int_Z f dzdydx= \\int_Vf d^3\\boldsymbol{\\mathbf{x}},\n\\end{equation}\\] where \\(V\\) is the volume of the integration domain, with the infinitesimal volume element \\(d^3\\boldsymbol{\\mathbf{x}}\\in V= \\left\\{dx\\, dy\\, dz\\; | \\; dx\\in X, dy\\in Y, dz\\in Z \\right\\}\\). The superscript \\(\\bullet^3\\) in the differentials indicates that the differential is a vector but a scalar representation of the element’s size created by the vector elements. As before, the differential \\(d^3\\boldsymbol{\\mathbf{x}}\\) can also be expressed in spherical elements by using the Jacobian determinant, which is equal to the matrix of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\), of the transformation: \\[\\begin{equation}\n    d^3\\boldsymbol{\\mathbf{x}}= \\left|\\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\boldsymbol{\\mathbf{r}}}\\right| d^3\\boldsymbol{\\mathbf{r}}= r^2\\cos\\varphi drd\\vartheta d\\varphi.\n\\end{equation}\\] Figure 1 illustrates the spherical differential element \\(d^3\\boldsymbol{\\mathbf{r}}\\) in a three-dimensional cartesian coordinate system. The azimuth angle \\(\\vartheta\\) rotates inside of the \\(x\\)–\\(y\\) plane, while the elevation angle \\(\\varphi\\) rotates the vector out of that plane in \\(z\\) direction. While the azimuth arc decreases with the sine of the elevation angle, the small angle approximation can be used to approximate the differential element as a cuboid with the volume \\(d^3\\boldsymbol{\\mathbf{r}}\\approx r^2 \\sin\\varphi\\, drd\\vartheta d\\varphi\\).\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Three-dimensional sketch of a spherical differential element in a cartesian coordinate system.\n\n\n\n\n% based on: https://tikz.net/spherical_volume/\n\n%Axis Angles\n\\tdplotsetmaincoords{70}{110}\n\n%Macros\n\\pgfmathsetmacro{\\rvec}{6}\n\\pgfmathsetmacro{\\elevationvec}{40}\n\\pgfmathsetmacro{\\azimuthvec}{45}\n\n\\pgfmathsetmacro{\\dazimuthvec}{20}\n\\pgfmathsetmacro{\\delevationvec}{20}\n\\pgfmathsetmacro{\\drvec}{1.5}\n\n%Layers\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\pgfsetlayers{background, main, foreground}\n\n\\begin{tikzpicture}[tdplot_main_coords]\n    \n    %Coordinates\n    \\coordinate (O) at (0,0,0);\n    %\n    \\tdplotsetcoord{A}{\\rvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{B}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{C}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{D}{\\rvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    %\n    \\tdplotsetcoord{E}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F'}{\\rvec + \\drvec}{90}{\\azimuthvec}\n    \\tdplotsetcoord{G}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{G'}{\\rvec + \\drvec}{90}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{H}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    \n    %Axis\n    \\begin{pgfonlayer}{background}\n        \\draw[thick,-latex] (0,0,0) -- (7,0,0) node[pos=1.1]{$\\cartesianCoordinateX$};\n        \\draw[thick,-latex] (0,0,0) -- (0,7,0) node[pos=1.05]{$\\cartesianCoordinateY$};\n        \\draw[thick,-latex] (0,0,0) -- (0,0,6) node[pos=1.05]{$\\cartesianCoordinateZ$};\n    \\end{pgfonlayer}\n    \n    %Help Lines\n    \\begin{pgfonlayer}{background}\n        %Up\n        \\draw[thick, black] (O) -- (A) node[pos=0.6, above left, black] {$\\sphericalCoordinateRadius$};\n        \\draw (O) -- (B);\n        \\draw (O) -- (C);\n        \\draw[dashed] (O) -- (D);\n        %Down\n        \\draw (O) -- (F');\n        \\draw (O) -- (G');\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        %%Help Curves\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotsetthetaplanecoords{\\azimuthvec+\\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, dashed]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        %\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n        \\node[rotate=13] at (3,4.45,0) {$\\sphericalCoordinateRadius\\sin\\sphericalCoordinateElevation d\\sphericalCoordinateAzimuth$};\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec+\\drvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n    \\end{pgfonlayer}\n    \n    \n    %Angles\n    \\begin{pgfonlayer}{foreground}\n        %Phi, dPhi\n        \\tdplotdrawarc[-stealth]{(O)}{0.9}{0}{\\azimuthvec}{anchor=north}{$\\sphericalCoordinateAzimuth$}\n        \\tdplotdrawarc[-stealth]{(O)}{1.5}{\\azimuthvec}{\\azimuthvec + \\dazimuthvec}{}{}\n        \\node at (1.4,1.9,0) {$ d\\sphericalCoordinateAzimuth$};\n        \n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \n        %Theta, dTheta\n        \\tdplotdrawarc[tdplot_rotated_coords, -stealth]{(0,0,0)}{1.2}{90}{\\elevationvec + \\delevationvec}{}{}\n        %\\node at (0,0.3,1.3) {$\\sphericalCoordinateElevation$};\n        \\node at (1,1.25,0.55) {$\\sphericalCoordinateElevation$};\n        \\tdplotdrawarc[tdplot_rotated_coords, stealth-]{(0,0,0)}{2.}{\\elevationvec}{\\elevationvec + \\delevationvec}{anchor=south west}{$ d\\sphericalCoordinateElevation$}\n    \\end{pgfonlayer}\n    \n    %Differential Volume\n    \n    %%Lines\n    \\begin{pgfonlayer}{foreground}\n        \\draw[thick] (A) -- (E) node[midway, above left]{$ d\\sphericalCoordinateRadius$};\n        \\draw[thick] (B) -- (F);\n        \\draw[thick] (C) -- (G);\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        \\draw[dashed, thick] (D) -- (H);\n    \\end{pgfonlayer}\n    \n    \n    %%Curved\n    \\begin{pgfonlayer}{background}\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{below left}{$\\sphericalCoordinateRadius d\\sphericalCoordinateElevation$}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-30.3813}{-8.6492}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{17.2983}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{17.2983}{}{}\n    \\end{pgfonlayer}\n    \n    %Fill Color\n    \\begin{pgfonlayer}{main}\n        %Front\n        \\fill[black, opacity=0.15] (E) to (A)  to[bend left=4] (B) to (F) to[bend right=4] cycle;\n        \\fill[black, opacity=0.6] (E) to[bend left=4] (F)  to[bend left=2] (G) to[bend right=6.5] (H) to[bend right=4] cycle;\n        \\fill[black, opacity=0.4] (F) to[bend left=2] (G) to[bend left=1.5] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        %Back\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to[bend left=6] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to (H) to[bend right=2.5] (E) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (D) to (H) to[bend left=6] (G) to[bend right=2] (C) to[bend right=6] cycle;\n    \\end{pgfonlayer}\n        \n\\end{tikzpicture}"
  },
  {
    "objectID": "documentation/math_num_comp/coordinate_systems.html#temporal-differentials",
    "href": "documentation/math_num_comp/coordinate_systems.html#temporal-differentials",
    "title": "Coordinate Systems",
    "section": "Temporal Differentials",
    "text": "Temporal Differentials"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "",
    "text": "This website is still under construction!"
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Citation",
    "text": "Citation\nDownload citation:"
  },
  {
    "objectID": "manuals/manuals.html",
    "href": "manuals/manuals.html",
    "title": "Manuals",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nDRAFT! Git Workflow\n\n\nAlexander Smolka\n\n\n\n\nExESS Package Installation\n\n\nAlexander Smolka\n\n\n\n\n\n\nNo matching items"
  }
]