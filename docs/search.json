[
  {
    "objectID": "additionals/essentials/julia_links/index.html",
    "href": "additionals/essentials/julia_links/index.html",
    "title": "Julia Programming Language: Links & Resources",
    "section": "",
    "text": "Julia is a cutting-edge, high-level programming language designed to address the unique challenges of scientific computing and data analytics. Born in 2012, Julia has quickly gained popularity among researchers, data scientists, and developers due to its remarkable performance and ease of use. The language’s key strength lies in its ability to handle complex mathematical computations and large datasets seamlessly. Julia boasts an intuitive syntax and rich mathematical library, making it particularly well-suited for numerical simulations, machine learning, and advanced statistical analysis. With its open-source nature and active community, Julia continues to evolve, receiving regular updates and enhancements that cater to its users’ diverse needs."
  },
  {
    "objectID": "additionals/essentials/julia_links/index.html#learning-julia",
    "href": "additionals/essentials/julia_links/index.html#learning-julia",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Learning Julia",
    "text": "Learning Julia\n\nMIT’s Introduction to Computational Thinking\n\nThis free online course held by the creators of the Julia Programming Language offers you a good overview of numerical methods and scientific computing in Julia. The course is held in Julia and is a great way to get started with the language.\n\nTUM-Dynamics-Lecture, 1 and TUM-Dynamics-Lecture, 2\n\nCreated by some colleagues of mine, these two lectures offer a great introduction to Julia and its applications in the field of dynamical systems. The lectures are held in Julia and are a great way to get started with the language."
  },
  {
    "objectID": "additionals/essentials/julia_links/index.html#resources",
    "href": "additionals/essentials/julia_links/index.html#resources",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Resources",
    "text": "Resources\n\nJulia Homepage (last visited: 31/07/2023)\nJulia Documentation (last visited: 31/07/2023)\n\nOnce you are familiar with the basics of Julia, the documentation is the best place to look up specific functions and syntax. Especially helpful are the following manuals: Performance Tips, Workflow Tips, and the Style Guide.\n\nSciML Style Guide for Julia, by Chris Rackauckas (last visited: 31/07/2023)\n\nA style guide for scientific machine learning in Julia. This guide is a work in progress and is updated regularly."
  },
  {
    "objectID": "additionals/essentials/julia_links/index.html#packages",
    "href": "additionals/essentials/julia_links/index.html#packages",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Packages",
    "text": "Packages\n\nDataFrames.jl\n\nA package for working with tabular data in Julia. The package is part of the Julia Data Ecosystem and offers a wide range of tools for data manipulation and analysis.\n\nDifferentialEquations.jl\n\nOne of the most popular packages for solving differential equations in Julia. The package is part of the SciML ecosystem and offers a wide range of solvers for ordinary and partial differential equations.\n\nJLD2.jl\n\nA package for saving and loading Julia data structures. Can also used for compressions (see CodecZlib.jl for more information).\n\nMakie.jl and its Documentation\n\nA high-performance plotting library for Julia. It features multiple backends and is highly customizable.\nAlso check out\n\nGeoMakie.jl for plotting geospatial data.\nColors.jl and ColorSchemes.jl for improved color handling.\n\n\nMeasurements.jl\n\nA physics package that handles uncertainty propagations coming from any kind of physical measuements.\n\nProgressMeter.jl\n\nProgress meter for long-running operations in Julia\n\nRevise.jl\n\nA package that allows you to modify your code without having to restart the Julia session. This is especially useful when working with large projects.\n\nUnitful.jl\n\nA package that allows you to work with physical units in Julia."
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html",
    "href": "additionals/code_examples/mc_simulation/index.html",
    "title": "Monte Carlo Simulation",
    "section": "",
    "text": "For additional information about the use of the Monte Carlo method in the ExESS research project, please refer to respective parts in the documentation."
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#structure",
    "href": "additionals/code_examples/mc_simulation/index.html#structure",
    "title": "Monte Carlo Simulation",
    "section": "Structure",
    "text": "Structure\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Basic Monte Carlo model structure.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n    \n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n    decision/.style={draw, diamond, aspect=2, thick, rounded corners=2pt, inner sep=3pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (START) at (0,0) {Start of Monte Carlo Simulation};    \n    \\node[main, below = 1 of START] (INIT) {\\n{Initialization of Monte Carlo \\\\ Simulation (e.g. setting of \\\\ global parameters)}};\n    \\node[decision, below = 1 of INIT] (CHECKSTEP) {};\n    \\node[main, below = 1 of CHECKSTEP, very thick] (STEP) {\\n{\\vspace{5mm}\\\\\\textbf{Monte Carlo Step}\\\\\\vspace{5mm}}};\n    \\node[main, right = 1 of STEP] (END) {\\n{End of\\\\Monte Carlo Simulation}};\n\n\n    %::. connections\n    \\draw[-latex, thick] (START) -- (INIT);\n    \\draw[-latex, thick] (INIT) -- node[midway, right] {$i=1$} (CHECKSTEP);\n    \\draw[-latex, thick] (CHECKSTEP) -- node [midway, right] {$i\\leq N$} (STEP);\n    \\draw[-latex, thick] (STEP.250) |- ($(STEP.250) + (-2, -1)$) |- node[near start, left] {$i\\mapsto i+1$} (CHECKSTEP.180);\n    \\draw[-latex, thick] (STEP.290) -- ($(STEP.290) + (0, -1.3)$) node[at end, below] {\\n{\\emph{save step }\\\\\\emph{results in file}}};\n    \\draw[-latex, thick] (CHECKSTEP.0) -| node[near start, above] {$i&gt;N$} (END.90);\n\n\\end{tikzpicture}"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#code",
    "href": "additionals/code_examples/mc_simulation/index.html#code",
    "title": "Monte Carlo Simulation",
    "section": "Code",
    "text": "Code\n\nfunction solvemontecarlo(step::Function, N::Int)\n    results = []\n    for i in 1:N\n        push!(results, step())\n    end\n    return results\nend\n\nsolvemontecarlo (generic function with 1 method)\n\n\n\nExample – Estimating Pi\n\nfunction step()\n    x, y = rand(2)*2 .- 1\n    return x^2 + y^2 &lt;= 1 ? 1 : 0\nend\n\nstep (generic function with 1 method)\n\n\nWhat does this specific stepping function do? It draws two positional arguments, x and y, from a uniform distribution between -1 and 1. Then it checks whether the point is inside the unit circle. If so, it returns 1, otherwise 0. The result is a vector of 1s and 0s, which can be interpreted as a Bernoulli distribution. The results look something like this:\n\n Figure Julia\n\n\n\n\n\n\n\n\n\nN=100\n\n\n\n\n\n\n\nN=1000\n\n\n\n\n\n\n\n\n\nN=10000\n\n\n\n\n\n\n\nN=100000\n\n\n\n\nFigure 2: Green points are inside the unit circle, red points are outside.\n\n\n\n\nusing CairoMakie\nfunction plotMC(N::Integer)\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        aspect=DataAspect())\n    for _ in 1:N\n        x, y = rand(2)*2 .- 1\n        if x^2 + y^2 &lt;= 1\n            scatter!(ax, x, y, color=:green)\n        else\n            scatter!(ax, x, y, color=:red)\n        end\n    end\n    xlims!(ax, (-1,1))\n    ylims!(ax, (-1,1))\n    save(joinpath(@__DIR__, @sprintf(\"%07i.png\", N)), fig, px_per_unit=4)\n    return nothing\nend\nplotMC.([100,1000,10000,100000])\nNote that the code above uses a custom theme loaded in the preamble of the document.\n\n\n\nWe can now use the results to estimate the value of \\(\\pi\\). The area of the unit circle is \\(\\pi\\), the area of the square is 4. The ratio of the areas is thus \\(\\pi/4\\). The ratio of the number of points inside the circle to the total number of points is an estimate of the ratio of the areas. We can thus estimate \\(\\pi\\) as follows:\n\nusing Statistics\nres = solvemontecarlo(step, 1_000_000)\nµ = mean(res)\npi_estimation = µ * 4\n\n3.14366\n\n\n\n\nAdditional Packages\nTwo important packages that can improve the workflow with Monte Carlo simulations are ProgressMeter and Distributed. The former allows to display of a progress bar, the latter allows simulating in parallel on multiple cores/workers. Both packages offer a simple interface that can be used through a macro that can be placed in front of the for-loop inside of the Monte Carlo solving function:\n# progress meter and parallel computing\n@showprogress @distributed for i in 1:N \n\n# only progress meter\n@showprogress for i in 1:N\n\n# only parallel computing\n@distributed for i in 1:N"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#structure-1",
    "href": "additionals/code_examples/mc_simulation/index.html#structure-1",
    "title": "Monte Carlo Simulation",
    "section": "Structure",
    "text": "Structure"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#code-1",
    "href": "additionals/code_examples/mc_simulation/index.html#code-1",
    "title": "Monte Carlo Simulation",
    "section": "Code",
    "text": "Code"
  },
  {
    "objectID": "index.html#author",
    "href": "index.html#author",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Author",
    "text": "Author\n\n\n\n\n\n\nM.Sc. Alexander Smolka\nProfessorship of Lunar and Planetary Exploration Technologies\nTUM School of Engineering and Design\nTechnical University of Munich\nPhone: +49 (89) 289 - 55681\nEmail: a.smolka@tum.de"
  },
  {
    "objectID": "index.html#publications-texts-and-presentations",
    "href": "index.html#publications-texts-and-presentations",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Publications, Texts, and Presentations",
    "text": "Publications, Texts, and Presentations\n\n\n\n  \n  \n    \n        Smolka, A., Nikolić, D., Gscheidle, C. and Reiss, P.\n        2023\n        Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions\n        0.1016/j.icarus.2023.115508\n        \n    \n  \n\n\n\n\n\n  \n  \n  \n  \n    TSU Mini-Moon Seminar\n    Presentation, 2023\n    Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions\n    \n  \n\n\n\n  \n  \n  \n  \n    IJS Physics Seminar\n    Presentation, 2023\n    Lunar exosphere, its mechanism and dynamics"
  },
  {
    "objectID": "index.html#additional-resources",
    "href": "index.html#additional-resources",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Additional Resources",
    "text": "Additional Resources\n\n\n\n  \n  \n  \n  \n    Julia Programming Language: Links & Resources\n     Links to the most important resources for learning the Julia programming language, including a subset of important packages for scientific computing\n  \n \n\n\n\n  \n  \n  \n  \n    ExESS Package Installation\n     Guide to describes how to install and use the ExESS package on your computer"
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Code Examples",
    "text": "Code Examples\n\nMonte Carlo Simulation"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#type-structure",
    "href": "api/grids/global_structured_2d_grids.html#type-structure",
    "title": "Global, Structured, 2D Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#usage",
    "href": "api/grids/global_structured_2d_grids.html#usage",
    "title": "Global, Structured, 2D Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#api",
    "href": "api/grids/global_structured_2d_grids.html#api",
    "title": "Global, Structured, 2D Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalStructured2DGrid – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over a sphere of radius r.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_EqSim([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_Reduced – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_Reduced{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_Reduced([T::Type,] r::Real, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the sphere radius r. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nVector{Int64}\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_Reduced_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_Reduced_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_Reduced_EqSim([T::Type,] r::Real, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nVector{Int64}\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2]."
  },
  {
    "objectID": "api/grids/utility.html#usage",
    "href": "api/grids/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/utility.html#api",
    "href": "api/grids/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nareas – Function\n\n\n\n\n\n[1] areas([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns the surface area of each grid element. For 3D grids, returns the base area of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoords – Function\n\n\n\n\n\n[1] coords([T::Type,] grid::AbstractGrid)\nReturns the coordinates of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoord2idx – Function\n\n\n\n\n\n[1] coord2idx(grid::AbstractGlobalGrid, [r::Real,] theta::Real, phi::Real)\n[2] coord2idx(grid::AbstractGlobalGrid, [r::AbstractVector,] theta::AbstractVector, phi::AbstractVector)\n[3] coord2idx(grid::AbstractGlobalGrid, coords::AbstractPosition)\n[4] coord2idx(grid::AbstractGlobalGrid, coords::Vector{AbstractPosition})\nCalculates the index of the grid element containing the given coordinates.\n\n\n\n\n\n\n\n\n\n\nsurfacecoords – Function\n\n\n\n\n\n[1] surfacecoords([T::Type,] grid::AbstractGrid)\nReturns only the coordinates of the surface (i.e. the base) of the discretized geometry.\n\n\n\n\n\n\n\n\n\n\nvolumes – Function\n\n\n\n\n\n[1] volumes([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns a vector of zeros(T) for each grid element. For 3D grids, returns the volume of each grid element."
  },
  {
    "objectID": "api/base/distributions.html#type-structure",
    "href": "api/base/distributions.html#type-structure",
    "title": "Distributions",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractDistribution\n    └─ AbstractVelocityDistribution{S} where {S&lt;:AbstractFloat}\n        ├─ MaxwellBoltzmannVelocityDistribution{S} where {S&lt;:AbstractFloat}\n        └─ MaxwellBoltzmannFluxVelocityDistribution{S} where {S&lt;:AbstractFloat}\nNote that the velocity distributions are of subtype AbstractFloat."
  },
  {
    "objectID": "api/base/distributions.html#usage",
    "href": "api/base/distributions.html#usage",
    "title": "Distributions",
    "section": "Usage",
    "text": "Usage\n\nVelocity Distributions\nFor the theoretical description of the velocity distributions, please read the documentation.\nGenerally, the two implemented velocity distributions can be created by calling the respective constructor with the respective temperature and mass as input arguments:\nT, m = 250.0, amu2kg(4) # [K], [kg] (mass of helium)\nvd_mb = MaxwellBoltzmannVelocityDistribution(T, m)\nvd_mbf = MaxwellBoltzmannFluxVelocityDistribution(T, m)\n\n\n\n\n\n\nSampling\n\n\n\n\n\nThe distributions in themselves are only placeholders to be used in statistical calculations. The following code shows how one can sample a Maxwell-Boltzmann velocity distribution to obtain a velocity vector (velocity),\n\nvelocity(vd_mb)\n\n3-element Vector{Float64}:\n  401.46588795294537\n  569.7524675250123\n -160.75186178013317\n\n\na speed (speed),\n\nspeed(vd_mb)\n\n718.3966519441951\n\n\nan azimuth angle (azimuth),\n\nazimuth(vd_mb)\n\n-0.5963191602346436\n\n\nan elevation angle (elevation),\n\nelevation(vd_mb)\n\n-0.7570264363328079\n\n\nand a zenith angle (zenith).\n\nzenith(vd_mb)\n\n-0.2700926415584921\n\n\n\n\n\n\n\n\n\n\n\nCumulative Distribution Functions\n\n\n\n\n\nAdditionally, the cumulative distribution (CDF) of an existing distribution, in this case, the Maxwell-Boltzmann Flux velocity distribution, can be analyzed. Note that this also works for the velocity vector, as well as for each individual, spherical component, i.e. the azimuth, elevation, speed, and zenith. The CDF computes the accumulated likelihood that a given value falls into a range provided in the function call. For the example usage, firstly the ranges will be defined:\n\nv1, v2 = 100.0, 200.0   # speed [m s-1]\naz1, az2 = -pi/4, pi/2  # azimuth [rad]\nel1, el2 = pi/6, pi/4   # elevation [ad]\nze1, ze2 = pi/4, pi/3   # zenith [rad]\n\nNow the respective CDFs can be computed. The following examples use the Maxwell-Boltzmann Flux velocity distribution vd_mbf:\n\nspeed_cdf(vd_mbf, v1, v2), azimuth_cdf(vd_mbf, az1, az2), elevation_cdf(vd_mbf, el1, el2), zenith_cdf(vd_mbf, ze1, ze2)\n\n(0.0006760328420158297, 0.375, 0.25, 0.24999999999999992)\n\n\nNote that, disregarding the numerical inaccuracies, the zenith and elevation angle CDF are evaluated to the same probability since the two angles are inherently connected through \\[\\begin{equation}\n    \\psi= \\begin{cases}\n        \\frac{\\pi}{2} - \\varphi& \\;\\text{for } \\varphi\\geq 0 \\\\\n        -\\frac{\\pi}{2} - \\varphi& \\;\\text{for } \\varphi&lt; 0\n    \\end{cases}\n\\end{equation}\\]\nAdditionally, the CDF can also be calculated for two velocity vectors, \\(\\boldsymbol{\\mathbf{v}}_1\\) (v1) and \\(\\boldsymbol{\\mathbf{v}}_2\\) (v2). In this case, the two vectors are used to calculate the corresponding speed, azimuth, and elevation angle, and then multiply each individual CDF together. Thus the following CDF\n\nv1_mbf, v2_mbf = velocity(MaxwellBoltzmannFluxVelocityDistribution(T, m)), velocity(MaxwellBoltzmannFluxVelocityDistribution(T, m))\nv1, v2 = speed(v1_mbf), speed(v2_mbf)\naz1, az2 = azimuth(v1_mbf), azimuth(v2_mbf)\nel1, el2 = elevation(v1_mbf), elevation(v2_mbf)\nvelocity_cdf(vd_mbf, v1_mbf, v2_mbf)\n\n\n\n0.0006638353807840756\n\n\nwill evaluate to the same likelihood as the CDFs of the three spherical components investigated individually\n\nabs(speed_cdf(vd_mbf, v1, v2)) * abs(azimuth_cdf(vd_mbf, az1, az2)) * abs(elevation_cdf(vd_mbf, el1, el2))\n\n0.0006638353807840756"
  },
  {
    "objectID": "api/base/distributions.html#api",
    "href": "api/base/distributions.html#api",
    "title": "Distributions",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nMaxwellBoltzmannVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannVelocityDistribution{S&lt;:AbstractFloat} &lt;: AbstractVelocityDistribution{S}\n[2] MaxwellBoltzmannVelocityDistribution(T::Real, m::Real)\nCustom struct defining a (3D) Maxwell-Boltzmann velocity distribution. Uses the temperature T in Kelvin and the mass m in kg as inputs.\n\n\n\n\n\n\n\n\n\n\nMaxwellBoltzmannFluxVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannFluxVelocityDistribution{S&lt;:AbstractFloat} &lt;: AbstractVelocityDistribution{S}\n[2] MaxwellBoltzmannFluxVelocityDistribution(T::Real, m::Real)\nCustom struct defining a (3D) Maxwell-Boltzmann flux velocity distribution. Uses the temperature T in Kelvin and the mass m in kg as inputs.\n\n\n\n\n\nUtility Functions\n\n\n\n\n\n\nazimuth – Function\n\n\n\n\n\n[1] azimuth([S::Type], vd::AbstractVelocityDistribution)\n[2] azimuth([S::Type], v::Vector{&lt;:Real})\n[3] azimuth([S::Type], v::LocalCartesianVelocity)\n[1] Draw a random azimuth angle (in [rad]) from the velocity distribution vd.\n[2] & [3] Calculate the azimuth angle (in [rad]) of the velocity vector v (in [m s-1]). Alternatively, the azimuth angle can be calculated from a LocalCartesianVelocity v (in [m s-1]).\n\n\n\n\n\n\n\n\n\n\nazimuth_cdf – Function\n\n\n\n\n\n[1] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, theta::Tuple{Real, Real})\n[2] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, theta1::Real, theta2::Real)\n[3] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, theta::Real)\n[4] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, v1::AbstractVector, v2::AbstractVector)\n[5] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[6] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, v1::LocalCartesianVelocity, v2::LocalCartesianVelocity)\n[7] azimuth_cdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nComputes the cumulative distribution function of the azimuth angle of the velocity distribution vd, between the azimuth angles theta[1]/theta1 and theta[2]/theta2 (in [rad]). Should only one angle be given, the lower boundary is assumed to be lower boundary of the respective domain, -pi.\nIf instead of an azimuth angle theta a velocity vector v (in [m s-1]) or a LocalCartesianVelocity v (in [m s-1]) is given, the azimuth angle is calculated from the velocity vector and the cumulative distribution function is calculated accordingly.\n\n\n\n\n\n\n\n\n\n\nazimuth_pdf – Function\n\n\n\n\n\n[1] azimuth_pdf([S::Type], vd::AbstractVelocityDistribution, theta::Real)\n[2] azimuth_pdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[3] azimuth_pdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nCalculates the probability density of the azimuth angle of the velocity distribution vd, at the azimuth angle theta (in [rad]). Alternatively, the probability density can be calculated at a velocity vector v (in [m s-1]) or a LocalCartesianVelocity v (in [m s-1]). Note that for [2] the vector assumes a local cartesian coordinate system (see LocalCartesianVelocity).\n\n\n\n\n\n\n\n\n\n\nelevation – Function\n\n\n\n\n\n[1] elevation([S::Type], vd::AbstractVelocityDistribution)\n[2] elevation([S::Type], v::AbstractVector)\n[3] elevation([S::Type], v::LocalCartesianVelocity)\n[1] Draw a random elevation angle (in [rad]) from the velocity distribution vd.\n[2] & [3] Calculate the elevation angle (in [rad]) of the velocity vector v (in [m s-1]). Alternatively, the elevation angle can be calculated from a LocalCartesianVelocity v (in [m s-1]).\nNote\n\nDomain of MaxwellBoltzmannVelocityDistribution is [-pi/2, pi/2]\nDomain of MaxwellBoltzmannFluxVelocityDistribution is [0, pi/2]\n\n\n\n\n\n\n\n\n\n\n\nelevation_cdf – Function\n\n\n\n\n\n[1] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, phi::Tuple{Real, Real})\n[2] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, phi1::Real, phi2::Real)\n[3] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, phi::Real)\n[4] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, v1::AbstractVector, v2::AbstractVector)\n[5] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[6] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, v1::LocalCartesianVelocity, v2::LocalCartesianVelocity)\n[7] elevation_cdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nComputes the cumulative distribution function of the elevation angle of the velocity distribution vd, between the elevation angles phi[1]/phi1 and phi[2]/phi2 (in [rad]). Should only one angle be given, the lower boundary is assumed to be lower boundary of the respective domain.\nIf instead of an elevation angle theta a velocity vector v (in [m s-1]) or a LocalCartesianVelocity v (in [m s-1]) is given, the elevation angle is calculated from the velocity vector and the cumulative distribution function is calculated accordingly.\n** Notes**\n\nDomain of MaxwellBoltzmannVelocityDistribution is [-pi/2, pi/2], thus, using [3,5,7], the lower boundary is -pi/2.\nDomain of MaxwellBoltzmannFluxVelocityDistribution is [0, pi/2], thus, using [3,5,7], the lower boundary is 0.\n\n\n\n\n\n\n\n\n\n\n\nelevation_pdf – Function\n\n\n\n\n\n[1] elevation_pdf([S::Type], vd::AbstractVelocityDistribution, phi::Real)\n[2] elevation_pdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[3] elevation_pdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nCalculates the probability density of the elevation angle of the velocity distribution vd, at the elevation angle phi (in [rad]). Alternatively, the probability density can be calculated at a velocity vector v (in [m s-1]) or a LocalCartesianVelocity v (in [m s-1]). Note that for [2] the vector assumes a local cartesian coordinate system (see LocalCartesianVelocity).\n\n\n\n\n\n\n\n\n\n\nspeed – Function\n\n\n\n\n\n[1] speed([S::Type], vd::AbstractVelocityDistribution)\n[2] speed([S::Type], v::AbstractVector)\n[3] speed([S::Type], v::LocalCartesianVelocity)\n[4] speed([S::Type], vd::MaxwellBoltzmannVelocityDistribution, mode::Symbol)\n[1] Draw a random speed (in [m s-1]) from the velocity distribution vd.\n[2] & [3] Calculate the speed (in [m s-1]) of the velocity vector v (in [m s-1]). Alternatively, the speed can be calculated from a LocalCartesianVelocity v (in [m s-1]).\n[4] Calculate the typical speed (in [m s-1]) of the velocity distribution vd based on the mode mode. The following modes are available:\n\n:prob for most probable velocity\n:mean for mean velocity\n:rms for root-mean-square velocity\n\n\n\n\n\n\n\n\n\n\n\nspeed_cdf – Function\n\n\n\n\n\n[1] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v::Tuple{Real, Real}; N=1000)\n[2] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v::Tuple{Integer, Integer}; kwargs...)\n[3] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v::Real; kwargs...)\n[4] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v1::AbstractVector, v2::AbstractVector)\n[5] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[6] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v1::LocalCartesianVelocity, v2::LocalCartesianVelocity)\n[7] speed_cdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nComputes the cumulative distribution function of the speed of the velocity distribution vd based on numerical integration of the respective probability density function between the upper and lower speed given in v (in [m s-1]) (if v is scalar, the lower boundary is zero).\nAlternatively, the cumulative distribution function can be calculated between the upper and lower speed given in v (in [m s-1]), either as an AbstractVector or a LocalCartesianVelocity (in [m s-1]). Note that [4] and [5] expect the vector to be given in cartesian coordinates (see LocalCartesianVelocity).\n\n\n\n\n\n\n\n\n\n\nspeed_pdf – Function\n\n\n\n\n\n[1] speed_pdf([S::Type], vd::AbstractVelocityDistribution, v::Real)\n[2] speed_pdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[3] speed_pdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nCalculates the probability density of the speed of the velocity distribution vd, at the speed v (in [m s-1]).\n\n\n\n\n\n\n\n\n\n\nvelocity – Function\n\n\n\n\n\n[1] velocity([S::Type], vd::AbstractVelocityDistribution)\nDraw a random, trhee-dimensional velocity vector (in [m s-1]) from the velocity distribution vd.\nNotes\n\nThe three-dimensional vector is given in local cartesian coordinates (see LocalCartesianVelocity). This means that v[1] points locally east, v[2] points locally north, and v[3] points locally up.\n\n\n\n\n\n\n\n\n\n\n\nvelocity_cdf – Function\n\n\n\n\n\n[1] velocity_cdf([S::Type], vd::AbstractVelocityDistribution, v1::AbstractVector, v2::AbstractVector)\n[2] velocity_cdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[3] velocity_cdf([S::Type], vd::AbstractVelocityDistribution, v1::LocalCartesianVelocity, v2::LocalCartesianVelocity)\n[4] velocity_cdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nComputes the cumulative distribution function of the velocity vector of the velocity distribution vd, between the velocity vectors v1 and v2 (in [m s-1]). Should only one vector be given, the lower boundary is assumed to be the zero vector.\nNote that if an AbstractVector is given, it is assumed to be given in cartesian coordinates (see LocalCartesianVelocity).\n\n\n\n\n\n\n\n\n\n\nvelocity_pdf – Function\n\n\n\n\n\n[1] velocity_pdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[2] velocity_pdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nCalculates the probability density of the velocity vector v (in [m s-1]) of the velocity distribution vd.\n\n\n\n\n\n\n\n\n\n\nzenith – Function\n\n\n\n\n\n[1] zenith([S::Type], vd::AbstractVelocityDistribution)\n[2] zenith([S::Type], v::Vector{&lt;:Real})\n[3] zenith([S::Type], v::LocalCartesianVelocity)\n[1] Draw a random zenith angle (in [rad]) from the velocity distribution vd.\n[2] & [3] Calculate the zenith angle (in [rad]) of the velocity vector v (in [m s-1]). Alternatively, the zenith angle can be calculated from a LocalCartesianVelocity v (in [m s-1]).\nNotes\n\nthe zenith angle is the same-sign pi/2-inversion of the elevation angle\n\n\n\n\n\n\n\n\n\n\n\nzenith_cdf – Function\n\n\n\n\n\n[1] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, psi::Tuple{Real, Real})\n[2] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, psi1::Real, psi2::Real)\n[3] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, psi::Real)\n[4] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, v1::AbstractVector, v2::AbstractVector)\n[5] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[6] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, v1::LocalCartesianVelocity, v2::LocalCartesianVelocity)\n[7] zenith_cdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nComputes the cumulative distribution function of the zenith angle of the velocity distribution vd, between the zenith angles psi[1]/psi1 and psi[2]/psi2 (in [rad]). Should only one angle be given, the lower boundary is assumed to be lower boundary of the respective domain.\n** Notes**\n\nDomain of MaxwellBoltzmannVelocityDistribution is [-pi/2, pi/2], thus, using [3,5,7], the lower boundary is -pi/2.\nDomain of MaxwellBoltzmannFluxVelocityDistribution is [0, pi/2], thus, using [3,5,7], the lower boundary is 0.\n\n\n\n\n\n\n\n\n\n\n\nvelocity_pdf – Function\n\n\n\n\n\n[1] zenith_pdf([S::Type], vd::AbstractVelocityDistribution, psi::Real)\n[2] zenith_pdf([S::Type], vd::AbstractVelocityDistribution, v::AbstractVector)\n[3] zenith_pdf([S::Type], vd::AbstractVelocityDistribution, v::LocalCartesianVelocity)\nCalculates the probability density of the zenith angle of the velocity distribution vd, at the zenith angle psi (in [rad]). Alternatively, the probability density can be calculated at a velocity vector v (in [m s-1]) or a LocalCartesianVelocity v (in [m s-1]). Note that for [2] the vector assumes a local cartesian coordinate system (see LocalCartesianVelocity)."
  },
  {
    "objectID": "api/base/distributions.html#benchmarks",
    "href": "api/base/distributions.html#benchmarks",
    "title": "Distributions",
    "section": "Benchmarks",
    "text": "Benchmarks\nJulia Version Information\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 1 on 8 virtual cores\n\n\n\n\n\n\n\n\nBenchmark\nMinimum [ns]\nMedian [ns]\n\n\n\n\nConstructor: MaxwellBoltzmannVelocityDistribution\n2.33\n2.706\n\n\nConstructor: MaxwellBoltzmannFluxVelocityDistribution\n2.457\n2.777\n\n\nFunction: velocity with MaxwellBoltzmannVelocityDistribution\n77.647\n82.579\n\n\nFunction: velocity with MaxwellBoltzmannFluxVelocityDistribution\n97.678\n105.72\n\n\nFunction: rand with MaxwellBoltzmannVelocityDistribution\n17.75\n18.485\n\n\nFunction: rand with MaxwellBoltzmannFluxVelocityDistribution\n30.211\n30.962\n\n\nFunction: velocity with predefined MaxwellBoltzmannVelocityDistribution\n73.17\n76.105\n\n\nFunction: velocity with predefined MaxwellBoltzmannFluxVelocityDistribution\n95.875\n99.456\n\n\nFunction: rand with predefined MaxwellBoltzmannVelocityDistribution\n17.292\n18.293\n\n\nFunction: rand with predefined MaxwellBoltzmannFluxVelocityDistribution\n30.058\n30.867\n\n\nFunction: velocity_pdf with MaxwellBoltzmannVelocityDistribution\n1107.083\n1188.967\n\n\nFunction: velocity_pdf with MaxwellBoltzmannFluxVelocityDistribution\n1095.629\n1166.584\n\n\n\nConstructor: MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.330 ns … 20.025 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.706 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.813 ns ±  0.675 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  █              ▅  ▁▁                                        \n  █▂▄▇▂▇▆▁▆▄▂▅█▂▂█▂▂██▂▁▆▃▂▁▆▄▂▁▄█▂▁▁▆▃▁▁▁█▃▁▁▁▅▄▂▁▁▂▇▃▂▁▁▂▂ ▃\n  2.33 ns        Histogram: frequency by time        3.66 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nConstructor: MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  2.457 ns … 47.982 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     2.777 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.999 ns ±  1.080 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▁ ▆ █ ▃                                                    \n  ██▃█▂█▂█▂█▁▅▂▂▅▁▆▂▁▇▁▁▆▁▁▆▂▁▃▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  2.46 ns        Histogram: frequency by time        4.85 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nFunction: velocity with MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):   77.647 ns …   3.116 μs  ┊ GC (min … max): 0.00% … 90.43%\n Time  (median):      82.579 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   103.516 ns ± 112.972 ns  ┊ GC (mean ± σ):  5.80% ±  5.32%\n\n  ██▅▅▅▄▄▄▃▃▂▁▂▁▁▁▂▁▁  ▁▁▁▁▁    ▁ ▁▁▁▁▁                         ▂\n  ███████████████████████████▇███████████████▇█▇▇▆▆▆▆▆▆▆▇▇▆▆▆▆▅ █\n  77.6 ns       Histogram: log(frequency) by time        220 ns &lt;\n\n Memory estimate: 160 bytes, allocs estimate: 2.\nFunction: velocity with MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):   97.678 ns …   2.983 μs  ┊ GC (min … max): 0.00% … 91.73%\n Time  (median):     105.720 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   125.589 ns ± 115.534 ns  ┊ GC (mean ± σ):  4.90% ±  5.29%\n\n  ██▅▅▅▅▅▄▃▃▃▂▂▂▂▂▂▁▂▂▂▁▁▁▁  ▁                                  ▂\n  █████████████████████████████████▆▇▆▇▆▆▇▆▇▆▅▆▅▆▆▆▆▇▆▇▇▆█▇▆▇▆▆ █\n  97.7 ns       Histogram: log(frequency) by time        260 ns &lt;\n\n Memory estimate: 160 bytes, allocs estimate: 2.\nFunction: rand with MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  17.750 ns … 68.539 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     18.485 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   19.896 ns ±  4.240 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▅█▇▅▃▂▁▁▂▃▂▁▁▁     ▁▁▁▁                                     ▂\n  ███████████████████████▇█▇███▇█▇▆▇█▆▇▇▇▅▅▅▅▅▇█▇▅▁▃▅▇▇▇▅▅▅▄▄ █\n  17.8 ns      Histogram: log(frequency) by time      38.7 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nFunction: rand with MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  30.211 ns … 118.408 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     30.962 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   33.083 ns ±   6.797 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▇█▃▁  ▁ ▁ ▁               ▁                                  ▁\n  ███████████▇█▆▇▆▇▅█▆▇█▆▇▆▇██▇███▇▆▅▄▅▄▅▄▅▆▃▃▃▄▅▄▃▃▃▅▄▄▃▅▇▅▃▅ █\n  30.2 ns       Histogram: log(frequency) by time      66.8 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nFunction: velocity with predefined MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  73.170 ns …  2.360 μs  ┊ GC (min … max): 0.00% … 93.70%\n Time  (median):     76.105 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   88.219 ns ± 98.288 ns  ┊ GC (mean ± σ):  6.16% ±  5.36%\n\n  ▄█▆▅▂▁  ▁    ▁▁                                             ▁\n  █████████▇▇██████▇▆▆▆▇▇█▇██▇▇▆▆▇▇▇▇▇███▇▇▇▆▇▇▅▆▇█▇▆▅▆▆▅▅▅▅▅ █\n  73.2 ns      Histogram: log(frequency) by time       160 ns &lt;\n\n Memory estimate: 160 bytes, allocs estimate: 2.\nFunction: velocity with predefined MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):   95.875 ns …  2.098 μs  ┊ GC (min … max): 0.00% … 84.47%\n Time  (median):      99.456 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   113.792 ns ± 98.237 ns  ┊ GC (mean ± σ):  4.77% ±  5.31%\n\n  ▅█▇▃▂▁   ▁▁▂▁▁       ▁         ▁                             ▁\n  █████████████████▆█████▇█████▇██▇▇█▇▇▆▆██▇▇▆▆▆▇▇▆▆▆▅▆▅▅▄▅▄▅▅ █\n  95.9 ns       Histogram: log(frequency) by time       202 ns &lt;\n\n Memory estimate: 160 bytes, allocs estimate: 2.\nFunction: rand with predefined MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  17.292 ns … 69.647 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     18.293 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   19.902 ns ±  4.639 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▂██▆▃▁ ▂▄▂▁  ▁▁▁                                            ▂\n  ██████████████████▇█▇█▇█████▇█▇▅▇▇▅▅▄▂▇▇█▆▄▄▅▇▇▇▅▄▄▃▃▅▄▂▄▅▄ █\n  17.3 ns      Histogram: log(frequency) by time      41.4 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nFunction: rand with predefined MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  30.058 ns … 85.037 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     30.867 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   32.191 ns ±  4.781 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▃▇█▅                                                        ▁\n  █████▆████▇▇▇▇██▆█▇▅▄▆▂▇▇▆▂▆▇▃▅▇▆▄▅▇▇▆▄▅▅▆▅▆██▆▅▄▅▇▆▅▄▅▇▇▆▅ █\n  30.1 ns      Histogram: log(frequency) by time      51.1 ns &lt;\n\n Memory estimate: 0 bytes, allocs estimate: 0.\nFunction: velocity_pdf with MaxwellBoltzmannVelocityDistribution\nBenchmarkTools.Trial: 3874 samples with 1000 evaluations.\n Range (min … max):  1.107 μs …   6.497 μs  ┊ GC (min … max): 0.00% … 50.79%\n Time  (median):     1.189 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.287 μs ± 339.011 ns  ┊ GC (mean ± σ):  1.28% ±  5.40%\n\n   █▂                                                          \n  ███▆▆▆▄▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  1.11 μs         Histogram: frequency by time        3.05 μs &lt;\n\n Memory estimate: 448 bytes, allocs estimate: 20.\nFunction: velocity_pdf with MaxwellBoltzmannFluxVelocityDistribution\nBenchmarkTools.Trial: 4179 samples with 1000 evaluations.\n Range (min … max):  1.096 μs …   2.987 μs  ┊ GC (min … max): 0.00% … 52.22%\n Time  (median):     1.167 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.194 μs ± 162.052 ns  ┊ GC (mean ± σ):  1.24% ±  5.50%\n\n  ▃ ▅▃▃█▆▆▅▄▃▂▂▁▁                                             ▁\n  █▇█████████████▇▇█▇▇▆▆▆▅▅▄▅▄▁▅▁▃▄▄▁▁▃▄▃▃▁▁▄▁▁▁▁▁▃▃▁▁▁▁▃▁▁▄▃ █\n  1.1 μs       Histogram: log(frequency) by time      1.83 μs &lt;\n\n Memory estimate: 448 bytes, allocs estimate: 20."
  },
  {
    "objectID": "api/base/utility.html",
    "href": "api/base/utility.html",
    "title": "Utility",
    "section": "",
    "text": "In base/utility.jl, you will find a collection of utility functions that are used throughout the package."
  },
  {
    "objectID": "api/base/utility.html#usage",
    "href": "api/base/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage\nAll the utility functions defined here are easy-to-use and generally self-explanatory. For example, the unit conversion functions amu2kg, eV2J, and J2eV:\nm_H = amu2kg(AMU_H) # 1.673781838440757e-27\nIn the example above, the atomic mass of hydrogen, stored in the custom constant AMU_H, is converted from atomic mass units to kilograms and stored in a new variable m_H (its value is provided in the comment).\neV = 1 # 1\nJ = eV2J(eV) # 1.602176634e-19\nev == J2eV(J) # true\nThe functions eV2J and J2eV convert the energy units electronvolt and joule. In the example above, the value of eV is converted to joules and stored in J. The conversion is then reversed, and the result is compared to the original value of eV. Note that all three functions accept any Real number type, returning either the input type, if that type is a subtype of AbstractFloat, or a Float64 otherwise (exception with the input type BigInt which leads the function to return a BigFloat)."
  },
  {
    "objectID": "api/base/utility.html#examples",
    "href": "api/base/utility.html#examples",
    "title": "Utility",
    "section": "Examples",
    "text": "Examples\n\nEscape Velocities and Energies\nThe following example shows how to use the utility functions to calculate the required energy of a particle to escape the gravitational pull of the Moon.\n# defines the masses of hydrogen, molecular hydrogen, hydroxyl, and water \n# in kilograms\nmasses = amu2kg.([AMU_H, AMU_H2, AMU_OH, AMU_H2O])\n\n# calculates the escape velocity of the Moon on its surface in m/s\nv_esc = escape_velocity(LUNAR_RADIUS, LUNAR_MASS)\n\n# define a function to calculate the kinetic energy of a particle, based on\n# its mass and velocity\nE_kin(m::Real; v=v_esc) = 0.5 * m * v_esc^2\n\n# calculate the kinetic energy of the particles defined above, in eV\nE = J2eV.(E_kin.(masses))\nIn the following, we will go through this example step-by-step. The first line of code defines the masses of hydrogen, molecular hydrogen, hydroxyl, and water in kilograms and saves their values in a vector masses. It uses the amu2kg function to turn the constants AMU_H, AMU_H2, AMU_OH, and AMU_H2O from atomic mass units to kilograms (note the amu2kg.(...) dot-notation to broadcast the function which is only defined for scalar inputs, to work with arrays):\nmasses = amu2kg.([AMU_H, AMU_H2, AMU_OH, AMU_H2O])\nThe output is a vector of four elements, each corresponding to the mass of one of the particles in kilograms:\n\n\n4-element Vector{Float64}:\n 1.673781838440757e-27\n 3.347563676881514e-27\n 2.824141014861615e-26\n 2.9915191987056904e-26\n\n\nThe next line calculates the velocity that each particle would need to escape the lunar gravity field, i.e., the escape velocity, for which the orbital mechanics function escape_velocity is used. Note that, as the name of the function suggests, it requires the radius and mass of the respective body for which the escape velocity shall be calculated as inputs, which are provided as the constants LUNAR_RADIUS and LUNAR_MASS:\nv_esc = escape_velocity(LUNAR_RADIUS, LUNAR_MASS)\nIt results in the following scalar value:\n\n\n2359.7179236582847\n\n\nThe third code line defines a new function called E_kin, which takes one argument m::Real as the mass of a particle in kilograms as a real number type, and one optional keyword argument v which is given the default value of our previously calculated escape velocity v_esc.\nE_kin(m::Real; v=v_esc) = 0.5 * m * v_esc^2\nNow, the function E_kin can be used to calculate the kinetic energy of particles with masses saved in masses, again, by broadcasting over the function with the dot notation. To provide the result in a more convenient unit, the function J2eV is applied to the result, which converts the energy from Joules to electronvolts:\nE = J2eV.(E_kin.(masses))\nwhich leads to the final output vector:\n\n\n4-element Vector{Float64}:\n 0.029085641336536464\n 0.05817128267307293\n 0.49075662523969016\n 0.5198422665762266"
  },
  {
    "objectID": "api/base/utility.html#api",
    "href": "api/base/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\namu2kg – Function\n\n\n\n\n\n[1] amu2kg(amu::Real)\nConverts atomic mass unit amu into kilo gram.\n\n\n\n\n\n\n\n\n\n\neV2J – Function\n\n\n\n\n\n[1] eV2J(eV::Real)\nConverts energy in electron volt eV to joule.\n\n\n\n\n\n\n\n\n\n\nJ2eV – Function\n\n\n\n\n\n[1] J2eV(J::Real)\nConverts energy in joule J to electron volt.\n\n\n\n\n\n\n\n\n\n\nlimit_acos – Function\n\n\n\n\n\n[1] limit_acos(x::Real)\nExtends the acos function for input outside of [-1,1] through clipping.\n\n\n\n\n\n\n\n\n\n\nsgn – Function\n\n\n\n\n\n[1] sgn(x::Real)\nReturns the sign of x with the custom definition sgn(0) = 1."
  },
  {
    "objectID": "api/exospheres/trajectory.html",
    "href": "api/exospheres/trajectory.html",
    "title": "Trajectory",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/exospheres/trajectory.html#usage",
    "href": "api/exospheres/trajectory.html#usage",
    "title": "Trajectory",
    "section": "Usage",
    "text": "Usage\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\nv0 = GlobalCartesianVelocity(100, 0, 0)\nddx = ddx_lunar_gravity\ntraj = trajectory(x0, v0, ddx)"
  },
  {
    "objectID": "api/exospheres/trajectory.html#examples",
    "href": "api/exospheres/trajectory.html#examples",
    "title": "Trajectory",
    "section": "Examples",
    "text": "Examples\n\n\n\n\n\n\n3D Ballistic Trajectory Calculation\n\n\n\n\n\n\nPreparation\nFirstly, the following examples were executed using the following Julia version:\n\nversioninfo()\n\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 2 on 8 virtual cores\n\n\nNext, the locally available ExESS package has to be loaded to access the trajectory function:\n\ninclude(path_to_exess)\nusing .ExESS\n\n\n\nInputs\nLet us define all required inputs for the trajectory calculation. If you are unsure about how the function works, you can type julia&gt; ?trajectory in the REPL to get a description of the function and its arguments.\nApart from the key-word arguments, the function requires the following inputs:\n\nx0: Initial position vector in Cartesian coordinates (m)\nv0: Initial velocity vector in Cartesian coordinates (m/s)\nddx: Acceleration function (m/s2)\n\nThe docstring (see ?trajectory) shows that these inputs can be of different types, either vectors (AbstractVector) or positions (AbstractPosition). The latter are custom types defined in the ExESS package to distinguish one three-dimensional in a certain coordinate space from another. The following example shows how to use the GlobalCartesianPosition.\nWe create a GlobalCartesianPosition object with the initial position vector, located at [LUNAR_RADIUS, 0, 0], in other words: on the surface of a sphere with radius LUNAR_RADIUS.\n\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\n\nGlobalCartesianPosition{Float64}(1.7374e6, 0.0, 0.0)\n\n\nNext, the initial velocity vector is defined. We use the GlobalCartesianVelocity type to define a velocity vector in the same coordinate system as the position vector. Here, we only use a velocity in the x-direction, with a magnitude of 100 m/s.\n\nv0 = GlobalCartesianVelocity(100, 0, 0)\n\nGlobalCartesianVelocity{Int64}(100, 0, 0)\n\n\nWithout letting the trajectory calculation run, we can review the initial conditions set. Both the position and the velocity vector are set in the same coordinate system and have non-zero components only in the x-direction. For purely gravitational accelerations, the trajectory should therefore be a straight line in the x-direction.\nWe can test these assumptions by using the ddx_lunar_gravity function, which is a predefined acceleration function for the gravitational acceleration of the Moon. It already has the Moon’s mass and radius defined, so we can use it directly as is. Note that it assumes that every other acceleration is negligible, which might not be true for charged particles in electromagnetic fields.\n\nddx = ddx_lunar_gravity\n\nddx_lunar_gravity (generic function with 2 methods)\n\n\n\n\nSolve the Trajectory\nFinally, we have all the required inputs to calculate the trajectory. Let’s call the function and save the solution in a variable called traj.\n\ntraj = trajectory(x0, v0, ddx)\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation\nt: 7-element Vector{Float32}:\n   0.0\n   0.17253026\n   1.897833\n  19.15086\n  89.02362\n 125.11684\n 125.11684\nu: 7-element Vector{RecursiveArrayTools.ArrayPartition{Float64, Tuple{Vector{Float64}, Vector{Float64}}}}:\n ([100.0, 0.0, 0.0], [1.737401e6, 0.0, 0.0])\n ([99.72352819548777, 0.0, 0.0], [1.7374182291764107e6, 0.0, 0.0])\n ([96.95910868428572, 0.0, 0.0], [1.737587897640642e6, 0.0, 0.0])\n ([69.34166361242546, 0.0, 0.0], [1.7390224279588673e6, 0.0, 0.0])\n ([-42.27453422294352, 0.0, 0.0], [1.739967349345177e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])"
  },
  {
    "objectID": "api/exospheres/trajectory.html#preparation",
    "href": "api/exospheres/trajectory.html#preparation",
    "title": "Trajectory",
    "section": "Preparation",
    "text": "Preparation\nFirstly, the following examples were executed using the following Julia version:\n\nversioninfo()\n\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 2 on 8 virtual cores\n\n\nNext, the locally available ExESS package has to be loaded to access the trajectory function:\n\ninclude(path_to_exess)\nusing .ExESS"
  },
  {
    "objectID": "api/exospheres/trajectory.html#inputs",
    "href": "api/exospheres/trajectory.html#inputs",
    "title": "Trajectory",
    "section": "Inputs",
    "text": "Inputs\nLet us define all required inputs for the trajectory calculation. If you are unsure about how the function works, you can type julia&gt; ?trajectory in the REPL to get a description of the function and its arguments.\nApart from the key-word arguments, the function requires the following inputs:\n\nx0: Initial position vector in Cartesian coordinates (m)\nv0: Initial velocity vector in Cartesian coordinates (m/s)\nddx: Acceleration function (m/s2)\n\nThe docstring (see ?trajectory) shows that these inputs can be of different types, either vectors (AbstractVector) or positions (AbstractPosition). The latter are custom types defined in the ExESS package to distinguish one three-dimensional in a certain coordinate space from another. The following example shows how to use the GlobalCartesianPosition.\nWe create a GlobalCartesianPosition object with the initial position vector, located at [LUNAR_RADIUS, 0, 0], in other words: on the surface of a sphere with radius LUNAR_RADIUS.\n\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\n\nGlobalCartesianPosition{Float64}(1.7374e6, 0.0, 0.0)\n\n\nNext, the initial velocity vector is defined. We use the GlobalCartesianVelocity type to define a velocity vector in the same coordinate system as the position vector. Here, we only use a velocity in the x-direction, with a magnitude of 100 m/s.\n\nv0 = GlobalCartesianVelocity(100, 0, 0)\n\nGlobalCartesianVelocity{Int64}(100, 0, 0)\n\n\nWithout letting the trajectory calculation run, we can review the initial conditions set. Both the position and the velocity vector are set in the same coordinate system and have non-zero components only in the x-direction. For purely gravitational accelerations, the trajectory should therefore be a straight line in the x-direction.\nWe can test these assumptions by using the ddx_lunar_gravity function, which is a predefined acceleration function for the gravitational acceleration of the Moon. It already has the Moon’s mass and radius defined, so we can use it directly as is. Note that it assumes that every other acceleration is negligible, which might not be true for charged particles in electromagnetic fields.\n\nddx = ddx_lunar_gravity\n\nddx_lunar_gravity (generic function with 2 methods)"
  },
  {
    "objectID": "api/exospheres/trajectory.html#solve-the-trajectory",
    "href": "api/exospheres/trajectory.html#solve-the-trajectory",
    "title": "Trajectory",
    "section": "Solve the Trajectory",
    "text": "Solve the Trajectory\nFinally, we have all the required inputs to calculate the trajectory. Let’s call the function and save the solution in a variable called traj.\n\ntraj = trajectory(x0, v0, ddx)\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation\nt: 7-element Vector{Float32}:\n   0.0\n   0.17253026\n   1.897833\n  19.15086\n  89.02362\n 125.11684\n 125.11684\nu: 7-element Vector{RecursiveArrayTools.ArrayPartition{Float64, Tuple{Vector{Float64}, Vector{Float64}}}}:\n ([100.0, 0.0, 0.0], [1.737401e6, 0.0, 0.0])\n ([99.72352819548777, 0.0, 0.0], [1.7374182291764107e6, 0.0, 0.0])\n ([96.95910868428572, 0.0, 0.0], [1.737587897640642e6, 0.0, 0.0])\n ([69.34166361242546, 0.0, 0.0], [1.7390224279588673e6, 0.0, 0.0])\n ([-42.27453422294352, 0.0, 0.0], [1.739967349345177e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])"
  },
  {
    "objectID": "api/exospheres/trajectory.html#api",
    "href": "api/exospheres/trajectory.html#api",
    "title": "Trajectory",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlanding_position – Function\n\n\n\n\n\n[1] landing_position(x0::AbstractVector, v0::AbstractVector; kwargs...)\n[2] landing_position(x0::AbstractPosition, v0::AbstractVelocity; kwargs...)\nCalculates the landing position of a particle starting at position x0 (global spherical coordinates: radius, longitude, latitude), with initial velocity v0 (local cartesian coordinates: x (east), y (north), z (up)), flying on a ballistic trajectory, i.e., only influenced by graviational forces.\nReturns the landing position in global spherical coordinate as r, lon, lat ([1]) or as GlobalSphericalPosition(r, lon, lat) ([2]).\nKey-Word Arguments\n\n\n\nField\nValue\nUnit\nDescription\n\n\n\n\nm\nLUNAR_MASS\n[kg]\nmass of planetary object\n\n\n\nReferences\n\nN. Schörghofer: “USER GUIDE: Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces”, https://github.com/nschorgh/Planetary-Code-Collection\nB. J. Butler, 1997, “The migration of volatiles on the surfaces of Mercury and the Moon,” Journal of Geophysical Research, vol. 102, no. E8, pp. 19,283–19,291, doi: 10.1029/97JE01347.\nKegerreis et al., 2017, “Evidence for a localized source of the argon in the lunar exosphere”, Journal of Geophysical Research: Planets, American Geophysical Union (AGU), 122, 2163-2181\n\n\n\n\n\n\n\n\n\n\n\ntrajectory – Function\n\n\n\n\n\n[1] trajectory(x0::AbstractVector, v0::AbstractVector, ddx::Function; kwargs...)\n[2] trajectory(x0::AbstractPosition, v0::AbstractVelocity, ddx::Function; kwargs...)\nCalculate the trajectory of a particle starting at position x0 (global cartesian coordinates), with initial velocity v0 (global cartesian coordinates), given the acceleration function ddx (global cartesian coordinates).\nReturns a ODESolution object as the trajectory.\nKey-Word Arguments\n\n\n\n\n\n\n\n\n\nField\nValue\nUnit\nDescription\n\n\n\n\nalg\nTsit5()\n\nnumerical solver algorithm\n\n\nrmin\nLUNAR_RADIUS\n[m]\nminimum radius of computational domain\n\n\nrmax\n1e9\n[m]\nmaximum radius of computational domain\n\n\ntspan\n(0f0,1f10)\n([s], [s])\ntime span of the integration\n\n\nkwargs\n\n\nadditional key-word arguments\n\n\n\nThe integration terminates if either the minimum or maximum radius is exceeded or if the end of the time span is reached.\nNotes\n\ncalling the function with &lt;:Integer arguments will promote them to Float64\n\n\n\n\n\n\n\n\n\n\n\nddx_lunar_gravity – Function\n\n\n\n\n\n[1] ddx_lunar_gravity(x::AbstractVector, [args...])\nAcceleration function for the lunar gravity."
  },
  {
    "objectID": "api/exospheres/trajectory.html#benchmarks",
    "href": "api/exospheres/trajectory.html#benchmarks",
    "title": "Trajectory",
    "section": "Benchmarks",
    "text": "Benchmarks\nJulia Version Information\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 1 on 8 virtual cores\n\n\n\n\n\n\n\n\nBenchmark\nMinimum [ns]\nMedian [ns]\n\n\n\n\nFunction: trajectory\n175499.26\n209686.335\n\n\nFunction: trajectory - global coordinates\n175574.79\n183176.6\n\n\nFunction: trajectory - vectorized global coordinates\n175310.78\n179317.46\n\n\nFunction: trajectory - vectorized global coordinates, reltol=1e-8\n251965.28\n298381.57\n\n\nFunction: trajectory - extract position\n199.675\n204.374\n\n\nFunction: trajectory - extract position (100)\n20560.2\n23785.75\n\n\nFunction: trajectory - extract position (100) - vectorized\n20625.6\n24045.25\n\n\n\nFunction: trajectory\nBenchmarkTools.Trial: 442 samples with 100 evaluations.\n Range (min … max):  175.499 μs … 781.703 μs  ┊ GC (min … max): 0.00% … 14.62%\n Time  (median):     209.686 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   226.261 μs ±  61.208 μs  ┊ GC (mean ± σ):  5.82% ±  8.82%\n\n  █                                                              \n  █▇▄▄▅▆▅▃▄▃▃▇▄▄▃▃▄▄▃▄▃▃▃▂▃▃▃▂▂▂▂▃▂▃▂▂▂▂▂▁▁▁▂▂▂▁▂▂▂▁▂▁▁▁▁▁▁▁▁▂▂ ▃\n  175 μs           Histogram: frequency by time          441 μs &lt;\n\n Memory estimate: 105.30 KiB, allocs estimate: 1783.\nFunction: trajectory - global coordinates\nBenchmarkTools.Trial: 487 samples with 100 evaluations.\n Range (min … max):  175.575 μs … 612.288 μs  ┊ GC (min … max): 0.00% … 16.78%\n Time  (median):     183.177 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   205.536 μs ±  51.616 μs  ┊ GC (mean ± σ):  5.80% ±  8.79%\n\n  █▆▃       ▄▃▁▁                                                 \n  █████▆▆█▇▆████▇▇▄▄▅▅▅▅▆▄▅▁▅▄▄▄▁▁▁▄▁▄▄▄▁▁▄▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▄▁▁▁▅ ▆\n  176 μs        Histogram: log(frequency) by time        459 μs &lt;\n\n Memory estimate: 105.45 KiB, allocs estimate: 1785.\nFunction: trajectory - vectorized global coordinates\nBenchmarkTools.Trial: 523 samples with 100 evaluations.\n Range (min … max):  175.311 μs … 268.996 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     179.317 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   191.211 μs ±  20.788 μs  ┊ GC (mean ± σ):  5.63% ± 8.61%\n\n   ▃█▄                                                           \n  ▇███▆▅▃▄▄▃▃▃▃▃▃▂▃▂▂▂▁▁▂▂▁▁▁▁▁▁▂▁▁▁▂▁▁▂▁▁▁▁▁▁▁▂▃▄▆▆▃▃▃▃▃▂▂▁▂▃▂ ▃\n  175 μs           Histogram: frequency by time          237 μs &lt;\n\n Memory estimate: 105.30 KiB, allocs estimate: 1783.\nFunction: trajectory - vectorized global coordinates, reltol=1e-8\nBenchmarkTools.Trial: 297 samples with 100 evaluations.\n Range (min … max):  251.965 μs …   1.033 ms  ┊ GC (min … max): 0.00% … 10.84%\n Time  (median):     298.382 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   337.601 μs ± 136.062 μs  ┊ GC (mean ± σ):  5.99% ±  6.95%\n\n  █▄  ▆▅▁                                                        \n  ██▄████▆▇▄▅▆▆▅▄▇▆▆▄▇▄▆▄▅▅▄▁▁▁▅▄▁▄▄▁▄▄▁▄▄▄▁▄▄▅▁▁▇▁▄▄▁▄▅▄▁▁▁▁▁▄ ▅\n  252 μs        Histogram: log(frequency) by time        859 μs &lt;\n\n Memory estimate: 182.38 KiB, allocs estimate: 2920.\nFunction: trajectory - extract position\nBenchmarkTools.Trial: 10000 samples with 434 evaluations.\n Range (min … max):  199.675 ns …   9.522 μs  ┊ GC (min … max): 0.00% … 94.55%\n Time  (median):     204.374 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   236.174 ns ± 391.711 ns  ┊ GC (mean ± σ):  7.67% ±  4.52%\n\n  ██▇▅▃▁▂▁▂ ▁▁▂▂▁   ▁     ▁                                     ▂\n  ████████████████▇██▇██▇▇█▇██████▇██▆▆▇▇▇▇▇▆▅▇▆▆▆▅▆▄▅▅▆▅▄▄▄▅▄▅ █\n  200 ns        Histogram: log(frequency) by time        383 ns &lt;\n\n Memory estimate: 240 bytes, allocs estimate: 3.\nFunction: trajectory - extract position (100)\nBenchmarkTools.Trial: 10000 samples with 10 evaluations.\n Range (min … max):  20.560 μs … 981.239 μs  ┊ GC (min … max): 0.00% … 93.33%\n Time  (median):     23.786 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   31.414 μs ±  36.598 μs  ┊ GC (mean ± σ):  7.71% ±  6.83%\n\n  █▇▇▆▆▅▅▄▄▄▃▄▃▃▃▂▂▂▁▁▁ ▁  ▁             ▁  ▁▁▁▁▁▁▁▁▁▁         ▂\n  ██████████████████████████████▇▇▇▇█▇▇▇███████████████████▇▇▇ █\n  20.6 μs       Histogram: log(frequency) by time      70.4 μs &lt;\n\n Memory estimate: 24.31 KiB, allocs estimate: 301.\nFunction: trajectory - extract position (100) - vectorized\nBenchmarkTools.Trial: 10000 samples with 10 evaluations.\n Range (min … max):  20.626 μs …  1.362 ms  ┊ GC (min … max): 0.00% … 93.74%\n Time  (median):     24.045 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   32.101 μs ± 46.974 μs  ┊ GC (mean ± σ):  9.51% ±  7.12%\n\n  █▇▆▆▅▅▄▃▃▃▃▃▂▂▂▂▁▁▁ ▁▁▁ ▁                                   ▂\n  █████████████████████████████████▇███▇▇█▇▇▇▇▆▆▆▆▇▅▆▆▆▆▅▃▆▅▄ █\n  20.6 μs      Histogram: log(frequency) by time      85.4 μs &lt;\n\n Memory estimate: 26.08 KiB, allocs estimate: 302."
  },
  {
    "objectID": "api/surfaces/temperature.html",
    "href": "api/surfaces/temperature.html",
    "title": "Temperature",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/surfaces/temperature.html#usage",
    "href": "api/surfaces/temperature.html#usage",
    "title": "Temperature",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/surfaces/temperature.html#api",
    "href": "api/surfaces/temperature.html#api",
    "title": "Temperature",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlunar_surface_temperatures_diviner – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner(lng0::Real)\n[2] lunar_surface_temperatures_diviner(lng0::Real, lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner(lng0::Real, lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner(lng0::Real, xs::GlobalSphericalPosition) \n[5] lunar_surface_temperatures_diviner(lng0::Real, XS::Vector{GlobalSphericalPosition}) \n[6] lunar_surface_temperatures_diviner(lng0::Real, grid::Abstract2DGrid)\nReturns the Diviner measurements based lunar surface temperatures, with the sub-solar point shifted by lng (in radians) from the center.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_diviner_avg – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner_avg()\n[2] lunar_surface_temperatures_diviner_avg(lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner_avg(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner_avg(xs::GlobalSphericalPosition)\n[5] lunar_surface_temperatures_diviner_avg(XS::Vector{GlobalSphericalPosition})\n[6] lunar_surface_temperatures_diviner_avg(grid::Abstract2DGrid)\nReturns the Diviner measurements based averaged lunar surface temperatures.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_BUTLER1997 – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_BUTLER1997(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_BUTLER1997(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_BUTLER1997(xs::GlobalSphericalPosition)\n[4] lunar_surface_temperatures_BUTLER1997(XS::Vector{GlobalSphericalPosition})\n[5] lunar_surface_temperatures_BUTLER1997(grid::Abstract2DGrid)\nCalculates the surface temperature based on the approximation given in Butler, 1997. Takes the SSE coordinates lngs and lats and returns the temperature vector of equal size at the given pair.\nT = 250*cos(Z)^1/4 + 100 on the Sun-side, and T = 100 on the night-side, in kelvin.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_HURLEY2015 – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_HURLEY2015(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_HURLEY2015(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_HURLEY2015(xs::GlobalSphericalPosition)\n[4] lunar_surface_temperatures_HURLEY2015(XS::Vector{GlobalSphericalPosition})\n[5] lunar_surface_temperatures_HURLEY2015(grid::Abstract2DGrid)\nCalculates the lunar surface temperatures based on the analytic formula given in Hurley et al. 2015. All angular arguments are in radians."
  },
  {
    "objectID": "documentation/regolith/composition.html",
    "href": "documentation/regolith/composition.html",
    "title": "5.1 Regolith Composition",
    "section": "",
    "text": "Atomic vs. Mass vs. Mineralogic Composition\n\n Table LaTeX\n\n\n\n\nTable 1: Average chemical compositions of surficial lunar regolith (Taylor, 1975). Elements are sorted by descending Maria atomic composition, and oxides are sorted by descending Maria weight composition.\n\n\n\n\n\n\n\n\n\n\nElement / Oxide\nAtomic Mass / Molecular Mass\nMaria\\(\\left[\\,\\mathrm{atom.\\%}\\right]\\)\nMaria\\(\\left[\\,\\mathrm{wt. \\%}\\right]\\)\nHighlands\\(\\left[\\,\\mathrm{atom.\\%}\\right]\\)\nHighlands\\(\\left[\\,\\mathrm{wt. \\%}\\right]\\)\n\n\n\n\n\\(\\ce{O}\\)\n\\(15.999\\)\n\\(60.3\\)\n\\(43.2\\)\n\\(61.1\\)\n\\(45.1\\)\n\n\n\\(\\ce{Si}\\)\n\\(28.085\\)\n\\(16.9\\)\n\\(21.2\\)\n\\(16.3\\)\n\\(21.1\\)\n\n\n\\(\\ce{Al}\\)\n\\(26.982\\)\n\\(6.5\\)\n\\(7.8\\)\n\\(10.1\\)\n\\(12.6\\)\n\n\n\\(\\ce{Mg}\\)\n\\(24.305\\)\n\\(5.1\\)\n\\(5.5\\)\n\\(4.0\\)\n\\(4.5\\)\n\n\n\\(\\ce{Ca}\\)\n\\(40.078\\)\n\\(4.7\\)\n\\(8.4\\)\n\\(6.1\\)\n\\(11.3\\)\n\n\n\\(\\ce{Fe}\\)\n\\(55.845\\)\n\\(4.4\\)\n\\(11.0\\)\n\\(1.8\\)\n\\(4.6\\)\n\n\n\\(\\ce{Ti}\\)\n\\(47.867\\)\n\\(1.1\\)\n\\(2.4\\)\n\\(0.15\\)\n\\(0.3\\)\n\n\n\\(\\ce{Na}\\)\n\\(22.990\\)\n\\(0.4\\)\n\\(0.4\\)\n\\(0.4\\)\n\\(0.4\\)\n\n\n\\(\\ce{SiO2}\\)\n\\(60.083\\)\n\n\\(45.4\\)\n\n\\(45.5\\)\n\n\n\\(\\ce{Al2O3}\\)\n\\(101.961\\)\n\n\\(14.9\\)\n\n\\(24.0\\)\n\n\n\\(\\ce{FeO}\\)\n\\(71.844\\)\n\n\\(14.1\\)\n\n\\(5.9\\)\n\n\n\\(\\ce{CaO}\\)\n\\(56.077\\)\n\n\\(11.8\\)\n\n\\(15.9\\)\n\n\n\\(\\ce{MgO}\\)\n\\(40.304\\)\n\n\\(9.2\\)\n\n\\(7.5\\)\n\n\n\\(\\ce{TiO2}\\)\n\\(79.865\\)\n\n\\(3.9\\)\n\n\\(0.6\\)\n\n\n\\(\\ce{Na2O}\\)\n\\(61.979\\)\n\n\\(0.6\\)\n\n\\(0.6\\)\n\n\n\n\n\n\n\n\n\n\n(Taylor, 1975, pp. 62–64)\n\n Figure LaTeX Downloads\n\n\n\n\n\nFigure 1: Exemplary percentage conversion of the average atomic and mineralogic composition of lunar regolith reported by Taylor (1975). Oxygen is highlighted to underline its great abundance.\n\n\n\n\n\\usepackage[scaled]{helvet}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\n\\usepackage{siunitx}\n\\usepackage[version=4]{mhchem}\n\n\\usepackage{xcolor}\n\\definecolor{TUMBlue}{HTML}{0065BD}\n\n\\newcommand{\\apsize}{\\fontsize{44pt}{20pt}\\selectfont}\n\\newcommand{\\mpsize}{\\fontsize{48pt}{20pt}\\selectfont}\n\\newcommand{\\ompsize}{\\fontsize{35pt}{20pt}\\selectfont}\n\\newcommand{\\mycell}[2]{\\begin{tabular}{c}\\ce{#1}\\\\\\SI{#2}{\\percent}\\end{tabular}}\n\n\\begin{document}\n\n\n\\begin{tikzpicture}[scale=1.4,\n    main/.style={draw=none, left color=black, right color=lightgray, fill opacity=0.5},\n    nmain/.style={text=black, fill opacity=1},\n    nel/.style={text=white, fill opacity=1, font=\\footnotesize},\n]\n\n    \\def\\d{5}\n    \\def\\m{2.5}\n    \\def\\a{0.3}\n\n    % background\n    \\node[rotate=90, font=\\apsize\\bf, fill opacity=0.2, anchor=south east] at (-0.8, 0) {ATOMIC PERCENTAGES};\n    \\node[rotate=90, font=\\mpsize\\bf, fill opacity=0.2, anchor=east] at ($(\\d, 0) + (1.25,0)$) {MASS PERCENTAGES};\n    \\node[rotate=90, font=\\ompsize\\bf, fill opacity=0.2, anchor=east] at ($(2*\\d+\\m, 0) + (1.5,0)$) {OXIDES MASS PERCENTAGES};\n\n\n    % O 60.3% (1) &gt;&gt; 43.2% (1)\n    \\draw[main, left color=TUMBlue] (0, 0.0)     to[in=180, out=0] \n                (\\d, 0.0)    -- node[nmain,right] {\\SI{43.2}{\\percent}}\n                (\\d, -4.324) to[in=0, out=180] \n                (0, -6.066)  -- node[nel, right] {Oxygen} node[nmain,left] {\\SI{60.3}{\\percent}} cycle;\n\n    % Si 16.9% (2) &gt;&gt; 21.2% (2)\n    \\draw[main] ($(0, -6.066)  - (0, \\a)$) to[in=180, out=0] \n                ($(\\d, -4.324) - (0, \\a)$) -- node[nmain,right] {\\SI{21.2}{\\percent}}\n                ($(\\d, -6.445) - (0, \\a)$) to[in=0, out=180] \n                ($(0, -7.766)  - (0, \\a)$) -- node[nel, right] {Si} node[nmain,left] {\\SI{16.9}{\\percent}} cycle;\n\n    \n    % Al 6.5% (3) &gt;&gt; 7.8% (5)\n    \\draw[main] ($(0, -7.766) - (0, 2*\\a)$) to[in=180, out=0] \n                ($(\\d, -8.39) - (0, 4*\\a)$) -- node[nmain,right] {\\SI{7.8}{\\percent}}\n                ($(\\d, -9.17) - (0, 4*\\a)$) to[in=0, out=180] \n                ($(0, -8.42)  - (0, 2*\\a)$) -- node[nel, right] {Al} node[nmain,left] {\\SI{6.5}{\\percent}} cycle;\n                              \n    \n    % Mg 5.1% (4) &gt;&gt; 5.5% (6)\n    \\draw[main] ($(0, -8.42)   - (0, 3*\\a)$) to[in=180, out=0] \n                ($(\\d, -9.17)  - (0, 5*\\a)$) -- node[nmain,right] {\\SI{5.5}{\\percent}}\n                ($(\\d, -9.72)  - (0, 5*\\a)$) to[in=0, out=180] \n                ($(0, -8.94)   - (0, 3*\\a)$) -- node[nel, right] {Mg} node[nmain,left] {\\SI{5.1}{\\percent}} cycle;\n                              \n    % Ca 4.7% (5) &gt;&gt; 8.4% (4)\n    \\draw[main] ($(0, -8.94)   - (0, 4*\\a)$) to[in=180, out=0] \n                ($(\\d, -7.547) - (0, 3*\\a)$) -- node[nmain,right] {\\SI{8.4}{\\percent}}\n                ($(\\d, -8.39)  - (0, 3*\\a)$) to[in=0, out=180] \n                ($(0, -9.41)   - (0, 4*\\a)$) -- node[nel, right] {Ca} node[nmain,left] {\\SI{4.7}{\\percent}} cycle;\n    \n    % Fe 4.4% (6) &gt;&gt; 11.0% (3)\n    \\draw[main] ($(0, -9.41)   - (0, 5*\\a)$) to[in=180, out=0] \n                ($(\\d, -6.445) - (0, 2*\\a)$) -- node[nmain,right] {\\SI{11.0}{\\percent}}\n                ($(\\d, -7.547) - (0, 2*\\a)$) to[in=0, out=180] \n                ($(0, -9.85)   - (0, 5*\\a)$) -- node[nel, right] {Fe} node[nmain,left] {\\SI{4.4}{\\percent}} cycle;\n\n    % Ti 1.1% (7) &gt;&gt; 2.4% (7)\n    \\draw[main] ($(0, -9.85)  - (0, 6*\\a)$) to[in=180, out=0] \n                ($(\\d, -9.72) - (0, 6*\\a)$) -- node[nmain,right] {\\SI{2.4}{\\percent}}\n                ($(\\d, -9.96) - (0, 6*\\a)$) to[in=0, out=180] \n                ($(0, -9.96)  - (0, 6*\\a)$) -- node[nel, right, black, xshift=30px, yshift=7px] {Ti} node[nmain,left] {\\SI{1.1}{\\percent}} cycle;\n\n    % Na 0.4% (8) &gt;&gt; 0.4% (8)\n    \\draw[main] ($(0, -9.96)  - (0, 7*\\a)$) to[in=180, out=0] \n                ($(\\d, -9.96) - (0, 7*\\a)$) -- node[nmain,right, yshift=-2px] {\\SI{0.4}{\\percent}}\n                ($(\\d, -10.0) - (0, 7*\\a)$) to[in=0, out=180] \n                ($(0, -10.0)  - (0, 7*\\a)$) -- node[nel, right, black, yshift=-6px] {Na} node[nmain,left, yshift=-3px] {\\SI{0.4}{\\percent}} cycle;\n    \n\n\n    %::. MINERALS\n    % SiO2 45.4% &gt;&gt; 24.2% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, 0.0)$)     to[in=180, out=0]\n                ($(2*\\d+\\m, 0.0)$)   -- \n                ($(2*\\d+\\m, -2.42)$) to[in=0, out=180]\n                ($(\\d+\\m, -2.42)$)   -- node[nmain,left] {\\SI{24.2}{\\percent}} node[nel,right] {Oxygen} cycle;\n\n    \\draw[main] ($(\\d+\\m, -4.324)  - (0, \\a)$) to[in=180, out=0] node[nmain,right,at end] {\\mycell{SiO2}{45.4}}\n                ($(2*\\d+\\m, -2.42)$)           -- \n                ($(2*\\d+\\m, -4.54)$)            to[in=0, out=180]\n                ($(\\d+\\m, -6.445)  - (0, \\a)$) -- node[nel,right] {Si} cycle;\n                \n    % Al2O3 14.9% &gt;&gt; 7.01% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -2.42)$)              to[in=180, out=0]\n                ($(2*\\d+\\m, -4.54)  - (0, \\a)$) -- \n                ($(2*\\d+\\m, -5.241) - (0,\\a)$)  to[in=0, out=180]\n                ($(\\d+\\m, -3.121)$)             --  node[nmain,left] {\\SI{7.0}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -8.39)    - (0, 4*\\a)$) to[in=180, out=0] node[nmain,right,at end] {\\mycell{Al2O3}{14.9}}\n                ($(2*\\d+\\m, -5.241) - (0, \\a)$)   -- \n                ($(2*\\d+\\m, -6.03)  - (0,\\a)$)    to[in=0, out=180]\n                ($(\\d+\\m, -9.17)    - (0, 4*\\a)$) -- node[nel,right] {Al} cycle;\n                \n    % FeO 14.1% &gt;&gt; 3.14% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -3.121)$)               to[in=180, out=0]\n                ($(2*\\d+\\m, -6.03)  - (0, 2*\\a)$) -- \n                ($(2*\\d+\\m, -6.344) - (0, 2*\\a)$) to[in=0, out=180]\n                ($(\\d+\\m, -3.435)$)               --  node[nmain,left] {\\SI{3.1}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -6.344)    - (0, 2*\\a)$)  to[in=180, out=0] node[nmain,right,at end,yshift=-18px] {\\mycell{FeO}{14.1}}\n                ($(2*\\d+\\m, -6.344) - (0, 2*\\a)$)  -- \n                ($(2*\\d+\\m, -7.44)    - (0, 2*\\a)$) to[in=0, out=180]\n                ($(\\d+\\m, -7.547)    - (0, 2*\\a)$)  -- node[nel,right] {Fe} cycle;\n\n    % CaO 11.8% &gt;&gt; 3.652% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -3.435)$)                to[in=180, out=0]\n                ($(2*\\d+\\m, -7.44)   - (0, 3*\\a)$) -- \n                ($(2*\\d+\\m, -7.8052) - (0, 3*\\a)$) to[in=0, out=180]\n                ($(\\d+\\m, -3.8002)$)               --  node[nmain,left] {\\SI{3.7}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -7.547)    - (0, 3*\\a)$)  to[in=180, out=0] node[nmain,right,at end,yshift=-10px] {\\mycell{CaO}{11.8}}\n                ($(2*\\d+\\m, -7.8052) - (0, 3*\\a)$)  -- \n                ($(2*\\d+\\m, -8.62)   - (0, 3*\\a)$)  to[in=0, out=180]\n                ($(\\d+\\m, -8.39)     - (0, 3*\\a)$)  -- node[nel,right] {Ca} cycle;\n\n    % MgO 9.2% &gt;&gt; 3.367% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -3.8002)$)                to[in=180, out=0]\n                ($(2*\\d+\\m, -8.62)   - (0, 4*\\a)$) -- \n                ($(2*\\d+\\m, -8.9567) - (0, 4*\\a)$) to[in=0, out=180]\n                ($(\\d+\\m, -4.1369)$)               --  node[nmain,left,yshift=2px] {\\SI{3.4}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -9.17)     - (0, 5*\\a)$)  to[in=180, out=0] node[nmain,right,at end,yshift=-5px] {\\mycell{MgO}{9.2}}\n                ($(2*\\d+\\m, -8.9567) - (0, 4*\\a)$)  -- \n                ($(2*\\d+\\m, -9.54)   - (0, 4*\\a)$)  to[in=0, out=180]\n                ($(\\d+\\m, -9.72)     - (0, 5*\\a)$)  -- node[nel,right] {Mg} cycle;\n\n    % TiO2 3.9% &gt;&gt; 1.562% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -4.1369)$)                to[in=180, out=0, looseness=0.95]\n                ($(2*\\d+\\m, -9.54)    - (0, 5*\\a)$) -- \n                ($(2*\\d+\\m, -9.6962)  - (0, 5*\\a)$) to[in=0, out=180, looseness=0.95]\n                ($(\\d+\\m, -4.2931)$)                --  node[nmain,left,yshift=2px] {\\SI{1.6}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -9.72)     - (0, 6*\\a)$)  to[in=180, out=0] node[nmain,right,at end,yshift=-3px] {\\mycell{TiO2}{3.9}}\n                ($(2*\\d+\\m, -9.6962) - (0, 5*\\a)$)  -- \n                ($(2*\\d+\\m, -9.93)   - (0, 5*\\a)$)  to[in=0, out=180]\n                ($(\\d+\\m, -9.96)     - (0, 6*\\a)$)  -- node[nel,right] {Ti} cycle;\n\n    % Na2O 0.6% &gt;&gt; 0.1549% O\n    \\draw[main, left color=TUMBlue] ($(\\d+\\m, -4.2931)$)               to[in=180, out=0, looseness=0.9]\n                ($(2*\\d+\\m, -9.93)   - (0, 6*\\a)$) -- \n                ($(2*\\d+\\m, -9.9455) - (0, 6*\\a)$) to[in=0, out=180, looseness=0.9]\n                ($(\\d+\\m, -4.309)$)                --  node[nmain,left,yshift=-3px] {\\SI{0.2}{\\percent}} cycle;\n\n    \\draw[main] ($(\\d+\\m, -9.96)     - (0, 7*\\a)$) to[in=180, out=0] node[nmain,right,at end,yshift=-6px] {\\mycell{Na2O}{0.6}}\n                ($(2*\\d+\\m, -9.9455) - (0, 6*\\a)$) -- \n                ($(2*\\d+\\m, -9.99)   - (0, 6*\\a)$) to[in=0, out=180]\n                ($(\\d+\\m, -10.0)     - (0, 7*\\a)$) -- node[nel,right, black, yshift=-5px] {Na} cycle;\n\n\\end{tikzpicture}\n\n\n\n composition_pg.pdf \n composition_pg.svg \n\n\n\n\n\n\n\n\n\n\nReferences\n\nTaylor, S. R. (1975). Lunar Science: A Post-Apollo View: Scientific results and insights from the lunar samples. Elsevier Science.\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "href": "documentation/drivers/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.693\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(0.866\\)\n\\(\\approx\\sqrt{3/4}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(0.916\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(0.94\\)\n\\(\\approx\\sqrt{9\\pi/32}\\)\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.594\\)\n\\(2.0\\)\n\\(1.155\\)\n\\(\\approx\\sqrt{4/3}\\)\n\\(1.064\\)\n\\(\\approx\\sqrt{32/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.16\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.395\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(1.54\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(1.822\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(2.149\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-distribution",
    "href": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-distribution",
    "title": "3.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Distribution",
    "text": "Maxwell-Boltzmann Distribution\nThe MBD (Maxwell-Boltzmann velocity distribution) is a probability distribution function that describes the distribution of velocities and speeds of particles in a gas or liquid. It is intimately connected to the kinetic gas theory, which explains the behavior of gases in terms of the motion of their constituent particles, which is proportional to their temperature.\n\n\n MaxwellBoltzmannVelocityDistribution\nThe one-dimensional pdf of the MBD, given for a velocity in the direction \\(x\\), is \\[\\begin{equation}\n   f(v_x)dv_x = \\sqrt{\\frac{m}{2\\pi k_BT}} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x\n   \\label{eq:mbd_1d}\n\\end{equation}\\] with the mass \\(m\\) and available thermodynamic temperature \\(T\\) of the particle, and the Boltzmann constant \\(k_B\\), properly normalized so that \\(\\int_{-\\infty}^\\infty f(v_x)dv_x = 1\\). Note that this distribution is identical to a Gaussian distribution with zero mean and variance of \\(k_BT/ m\\) (Crider & Vondrak, 2002; Smolka, 2022).\nOne can extend the distribution to three cartesian dimensions, with the velocity vector \\(\\boldsymbol{\\mathbf{v}}= \\left[v_x, v_y, v_z\\right]^T\\) and \\(d^3\\boldsymbol{\\mathbf{v}}= dv_xdv_ydv_z\\), by linearly combining all three pdf given in Eq. \\(\\eqref{eq:mbd_1d}\\) \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbd_3d}\n\\end{equation}\\] with the speed \\(v=\\sqrt{\\boldsymbol{\\mathbf{v}}^T\\boldsymbol{\\mathbf{v}}}\\). Identical to the one-dimensional form of the distribution, the three-dimensional one is based on a symmetric Gaussian distribution with zero mean. In order to convert it into a distribution of speeds, Eq. \\(\\eqref{eq:mbd_3d}\\) can be integrated twice over arbitrary solid angles, utilizing its symmetry. For this, the differential will be expressed in spherical coordinates \\(\\boldsymbol{\\mathbf{v}}\\left(v, \\vartheta, \\varphi\\right) = \\left[ v\\cos\\vartheta\\cos\\varphi,\\, v\\sin\\vartheta\\cos\\varphi,\\, v\\sin\\varphi\\right]^T\\), leading to the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) with \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\), which results in \\[\\begin{equation}\n    f(v)dv= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv. \\label{eq:mbd_speed_3d}\n\\end{equation}\\]\n\n\n velocity_cdf: integrated Eq. \\(\\eqref{eq:mbd_3d}\\)   velocity_pdf: Eq. \\(\\eqref{eq:mbd_3d}\\)      speed_cdf: integrated Eq. \\(\\eqref{eq:mbd_speed_3d}\\)   speed_pdf: Eq. \\(\\eqref{eq:mbd_speed_3d}\\)\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann velocity distribution.\n\n\n\nEquation \\(\\eqref{eq:mbd_3d}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n        f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n        &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_{-\\infty}^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\quad\\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\;\\quad f(\\varphi) \\, d\\varphi\\quad\\cdot && \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} &\\cdot& \\quad \\overbrace{\\frac{1}{2}\\cos\\varphi\\; d\\varphi} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{0}^\\infty f(v) dv= \\int_{-\\pi/2}^{\\pi/2} f(\\varphi) d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\, d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional as well as their components are normalized.\n\n\n\n\n Figure Julia Downloads\n\n\n\n\n\nFigure 1: Normalized Maxwell-Boltzmann velocity and speed distributions according to Eqs. \\(\\eqref{eq:mbd_1d}\\), \\(\\eqref{eq:mbd_speed_3d}\\). For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbd_most_probable_speed}\\), \\(\\eqref{eq:mbd_mean_speed}\\), \\(\\eqref{eq:mbd_rms}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \nfunction mbd(name=\"mbd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbd1d  = sqrt(1/2/pi) .* exp.(-x1.^2 ./ 2)\n    mbd3d  = 4*pi*(1/2/pi)^1.5 .* x2.^2 .* exp.(-x2.^2 ./ 2)\n    mbd1d2 = 2*sqrt(1/2/pi) .* exp.(-x2.^2 ./ 2)\n\n    # plot distributions\n    lines!(ax, x1, mbd1d; color=TUMBlueDark)\n    lines!(ax, x2, mbd1d2; color=TUMBlueLight)\n    lines!(ax, x2, mbd3d; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(2);            fvp = 4*pi*(1/2/pi)^1.5*vp^2*exp(-vp^2/2)\n    vmean = 2/sqrt(pi) * vp; fvmean = 4*pi*(1/2/pi)^1.5*vmean^2*exp(-vmean^2/2)\n    vrms = sqrt(1.5) * vp;   fvrms = 4*pi*(1/2/pi)^1.5*vrms^2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*1.1, fvrms*1.01; text=\"root mean squared\", align=ALGN, fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBD\", \"1D-MBD, one-directional\", \"3D-MBD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbd.pdf   mbd.svg   mbd.png \n\n\n\n\nFigure 1 shows three normalized MBDs, using the mass \\(m\\) and temperature \\(T\\) for the normalization. The one-dimensional distribution (1D-MBD) according to Eq. \\(\\eqref{eq:mbd_1d}\\) shows the symmetric normal distribution, as the normalization \\(\\sqrt{m/ (k_BT)} = 1\\,\\mathrm{s/m}\\) leads to a Gaussian distribution with zero mean and unit variance. The second one-dimensional distribution (1D-MBD, one-directional) shows the same equation but in its one-directional form, leading to only positive velocities. Mathematically, this operation changes the integration boundaries for the elevation angle \\(\\varphi\\) to \\(\\left[0, \\pi/2\\right)\\), which in turn leads to a doubling of the prefactor to assure pdf normalization: \\[\\begin{equation}\n    f_+(v_x)dv_x = \\begin{cases}\n        2 \\cdot f(v_x) dv_x, & \\quad v_x \\geq 0\\,\\mathrm{m/s}, \\\\\n        0, & \\quad \\text{else.}\n    \\end{cases}\n    \\label{eq:mbd_1d+}\n\\end{equation}\\] These one-directional forms of the MBD are helpful for velocities where one direction is obstructed, for example when launching particles from a surface, where a movement downwards into the ground is not physical. The third distribution (3D-MBD, speed) presents the graph of Eq. \\(\\eqref{eq:mbd_speed_3d}\\). Note that, as with the graph before, this distribution is also one-directional, though in this case, it is by nature, since the speed in the spherical coordinate system description can only assume a positive value. Additionally, the speed distribution has three indicated and typical speeds shown, which will be explained in the following.\nFurthermore, the angular arguments, \\(\\vartheta\\) and \\(\\varphi\\), also have a distinct probability distribution. As a result of the transformation of \\(f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}\\) from cartesian coordinates in Eq. \\(\\eqref{eq:mbd_3d}\\) into spherical coordinates with the speed given in Eq. \\(\\eqref{eq:mbd_speed_3d}\\), the two remaining distributions are \\[\\begin{align}\n    f(\\vartheta)d\\vartheta&= \\frac{1}{2\\pi} d\\vartheta\\label{eq:mbd_azimuth} \\\\\n    f(\\varphi)d\\varphi&= \\frac{1}{2} \\cos\\varphi d\\varphi. \\label{eq:mbd_elevation}\n\\end{align}\\] While the azimuth is uniformly distributed with no preferred direction, the elevation angle is sine-distributed. For one-direction applications, i.e. for \\(\\varphi\\in \\left[0, \\pi/2\\right)\\), this leads to a mean angle not equal to zero, calculated as the angle-weighted expectation of the probability distribution: \\[\\begin{equation}\n    \\langle \\varphi \\rangle = 2 \\int_0^{\\pi/2} \\frac{1}{2} \\varphi\\cos\\varphi d\\varphi= \\frac{\\pi - 2}{2}.\n\\end{equation}\\] Note that the factor \\(2\\) in front of the integral is used since the integration boundaries are only half of the full domain. Alternatively, the full domain \\(\\varphi\\in \\left(-\\pi/2, \\pi/2\\right)\\) can be used if one only takes the absolute value of the function. Figure 2 shows the density plot of \\(10^6\\) normalized samples of velocities of the MBD in a 2D plot with the vertical velocity \\(v_3\\) is plotted against the horizontal velocity \\(\\sqrt{v_1^2 + v_2^2}\\). For each sample, the angle between the x-axis and the velocity vector is the elevation angle, with the mean value \\(\\langle \\varphi \\rangle\\) included in the plot.\n\n\n elevation_cdf: integrated Eq. \\(\\eqref{eq:mbd_elevation}\\)   elevation_pdf: Eq. \\(\\eqref{eq:mbd_elevation}\\)\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 2: Density plot of \\(10^{6}\\) normalized samples of a one-directional MBD distributed velocities, shown in 2D without the uniform azimuth component. The line shows the mean elevation angle \\(\\langle \\varphi \\rangle\\).\n\n\n\n\nusing .ExESS\n\nusing CairoMakie, ColorSchemes\nusing LinearAlgebra\nusing Makie.StructArrays\n\n\nfunction get_data(vd; N=100)\n    # create and norm sampels \n    samples = [velocity(vd) for _ in 1:N]\n    samples_normed = samples ./ max(norm.(samples)...)\n\n    # 3D -&gt; 2D\n    S = [[sqrt(s[1]^2 + s[2]^2), abs.(s[3])] for s in samples_normed]\n\n    # filter outliers (for cleaner plots)\n    S_filtered = []\n    for i in eachindex(S)\n        if norm(S[i]) &lt; 0.8\n            push!(S_filtered, S[i])\n        end\n    end\n\n    return S_filtered\nend\n\n\nfunction plot_data(s, type)\n    # figure & axis setup\n    fig = Figure(; resolution=(600,500), figure_padding=(-25,10,10,-10))\n    ax = Axis(fig[1,1]; aspect=DataAspect())\n    hidedecorations!(ax)\n    hidespines!(ax)\n\n    # turn data to points for plotting recipe\n    points = hcat(s...)'\n    P = [Point2f(points[i,1], points[i,2]) for i in 1:size(points)[1]]\n\n    # create colormap (white background)\n    cmap = to_colormap(ColorSchemes.dense)\n    cmap[1] = RGBAf(1, 1, 1, 1)\n\n    # plot data\n    ds = datashader!(ax, P; async=false, colormap=cmap)\n\n    # add mean line and ave figure\n    if type == :mb\n        lines!(ax, 0.8.*[0,0.84147], 0.8.*[0,0.540302]; color=:black) # MB\n        lines!(ax, 0.4*cos.(0:0.01:(pi-2)/2), 0.4*sin.(0:0.01:(pi-2)/2); color=:black)\n        save(joinpath(@__DIR__, \"mbd_elevation.png\"), fig, px_per_unit=8)\n    elseif type == :mbf\n        lines!(ax, [0,0.70711], [0,0.70711]; color=:black)  # MBF\n        lines!(ax, 0.4*cos.(0:0.01:pi/4), 0.4*sin.(0:0.01:pi/4); color=:black)\n        save(joinpath(@__DIR__, \"mbfd_elevation.png\"), fig, px_per_unit=8)\n    end\n    nothing\nend\n\nplot_data(get_data(MaxwellBoltzmannVelocityDistribution(1, amu2kg(1)); N=1_000_000), :mb)\n\n\n\\begin{tikzpicture}[]\n\n    \\node[anchor=south west] at (0,0) {\\includegraphics[width=300px]{mbd_elevation.png}};\n\n    \\node[anchor=west] at (5.25, 2) {$\\meanof{\\sphericalCoordinateElevation} = \\frac{\\pi - 2}{2} \\approx 0.5708$};\n\n    \\draw[thick, -latex] (0.9,0.55) -- +(8,0) node[midway, below] {Horizontal Velocity};\n    \\draw[thick, -latex] (0.9,0.55) -- +(0,8) node[midway, above, sloped] {Vertical Velocity};\n\n\\end{tikzpicture}\nNote that the code relies on custom-defined variables, like \\sphericalCoordinateElevation, and commands, like \\meanof{}, loaded into the preamble of the document.\n\n\n\n mbd_elevation.pdf   mbd_elevation.svg \n\n\n\n\n\nTypical Speeds\nOne of those typical speeds obtained from properties of the MBD is the most probable speed, \\(v_p\\), which describes the speed at which Eq. \\(\\eqref{eq:mbd_speed_3d}\\) reaches its maximum value. Since the pdf is normalized, we can infer that it must have at least one global extreme point at which its derivative equals zero: \\[\\begin{equation}\n   \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad\\Rightarrow\\qquad v_p = \\sqrt{\\frac{2k_BT}{m}}.\n    \\label{eq:mbd_most_probable_speed}\n\\end{equation}\\]\n\n\n speed: Eqs. \\(\\eqref{eq:mbd_most_probable_speed}\\), \\(\\eqref{eq:mbd_mean_speed}\\), \\(\\eqref{eq:mbd_rms}\\)\nAnother typical value that can be drawn from a distribution is the mean speed \\(\\langle v \\rangle\\). For the speed distribution, the expected value can be calculated by the speed-weighted average of the distribution: \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty v\\; f(v) \\; dv= \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n    \\label{eq:mbd_mean_speed}\n\\end{equation}\\] Note that the expected speed \\(\\langle v \\rangle\\) of the distribution is not equal to the median \\(m\\) of the distribution, for which the expression \\(\\int_0^m f(v) dv\\) evaluates to .\nLastly and similar to the mean speed, the mean square speed \\(\\langle v^2 \\rangle\\) is an important value describing the distribution. As the second-order raw moment, it corresponds to the average kinetic energy of a particle and can be translated into the root mean squared speed \\(v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle}\\): \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n    \\label{eq:mbd_rms}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} = \\frac{d}{dv} \\left[ \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) \\right]_{v_p} &= 0 \\\\\n    %\\Rightarrow\\quad &&\\; \\frac{d}{d\\velocity} \\Big[ \\velocity^2 \\cdot \\exp\\left( -a\\velocity^2\\right) \\Big]_{\\velocity_p} &= 0  \\\\\n     \\Rightarrow\\quad &&\\; 2v_p \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^3 \\cdot \\exp\\left( -av_p^2 \\right) &= 0  \\\\\n     \\Rightarrow\\quad &&\\; v_p = \\sqrt{\\frac{1}{a}} &= \\sqrt{\\frac{2k_BT}{m}}\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\): \\[\\begin{align*}\n    \\langle v \\rangle &= \\int_0^\\infty v\\; f(v) \\; dv= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\int_0^\\infty v^3 \\cdot \\exp\\left( - a v^2 \\right)dv\\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ - \\frac{\\left(av^2 + 1\\right) \\cdot \\exp\\left(-av^2\\right)}{2a^2} \\right]_0^\\infty \\\\\n    %\\Rightarrow \\quad \\meanof{\\velocity} &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[\\frac{1}{2a^2} \\right] \\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= \\sqrt{\\frac{4}{\\pi a}} = \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbd_rms}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function: \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}\\cdot\\mathop{\\mathrm{erf}}{\\left(\\sqrt{a}v\\right)}}{8a^{5/2}} - \\frac{v\\exp\\left(-av^2\\right)\\cdot\\left(2av^2+3\\right)}{4a^2} \\right]_0^\\infty \\right)^{1/2}  \\\\\n    %\\Rightarrow\\quad \\velocity_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}}{8a^{5/2}} \\right]\\right)^{1/2}  \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\sqrt{\\frac{3}{2a}} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 1: Overview of normalized speeds \\(v\\) of the MBD, according to Eq. \\(\\eqref{eq:mbd_speed_3d}\\), including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(v_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(v_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = sqrt(1/2/pi)^3 * 4 * pi * v^2 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(2)\n    vm = sqrt(8/pi)\n    vr = sqrt(3)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\",\"\",\"\",raw\"$\\approx\\sqrt{4/\\pi}$\",raw\"$\\approx\\sqrt{3/2}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{\\pi/4}$\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\",raw\"$\\approx\\sqrt{2/3}$\",\"\",raw\"$\\approx\\sqrt{8/3\\pi}$\",\"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n    \n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbd_typical_speeds.md\", \"w\")\n    write(fid, maketable(), \"\\\\\\\\\"=&gt;\"\\\\\")\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\n\n\nNumerical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBD velocity, then any realization of \\(\\boldsymbol{\\mathbf{V}}\\) can be drawn from the respective pdf, in this case Eq. \\(\\eqref{eq:mbd_3d}\\), \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) =  \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right).\n\\end{equation}\\] Numerically speaking, to draw any realization from a randomly distributed variable, the latter has to be mapped onto one implemented state space, which in the most basic cases is a uniform distribution with the random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u\\sim f(r_u) = 1\\) and a normal distribution with the random variable \\(R_n\\in\\left(-\\infty,\\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n|\\mu,\\sigma^2\\right)\\) with zero mean and unit variance. Since \\(\\boldsymbol{\\mathbf{V}}\\) is three-dimensional, each individual dimension requires its own mapping. In its cartesian form, \\(\\boldsymbol{\\mathbf{V}}=\\left(V_x, V_y, V_z\\right)\\), all three components are equal to a scaled normal distribution, which can be used directly as \\[\\begin{alignat}{3}\n    V_i &= R_n\\cdot \\sqrt{\\frac{k_BT}{m}} \\; \\sim \\; \\mathcal{N} \\left(v_i \\Big| 0, \\frac{k_BT}{m}\\right) \\qquad && \\forall i \\in \\{x, y, z\\} \\label{eq:mbd_random_cartesian_component_2} \\\\\n    \\Rightarrow\\qquad v_i &= r_n\\cdot \\sqrt{\\frac{k_BT}{m}} \\qquad &&\\forall i \\in \\{x,y,z\\}.\n    \\label{eq:mbd_random_cartesian_component}\n\\end{alignat}\\] Should one dimension be one-directional, the absolute value \\(|r_n|\\) can be used in Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\) instead.\n\n\n velocity: Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\)\nThe random variable \\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in its spherical form, with its three components the speed \\(V_v\\in \\left[0,\\infty\\right)\\) with realization \\(v\\) of \\(V_v\\sim f(v)\\), the elevation angle \\(V_\\varphi\\in \\left[-\\pi/2, \\pi/2\\right]\\) with realization \\(\\varphi\\) of \\(V_\\varphi\\sim f(\\varphi) = 1/2 \\cdot \\cos\\varphi\\), and the azimuth angle \\(V_\\vartheta\\in \\left[-\\pi,\\pi\\right)\\) with realization \\(\\vartheta\\) of \\(V_\\vartheta\\sim f(\\vartheta) = 1/2\\pi\\). Similar to the cartesian description above, these three random variables can be matched to one of the numerically implemented distributions. Because all three pdfs of the random variables are normalized, their cdf can be set equal to the cdf of the uniform unit distribution \\(R_u\\sim f(r_u) = 1\\): \\[\\begin{alignat}{4}\n    r_v&= \\int_0^{r_v} f(r_u)dr_u &&= \\int_0^{v} f(\\tilde v) d\\tilde v\\label{eq:mbd_speed_random}\\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u)dr_u &&= \\int_{-\\pi/2}^{\\varphi} f(\\tilde\\varphi) d\\tilde\\varphi&&= \\frac{1}{2}\\left(\\sin\\varphi+ 1\\right) \\label{eq:mbd_elevation_random}\\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u)dr_u &&= \\int_{-\\pi}^{\\vartheta} f(\\tilde\\vartheta) d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}, \\label{eq:mbd_azimuth_random}\n\\end{alignat}\\] where the speed distribution is equal to Eq. \\(\\eqref{eq:mbd_speed_3d}\\). With the latter two integrals being trivial, the speed integral of Eq. \\(\\eqref{eq:mbd_speed_random}\\) evaluates to: \\[\\begin{equation}\n   r_v= \\mathop{\\mathrm{erf}}\\left( \\sqrt{\\frac{mv^2}{2k_BT}} \\right) - \\frac{2}{\\sqrt{\\pi}} \\cdot \\sqrt{\\frac{mv^2}{2k_BT}} \\cdot \\exp\\left( - \\frac{mv^2}{2k_BT}\\right).\n   \\label{eq:mbd_speed_random_evaluated}\n\\end{equation}\\] Due to the combination of the Gaussian error function \\(\\mathop{\\mathrm{erf}}\\) and an exponential function \\(\\exp\\), there is no elementary analytical expression of \\(v\\) as a function of \\(r_v\\). Thus, for numerical implementations Eq. \\(\\eqref{eq:mbd_speed_random_evaluated}\\) is usually pre-evaluated several times to build up an interpolation table that maps any uniform random \\(r_v\\) to a specific MBD speed. The other two components, see Eqs. \\(\\eqref{eq:mbd_elevation_random}\\), \\(\\eqref{eq:mbd_azimuth_random}\\), show that the elevation angle \\(\\varphi\\) is \\(\\sin\\)-distributed, while the azimuth angle \\(\\vartheta\\) is uniformly distributed.\n\n\n speed: Eq. \\(\\eqref{eq:mbd_speed_random}\\)   elevation: Eq. \\(\\eqref{eq:mbd_elevation_random}\\)   azimuth: Eq. \\(\\eqref{eq:mbd_azimuth_random}\\)"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "href": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "title": "3.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Flux Distribution",
    "text": "Maxwell-Boltzmann Flux Distribution\nThe MBFD (Maxwell-Boltzmann flux velocity distribution) is a modified three-dimensional MBD, which is based on the upwards flux governed by the upwards velocity component. It is calculated by multiplying Eq. \\(\\eqref{eq:mbd_3d}\\) by this additional velocity component and re-normalizing the pdf (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022). Let \\(n\\) be a velocity-independent normalization factor, and \\(v_z &gt; 0\\) the upwards velocity component, then the three-dimensional form of the MBFD can be written as \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= n \\cdot \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbfd_raw}\n\\end{equation}\\]\n\n\n MaxwellBoltzmannFluxVelocityDistribution\nTo calculate the normalization factor \\(n\\), the flux distribution can be integrated over spherical coordinates and set to unity, with the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) and domains \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\). After solving the three-dimensional integral, the normalization factor can be derived to \\[\\begin{equation}\n     n = 2\\pi\\sqrt{\\frac{m}{2\\pi k_BT}},\n    \\label{eq:mbfd_normalization_factor}\n\\end{equation}\\] which can be included in the original description of the MBFD, given in Eq. \\(\\eqref{eq:mbfd_raw}\\), leading to \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd}\n\\end{equation}\\] in cartesian coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x \\, dv_y \\, dv_z\\), or \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v\\sin\\varphi\\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd_spherical}\n\\end{equation}\\] in spherical coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\varphi\\, d\\vartheta\\) (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022; Smith et al., 1978).\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann Flux velocity distribution.\n\n\n\nEquations \\(\\eqref{eq:mbfd}\\) and \\(\\eqref{eq:mbfd_spherical}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{2\\pi v_z \\left(\\frac{m}{2\\pi k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_0^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\quad f(\\varphi) \\, d\\varphi&\\cdot& \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{2\\cdot\\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} \\; &\\cdot& \\quad \\overbrace{2\\sin\\varphi\\cos\\varphi\\; d\\varphi\\phantom{\\frac{1}{1}}} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_0^\\infty f(v) dv= \\int_0^{\\pi/2} f(\\varphi) \\;d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\; d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional pdfs as well as their components are normalized.\n\n\n\nThrough integration over the solid angles of Eq. \\(\\eqref{eq:mbfd_spherical}\\), the MBFD speed distribution emerges as \\[\\begin{equation}\n    f(v)dv=  2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_speed}\n\\end{equation}\\] Note that the scaling factor \\(2\\) is a result of the integration over half the sphere through \\(\\varphi\\in\\left(0,\\pi/2\\right)\\). As before, this speed distribution can be analyzed to extract typical speeds.\n\n\n velocity_cdf: integrated Eqs. \\(\\eqref{eq:mbfd}\\), \\(\\eqref{eq:mbfd_spherical}\\)   velocity_pdf: Eqs. \\(\\eqref{eq:mbfd}\\), \\(\\eqref{eq:mbfd_spherical}\\)      speed_cdf: integrated Eq. \\(\\eqref{eq:mbfd_speed}\\)   speed_pdf: Eq. \\(\\eqref{eq:mbfd_speed}\\)\n\n Figure Julia Downloads\n\n\n\n\n\nFigure 3: Normalized Maxwell-Boltzmann flux velocity and speed distributions according to Eq. \\(\\eqref{eq:mbfd_speed}\\). The 1D-MBFD distribution is perpendicular to the flux direction, 1D-MBFD, flux is parallel to the flux direction. For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbfd_most_probable_speed}\\), \\(\\eqref{eq:mbfd_mean_speed}\\), \\(\\eqref{eq:mbfd_rms_speed}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \n\nfunction mbfd(name=\"mbfd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbfdx  = sqrt(1/2/pi) * exp.(- x1.^2 ./ 2)\n    mbfdz  = x2 .* exp.(- x2.^2 ./ 2)\n    mbfdv  = x2.^3 ./ 2 .* exp.(- x2.^2 ./ 2)\n\n    \n    # plot distributions\n    lines!(ax, x1, mbfdx; color=TUMBlueDark)\n    lines!(ax, x2, mbfdz; color=TUMBlueLight)\n    lines!(ax, x2, mbfdv; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(3);         fvp = vp^3/2*exp(-vp^2/2)\n    vmean = sqrt(9*pi/8); fvmean = vmean^3/2*exp(-vmean^2/2)\n    vrms = sqrt(4);       fvrms = vrms^3/2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*1.1, fvrms*1.0; text=\"root mean squared\", align=(:left, :center), fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBFD\", \"1D-MBFD, flux\", \"3D-MBFD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbfd.pdf   mbfd.svg   mbfd.png \n\n\n\n\nFigure 3 shows the probability densities of three MBFD distributed, normalized velocities. The normalization of the velocities has been performed with \\(\\sqrt{m/k_BT} = 1\\). The 1D-MBFD curve shows the pdf of a velocity component perpendicular to the flux direction, which is equal to one-dimensional MBD velocities, see Eq. \\(\\eqref{eq:mbd_1d}\\), which is equal to the scaled normal distribution \\(\\mathcal{N}(0, k_BT/m)\\). The second graph, 1D-MBFD, flux shows the distribution of a directed velocity component in flux direction, \\(f_\\parallel(v)\\), which is equal to \\[\\begin{equation}\n    f_\\parallel (v) dv= 2v\\left(\\frac{m}{2k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_1d_parallel}\n\\end{equation}\\] Last, the graph 3D-MBFD, speed shows the distribution of speeds of the three-dimensional form, given in Eq. \\(\\eqref{eq:mbfd_speed}\\). For the latter, the three typical speeds, the most probable speed \\(v_p\\), the mean speed \\(\\langle v \\rangle\\) or the expected speed, and the root mean squared speed \\(v_\\text{rms}\\), which are derived in the following section.\nNote that, as with the speed, the angular components, the azimuth \\(\\vartheta\\) and elevation \\(\\varphi\\), also have distinct probability distributions that can be analyzed. Similar to the Maxwell-Boltzmann velocity distribution, the azimuth angle is uniformly distributed which results in no favored direction of the horizontal velocity components. The vertical component is governed by the elevation angle, which is distributed according to its PDF \\[\\begin{equation}\n    f(\\varphi)d\\varphi= 2\\sin\\varphi\\cos\\varphi d\\varphi. \\label{eq:mbfd_elevation}\n\\end{equation}\\] This leads to a mean elevation angle for the Maxwell-Boltzmann flux velocity distribution of \\[\\begin{align}\n        \\langle \\varphi \\rangle &= \\int_0^{\\pi/2} 2\\varphi\\sin\\varphi\\cos\\varphi d\\varphi\\nonumber \\\\\n        &= \\varphi\\sin^2\\varphi\\Big|_0^{\\pi/2} - \\int_0^{\\pi/2} \\sin^2\\varphi d\\varphi= \\frac{\\pi}{2} - \\frac{\\pi}{4} = \\frac{\\pi}{4}.\n\\end{align}\\] Figure 4 shows the density plot of \\(10^6\\) normalized samples of velocities of the MBD in a 2D plot with the vertical velocity \\(v_3\\) is plotted against the horizontal velocity \\(\\sqrt{v_1^2 + v_2^2}\\). For each sample, the angle between the x-axis and the velocity vector is the elevation angle, with the mean value \\(\\langle \\varphi \\rangle\\) included in the plot.\n\n\n elevation_cdf: integrated Eq. \\(\\eqref{eq:mbfd_elevation}\\)   elevation_pdf: Eq. \\(\\eqref{eq:mbfd_elevation}\\)\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 4: Density plot of \\(10^{6}\\) normalized samples of a one-directional MBFD distributed velocities, shown in 2D without the uniform azimuth component. The line shows the mean elevation angle \\(\\langle \\varphi \\rangle\\).\n\n\n\n\nusing .ExESS\n\nusing CairoMakie, ColorSchemes\nusing LinearAlgebra\nusing Makie.StructArrays\n\n\nfunction get_data(vd; N=100)\n    # create and norm sampels \n    samples = [velocity(vd) for _ in 1:N]\n    samples_normed = samples ./ max(norm.(samples)...)\n\n    # 3D -&gt; 2D\n    S = [[sqrt(s[1]^2 + s[2]^2), abs.(s[3])] for s in samples_normed]\n\n    # filter outliers (for cleaner plots)\n    S_filtered = []\n    for i in eachindex(S)\n        if norm(S[i]) &lt; 0.8\n            push!(S_filtered, S[i])\n        end\n    end\n\n    return S_filtered\nend\n\n\nfunction plot_data(s, type)\n    # figure & axis setup\n    fig = Figure(; resolution=(600,500), figure_padding=(-25,10,10,-10))\n    ax = Axis(fig[1,1]; aspect=DataAspect())\n    hidedecorations!(ax)\n    hidespines!(ax)\n\n    # turn data to points for plotting recipe\n    points = hcat(s...)'\n    P = [Point2f(points[i,1], points[i,2]) for i in 1:size(points)[1]]\n\n    # create colormap (white background)\n    cmap = to_colormap(ColorSchemes.dense)\n    cmap[1] = RGBAf(1, 1, 1, 1)\n\n    # plot data\n    ds = datashader!(ax, P; async=false, colormap=cmap)\n\n    # add mean line and ave figure\n    if type == :mb\n        lines!(ax, 0.8.*[0,0.84147], 0.8.*[0,0.540302]; color=:black) # MB\n        lines!(ax, 0.4*cos.(0:0.01:(pi-2)/2), 0.4*sin.(0:0.01:(pi-2)/2); color=:black)\n        save(joinpath(@__DIR__, \"mbd_elevation.png\"), fig, px_per_unit=8)\n    elseif type == :mbf\n        lines!(ax, [0,0.70711], [0,0.70711]; color=:black)  # MBF\n        lines!(ax, 0.4*cos.(0:0.01:pi/4), 0.4*sin.(0:0.01:pi/4); color=:black)\n        save(joinpath(@__DIR__, \"mbfd_elevation.png\"), fig, px_per_unit=8)\n    end\n    nothing\nend\n\nplot_data(get_data(MaxwellBoltzmannFluxVelocityDistribution(1, amu2kg(1)); N=1_000_000), :mbf)\n\n\n\\begin{tikzpicture}[]\n\n    \\node[anchor=south west] at (0,0) {\\includegraphics[width=300px]{mbfd_elevation.png}};\n\n    \\node[anchor=west] at (5.35, 3) {$\\meanof{\\sphericalCoordinateElevation} = \\frac{\\pi}{4} \\approx 0.7853$};\n    \\draw[thick, -latex] (0.9,0.55) -- +(8,0) node[midway, below] {Horizontal Velocity};\n    \\draw[thick, -latex] (0.9,0.55) -- +(0,8) node[midway, above, sloped] {Vertical Velocity};\n\n\\end{tikzpicture}\nNote that the code relies on custom-defined variables, like \\sphericalCoordinateElevation, and commands, like \\meanof{}, loaded into the preamble of the document.\n\n\n\n mbfd_elevation.pdf   mbfd_elevation.svg \n\n\n\n\n\nTypical Speeds\nThe most probable speed occurs at the maximum likelihood of the Eq. \\(\\eqref{eq:mbfd_speed}\\): \\[\\begin{equation}\n    \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad \\Rightarrow \\qquad v_p = \\sqrt{\\frac{3k_BT}{m}}.\n    \\label{eq:mbfd_most_probable_speed}\n\\end{equation}\\]\n\n\n speed: Eqs. \\(\\eqref{eq:mbfd_most_probable_speed}\\), \\(\\eqref{eq:mbfd_mean_speed}\\), \\(\\eqref{eq:mbfd_rms}\\)\nThe expected value of the speed distribution, the mean speed \\(\\langle v \\rangle\\) is calculated by using the ensemble average equation, shown in Eq. \\(\\eqref{eq:ensemble_average}\\): \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty vf(v) dv= \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}} \\,\\cdot v_p.\n    \\label{eq:mbfd_mean_speed}\n\\end{equation}\\]\nLastly, the speed is calculated as \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v)dv\\right)^{1/2} = \\sqrt{\\frac{4k_BT}{m}} = \\sqrt{\\frac{4}{3}}\\,\\cdot v_p.\n    \\label{eq:mbfd_rms_speed}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann flux distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbfd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} =\\; \\frac{d}{dv} \\left[ 2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\\right]_{v_p} &= 0 \\\\\n    \\Rightarrow && \\left[3v_p^2 \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^4 \\cdot \\exp\\left( -av_p^2 \\right) \\right] &= 0 \\nonumber \\\\\n    \\Rightarrow &&\\; v_p = \\sqrt{\\frac{3}{2a}} &= \\sqrt{\\frac{3k_BT}{m}}.\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbfd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function:: \\[\\begin{align*}\n    % \\meanof{\\velocity} &= \\int_0^\\infty \\velocity f(\\velocity) d\\velocity = 2 \\left(\\frac{\\mass}{2\\BoltzmannConstant\\temperature}\\right)^2 \\cdot \\int_0^\\infty \\velocity^4 \\exp\\left(-\\frac{\\mass\\velocity^2}{2\\BoltzmannConstant\\temperature}\\right) d\\velocity = 2 a^2 \\int_0^\\infty \\velocity^4 \\exp\\left(- a\\velocity^2\\right) d\\velocity \\\\\n    \\langle v \\rangle &= \\int_0^\\infty vf(v) dv= 2 a^2 \\int_0^\\infty v^4 \\exp\\left(- av^2\\right) dv\\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\left[ \\frac{3\\sqrt{\\pi}\\mathop{\\mathrm{erf}}\\left(\\sqrt{a}v\\right)}{4\\sqrt{a}} - \\frac{v\\exp\\left(-av^2\\right) \\cdot \\left(2av^2 + 3\\right)}{2} \\right]_0^\\infty \\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\sqrt{\\frac{9\\pi}{16a}} = \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}}\\,\\cdot v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbfd_rms_speed}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\) \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left(\\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\left( \\int_0^\\infty 2a^2 v^5 \\exp\\left(-av^2\\right) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left( \\left[-\\frac{\\exp\\left(-av^2\\right) \\left(a^2v^4 + 2av^2 + 2 \\right)}{a}\\right]_0^\\infty \\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left(\\frac{2}{a}\\right)^{1/2} = \\sqrt{\\frac{4k_BT}{m}} = \\sqrt{\\frac{4}{3}}\\,\\cdot v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 2: Overview of normalized speeds \\(v\\) of the MBFD, according to Eq. , including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.693\\)\n\n\n\n\\(v_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(0.866\\)\n\\(\\approx\\sqrt{3/4}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(0.916\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(0.94\\)\n\\(\\approx\\sqrt{9\\pi/32}\\)\n\n\n\\(v_\\text{rms}\\)\n\\(0.594\\)\n\\(2.0\\)\n\\(1.155\\)\n\\(\\approx\\sqrt{4/3}\\)\n\\(1.064\\)\n\\(\\approx\\sqrt{32/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.16\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.395\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(1.54\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(1.822\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(2.149\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = 1/2 * v^3 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(3)\n    vm = sqrt(9*pi/8)\n    vr = sqrt(4)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", raw\"$\\approx\\sqrt{4/3}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{8/3\\pi}$\", \"\", \"\", raw\"$\\approx\\sqrt{32/9\\pi}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\", raw\"$\\approx\\sqrt{3/4}$\", \"\", raw\"$\\approx\\sqrt{9\\pi/32}$\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n\n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbfd_typical_speeds.md\", \"w\")\n    write(fid, maketable())\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\nTable 2 shows an overview of the speeds of the MBFD and their relation to the typical speeds. The \\(v_{XX}\\) denotes the speed at which the cdf evaluated to \\(F(v_{XX}) = \\int_0^{v_{XX}} f(v) dv= XX\\,\\mathrm{\\%}\\). The entries are sorted by their cdf with the typical speeds highlighted and placed at the correct position. Note that \\(v_{50}\\) denotes the median of the distribution, which is not equal to the expected value \\(\\langle v \\rangle\\).\n\n\nNumerical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBFD velocity, then any realization can be drawn from the respective pdf: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) = \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\n\\end{equation}\\] given in cartesian coordinates, see Eq. \\(\\eqref{eq:mbfd}\\) and Eq. \\(\\eqref{eq:mbfd_spherical}\\) for the function in spherical coordinates. Similar to the MBD, the numerical sampling of the random variable can be performed by mapping each random component to one implemented numerical distribution. As a reminder, the most basic numerical distributions are the uniform distribution with random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u\\sim f(r_u)=1\\) and a normal distribution with random variable \\(R_n\\in\\left(-\\infty, \\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n| 0, 1 \\right)\\) with zero mean and unit variance.\nIn cartesian coordinates, with \\(\\boldsymbol{\\mathbf{V}}= \\left(V_x, V_y, V_z\\right)\\), the first two directions are assumed to be perpendicular to the flux, while the z-direction is parallel to the flux. Thus, both the x- and the y-component, \\(v_x\\), and \\(v_y\\), can be numerically sampled like in the MBD, which is with scaled normal distributions, see Eqs. \\(\\eqref{eq:mbd_random_cartesian_component_2}\\), \\(\\eqref{eq:mbd_random_cartesian_component}\\). The flux direction is drawn from the \\(f_\\parallel\\) pdf, see Eq. \\(\\eqref{eq:mbfd_1d_parallel}\\), which can not be directly translated in either a uniform or a normal distribution. Therefore, the respective cdf, \\(F_\\parallel\\left(v_z\\right)\\), must be matched with the uniform cdf: \\[\\begin{align}\n    r_{v_z} &= \\int_0^{r_{v_z}} f(r_u) dr_u = \\int_0^{v_z} f_\\parallel(v) dv= F_\\parallel\\left(v_z\\right) = 1 - \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) \\\\\n    \\Rightarrow\\qquad v_z &= \\sqrt{-\\ln\\left(1-r_{v_z}\\right)\\frac{2k_BT}{m}}.\n    \\label{eq:mbfd_random_cartesian_component}\n\\end{align}\\]\n\n\n velocity: Eq. \\(\\eqref{eq:mbfd_random_cartesian_component}\\)\n\\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in spherical coordinates as \\(\\boldsymbol{\\mathbf{V}}=\\left(V_v, V_\\varphi, V_\\vartheta\\right)\\) with the differential \\(d^3\\boldsymbol{\\mathbf{v}}=v^2 \\, \\cos\\varphi\\, dvd\\varphi d\\vartheta\\). The additional terms are distributed to the respective random variable: \\[\\begin{alignat}{3}\n    V_v&\\sim f(v) && \\qquad\\text{with realization }v, \\\\    \n    V_\\varphi&\\sim f(\\varphi) = 2\\sin\\varphi\\cos\\varphi&& \\qquad\\text{with realization }\\varphi, \\text{ and } \\\\    \n    V_\\vartheta&\\sim f(\\vartheta) = \\frac{1}{2\\pi} && \\qquad\\text{with realization }\\vartheta.\n\\end{alignat}\\] As before, the cdf of the random variables can be set to equal the cdf of the unit uniform distribution: \\[\\begin{alignat}{3}\n    r_v&= \\int_0^{r_v} f(r_u) dr_u = \\int_0^vf(\\tilde v)d\\tilde v, \\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u) dr_u = \\int_0^\\varphi f(\\tilde\\varphi)d\\tilde\\varphi&&= 1 - \\cos^2\\varphi, \\label{eq:mbfd_random_elevation} \\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u) dr_u = \\int_{-\\pi}^\\vartheta f(\\tilde\\vartheta)d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}. \\label{eq:mbfd_random_azimuth}\n\\end{alignat}\\] While the latter two integrals are trivial, leading to a cosine-squared dependence of the elevation angle \\(\\varphi\\) and a uniform dependence on the azimuth angle \\(\\vartheta\\), the speed integral evaluates to \\[\\begin{equation}\n    r_v= 1 - \\exp \\left( -\\frac{mv^2}{2k_BT} \\right) \\cdot \\left( \\frac{mv^2}{2k_BT} + 1\\right).\n    \\label{eq:mbfd_random_speed}\n\\end{equation}\\] with no direct inversion of Eq. \\(\\eqref{eq:mbfd_random_speed}\\).\n\n\n speed: Eq. \\(\\eqref{eq:mbfd_random_speed}\\)   elevation: Eq. \\(\\eqref{eq:mbfd_random_elevation}\\)   azimuth: Eq. \\(\\eqref{eq:mbfd_random_azimuth}\\)"
  },
  {
    "objectID": "documentation/acronyms.html",
    "href": "documentation/acronyms.html",
    "title": "Acronyms",
    "section": "",
    "text": "Acronyms\n\n\n Table \\(\\LaTeX\\)\n\n\n\n\n\n\n\n\n\n\nALSEP\nApollo Lunar Surface Experiments Package\n\n\ncdf\nCME\ncumulative distribution function\nCoronal Mass Ejection\n\n\nDLRE\nDiviner Lunar Radiometer Experiment\n\n\nENA\nESA\nESD\nEnergetic Neutral Atoms\nEuropean Space Agency\nElectron Stimulated Desorption\n\n\nLACE\nLADEE\nLRO\nLROC\nLunar Atmospheric Composition Experiment\nLunar Atmosphere and Dust Environment Explorer\nLunar Reconnaissance Orbiter\nLunar Reconnaissance Orbiter Camera\n\n\nHEALPix\nHierarchical Equal Area iso-Latitude Pixelization\n\n\nIID\nIMF\nIndependent and Identically Distributed\nInterplanetary Magnetic Field\n\n\nMBD\nMBFD\nMESSENGER\nMMIV\nMaxwell-Boltzmann Distribution\nMaxwell-Boltzmann Flux Distribution\nMErcury Surface, Space ENvironment, GEochemistry, and Ranging\nMicrometeoroid Impact Vaporization\n\n\nNASA\nNMS\nNational Aeronautics and Space Administration\nNeutral Mass Spectrometer\n\n\npdf\nPDS\nPSD\nPSR\nprobability density function\nPlanetary Data System\nPhoton Stimulated Desorption\nPermanently Shadowed Region\n\n\nrms\nroot mean squared\n\n\nSSE\nSelenocentric Solar Ecliptic\n\n\nTPD\nTUM\nTemperature Program Desorption\nTechnical University of Munich\n\n\nUVS\nUltraviolet Spectrometer (Apollo 17)\n\n\nWAC\nWide Angle Camera (LROC)\n\n\n\n\n\n\\newacronym{ALSEP}{ALSEP}{Apollo Lunar Surface Experiments Package}\n\n\\newacronym{cdf}{cdf}{cumulative distribution function}\n\\newacronym{CME}{CME}{Coronal Mass Ejection}\n\n\\newacronym{DLRE}{DLRE}{Diviner Lunar Radiometer Experiment}\n\n\\newacronym{ENA}{ENA}{Energetic Neutral Atoms}\n\\newacronym{ESA}{ESA}{European Space Agency}\n\\newacronym{ESD}{ESD}{Electron Stimulated Desorption}\n\n\\newacronym{LACE}{LACE}{Lunar Atmospheric Composition Experiment}\n\\newacronym{LADEE}{LADEE}{Lunar Atmosphere and Dust Environment Explorer}\n\\newacronym{LRO}{LRO}{Lunar Reconnaissance Orbiter}\n\\newacronym{LROC}{LROC}{Lunar Reconnaissance Orbiter Camera}\n\n\\newacronym{HEALPix}{HEALPix}{Hierarchical Equal Area iso-Latitude Pixelization}\n\n\\newacronym{IID}{IID}{Independent and Identically Distributed}\n\\newacronym{IMF}{IMF}{Interplanetary Magnetic Field}\n\n\\newacronym{MBD}{MBD}{Maxwell-Boltzmann Distribution}\n\\newacronym{MBFD}{MBFD}{Maxwell-Boltzmann Flux Distribution}\n\\newacronym{MESSENGER}{MESSENGER}{MErcury Surface, Space ENvironment, GEochemistry, and Ranging}\n\\newacronym{MMIV}{MMIV}{Micrometeoroid Impact Vaporization}\n\n\\newacronym{NASA}{NASA}{National Aeronautis and Space Administration}\n\\newacronym{NMS}{NMS}{Neutral Mass Spectrometer}\n\n\\newacronym{pdf}{pdf}{probability density function}\n\\newacronym{PDS}{PDS}{Planetary Data System}\n\\newacronym{PSD}{PSD}{Photon Stimulated Desorption}\n\\newacronym{PSR}{PSR}{Permanently Shadowed Region}\n\n\\newacronym{rms}{rms}{root mean squared}\n\n\\newacronym{SSE}{SSE}{Selenocentric Solar Ecliptic}\n\n\\newacronym{TUM}{TUM}{Technical University of Munich}\n\n\\newacronym{UVS}{UVS}{Ultraviolet Spectrometer}\n\n\\newacronym{WAC}{WAC}{Wide Angle Camera}"
  },
  {
    "objectID": "documentation/surface_interaction/physical_chemistry.html",
    "href": "documentation/surface_interaction/physical_chemistry.html",
    "title": "6.1 Physical Chemistry",
    "section": "",
    "text": "From Schörghofer (2023):\n\nAdsorption is a surface phenomenon.\nθ denotes the number of adsorbed particles per area.\nFor water ice, the number of molecules in a monolayer can be calculated from the density and molecular mass as θm = 10^19 molecules m^-2, i.e., 10 H2O molecules per nm^2.\nThe areal concentration of Si atoms in silica (SiO2) is nearly as high when calculated in the same manner (nine Si atoms per nm^2 for α-quartz, but not all nine atoms have the same distance from the surface).\n\nPolanyi-Wigner equation: (Schörghofer, 2023) \\[\\begin{equation}\n    \\frac{d\\theta}{dt} = - \\nu\\theta\\exp\\left(-\\frac{E_a}{k_BT}\\right)\n\\end{equation}\\] which describes a first-order process.\nPre-exponential factor \\(\\nu\\) for monolayer adsorbates usually in the order of \\(10^{\\mathrm{-13}}\\,\\mathrm{s^{\\mathrm{-1}}}\\) for atoms (close to their respective oscillation frequency), can be much higher for molecules (Minissale et al., 2023).\n\n\n\n\n\n\nDefinition: Monolayer\n\n\n\nA monolayer of particles refers to a single layer of adsorbed molecules or atoms on a surface. This term is essential in understanding the capacity and behavior of a surface to adsorb volatile substances. Specifically, for water ice, the number of molecules in a monolayer can be calculated from the density and molecular mass as \\(\\theta_m = 10^{\\mathrm{19}}\\,\\mathrm{m^{\\mathrm{-2}}}\\), or, \\(10\\,\\mathrm{nm^{\\mathrm{-2}}}\\). (Schörghofer, 2023)\n\n\n\n\n\n\n\nReferences\n\nMinissale, M., Aikawa, Y., Bergin, E., Bertin, M., Brown, W. A., Cazaux, S., Charnley, S. B., Coutens, A., Cuppen, H. M., Guzman, V., Linnartz, H., McCoustra, M. R. S., Rimola, A., Schrauwen, J. G. M., Toubin, C., Ugliengo, P., Watanabe, N., Wakelam, V., & Dulieu, F. (2023). Thermal Desorption of Interstellar Ices: A Review on the Controlling Parameters and Their Implications from Snowlines to Chemical Complexity. ACS Earth and Space Chemistry, 6(3), 597–630. https://doi.org/10.1021/acsearthspacechem.1c00357\n\n\nSchörghofer, N. (2023). Adsorption Kinetics of Water and Argon on Lunar Grains. The Planetary Science Journal, 4(9), 164. https://doi.org/10.3847/psj/acf19b\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html",
    "href": "documentation/fundamentals/coordinate_systems.html",
    "title": "2.1 Coordinate Systems",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html#spacial-differentials",
    "href": "documentation/fundamentals/coordinate_systems.html#spacial-differentials",
    "title": "2.1 Coordinate Systems",
    "section": "Spacial Differentials",
    "text": "Spacial Differentials\nThis work regularly relies on vector calculus, including substantial use of differentials and derivatives. The former uses two kinds of notations, depending on the use case of the differential. First, mathematical differentials of vectors are the vectorized form of the differentials of the vector components. In the following, the differentials will be set up for stationary conditions with constant base vectors, i.e.\n\\[\\begin{align}\n    \\frac{\\partial}{\\partial t} &= 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial r} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\varphi} = 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial x} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial z} = 0.\n\\end{align}\\]\nFor example, the differential of a stationary cartesian coordinate vector and cartesian elements is\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{x}}= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial z}dz= dx\\hat{\\boldsymbol{\\mathbf{e}}}_x+ dy\\hat{\\boldsymbol{\\mathbf{e}}}_y+ dz\\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix} dx\\\\ dy\\\\ dz\\end{bmatrix},\n\\end{equation}\\]\nand for spherical coordinates and elements\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\varphi}d\\varphi= dr\\hat{\\boldsymbol{\\mathbf{e}}}_r+ d\\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ d\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}.\n\\end{equation}\\]\nThe above total differentials are relatively simple to set up since their partial differentials cancel out to only contain one variable each. However, the differentials for the cartesian vector in spherical elements and the spherical vector in cartesian elements are more complicated, with the former differential given by\n\\[\\begin{align}\n    d\\boldsymbol{\\mathbf{x}}&= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\varphi}d\\varphi\\\\\n    &= \\left(\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) dr\\nonumber \\\\\n    &+ \\left(-r\\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ r\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y\\right) d\\vartheta\\nonumber \\\\\n    &+ \\left(-r\\cos\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x- r\\sin\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ r\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) d\\varphi\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi&  -r\\sin\\vartheta\\cos\\varphi& -r\\cos\\vartheta\\sin\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi& r\\cos\\vartheta\\cos\\varphi& - r\\sin\\vartheta\\sin\\varphi\\\\\n        \\sin\\varphi& 0 & r\\cos\\varphi\n    \\end{bmatrix} \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}  \\label{eq:total_cartesian_spherical_differential_matrix}\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi dr-r\\sin\\vartheta\\cos\\varphi d\\vartheta-r\\cos\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi dr+ r\\cos\\vartheta\\cos\\varphi d\\vartheta- r\\sin\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\varphi dr+ r\\cos\\varphi d\\varphi\n    \\end{bmatrix}. \\label{eq:total_cartesian_spherical_differential}\n\\end{align}\\]\nThe resulting vector in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential}\\) contains the scalar differentials of the spherical elements in each of its entries, which can also be pulled out of the vector and written as a linear combination using a matrix notation, shown in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\). While the differential of a spherical vector in cartesian elements can be calculated in the same way, which is \\(d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial z}dz\\), its trigonometric functions and subsequent differentiations make it less common and inefficient to use, which is why it is not shown here for brevity.\nThese vectorized total differentials are regularly used in vector calculus. A prime example is calculating the gradient \\(\\nabla\\) of a scalar function \\(f\\), which is given by \\[\\begin{equation}\n    \\frac{df}{d\\boldsymbol{\\mathbf{x}}} = \\nabla f = \\begin{bmatrix}\n        \\frac{\\partial f}{\\partial x} \\\\\n        \\frac{\\partial f}{\\partial y} \\\\\n        \\frac{\\partial f}{\\partial z}\n    \\end{bmatrix},\n\\end{equation}\\] as an example in a cartesian coordinate system and with cartesian elements. Many problems feature the second-order derivatives of a scalar function, which is called the Laplacian \\(\\nabla^2\\) and is given by \\[\\begin{equation}\n    \\nabla \\cdot \\nabla f = \\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}.\n\\end{equation}\\]\nBoth the gradient and the laplacian can also be expressed in spherical coordinates. The former makes use of the chain rule of differentiation, which evaluates to the inverse matrix of the coordinate projection of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\): \\[\\begin{align}\n    \\begin{bmatrix}\n        \\frac{\\partial}{\\partial x} \\\\\n        \\frac{\\partial}{\\partial y} \\\\\n        \\frac{\\partial}{\\partial z}\n    \\end{bmatrix} &= \\begin{bmatrix}\n        \\frac{\\partial r}{\\partial x} & \\frac{\\partial\\vartheta}{\\partial x} & \\frac{\\partial\\varphi}{\\partial x} \\\\\n        \\frac{\\partial r}{\\partial y} & \\frac{\\partial\\vartheta}{\\partial y} & \\frac{\\partial\\varphi}{\\partial y} \\\\\n        \\frac{\\partial r}{\\partial z} & \\frac{\\partial\\vartheta}{\\partial z} & \\frac{\\partial\\varphi}{\\partial z}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix} \\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi& -\\frac{\\sin\\vartheta}{r\\cos\\varphi} & -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\vartheta\\cos\\varphi& \\frac{\\cos\\vartheta}{r\\cos\\varphi} & -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\varphi& 0 & \\frac{\\cos\\varphi}{r}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial x} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_x}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial y} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_y}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial z} &= \\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}. \\label{eq:spherical_gradient_z}\n\\end{align}\\] The latter can be derived by applying the chain rule twice, which is a tedious but straightforward calculation, leading to: \\[\\begin{align}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right). \\label{eq:laplace_spherical}\n\\end{align}\\]\n\n\n\n\n\n\nDerivation of spherical Laplace operator.\n\n\n\nThe laplacian is the linear summation of the second-order cartesian partial derivative \\(\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\). The spherical laplacian can be derived by applying the chain rule of partial derivatives, shown in the gradient derivation in Eqs. \\(\\eqref{eq:spherical_gradient_x}\\), \\(\\eqref{eq:spherical_gradient_y}\\), \\(\\eqref{eq:spherical_gradient_z}\\) twice: \\[\\begin{align*}\n    \\frac{\\partial^2}{\\partial x^2} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial x} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial x} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial x} \\\\\n    &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\right) \\\\\n    &- \\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial y^2} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial y} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial y} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial y} \\\\\n    &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &+ \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial z^2} &= \\sin\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial z} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial z} \\\\\n    &= \\sin\\varphi\\frac{\\partial}{\\partial r} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right).\n\\end{align*}\\] Evaluating all partial derivatives and summing up all terms leads to a miraculous cancellation of terms, finally arriving at the following expression of Eq. \\(\\eqref{eq:laplace_spherical}\\) for the Laplacian in spherical coordinates: \\[\\begin{align*}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right).\n\\end{align*}\\]\n\n\nAnother example of the use of differentials is in integration, where it is used to represent an infinitesimal change in the variable. Shorthand versions of multi-dimensional integrals are often written using vector variables, such as \\[\\begin{equation}\n    \\int_X \\int_Y \\int_Z f dzdydx= \\int_Vf d^3\\boldsymbol{\\mathbf{x}},\n\\end{equation}\\] where \\(V\\) is the volume of the integration domain, with the infinitesimal volume element \\(d^3\\boldsymbol{\\mathbf{x}}\\in V= \\left\\{dx\\, dy\\, dz\\; | \\; dx\\in X, dy\\in Y, dz\\in Z \\right\\}\\). The superscript \\(\\bullet^3\\) in the differentials indicates that the differential is a vector but a scalar representation of the element’s size created by the vector elements. As before, the differential \\(d^3\\boldsymbol{\\mathbf{x}}\\) can also be expressed in spherical elements by using the Jacobian determinant, which is equal to the matrix of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\), of the transformation: \\[\\begin{equation}\n    d^3\\boldsymbol{\\mathbf{x}}= \\left|\\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\boldsymbol{\\mathbf{r}}}\\right| d^3\\boldsymbol{\\mathbf{r}}= r^2\\cos\\varphi drd\\vartheta d\\varphi.\n\\end{equation}\\] Figure 1 illustrates the spherical differential element \\(d^3\\boldsymbol{\\mathbf{r}}\\) in a three-dimensional cartesian coordinate system. The azimuth angle \\(\\vartheta\\) rotates inside of the \\(x\\)–\\(y\\) plane, while the elevation angle \\(\\varphi\\) rotates the vector out of that plane in \\(z\\) direction. While the azimuth arc decreases with the sine of the elevation angle, the small angle approximation can be used to approximate the differential element as a cuboid with the volume \\(d^3\\boldsymbol{\\mathbf{r}}\\approx r^2 \\sin\\varphi\\, drd\\vartheta d\\varphi\\).\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Three-dimensional sketch of a spherical differential element in a cartesian coordinate system.\n\n\n\n\n% based on: https://tikz.net/spherical_volume/\n\n%Axis Angles\n\\tdplotsetmaincoords{70}{110}\n\n%Macros\n\\pgfmathsetmacro{\\rvec}{6}\n\\pgfmathsetmacro{\\elevationvec}{40}\n\\pgfmathsetmacro{\\azimuthvec}{45}\n\n\\pgfmathsetmacro{\\dazimuthvec}{20}\n\\pgfmathsetmacro{\\delevationvec}{20}\n\\pgfmathsetmacro{\\drvec}{1.5}\n\n%Layers\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\pgfsetlayers{background, main, foreground}\n\n\\begin{tikzpicture}[tdplot_main_coords]\n    \n    %Coordinates\n    \\coordinate (O) at (0,0,0);\n    %\n    \\tdplotsetcoord{A}{\\rvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{B}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{C}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{D}{\\rvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    %\n    \\tdplotsetcoord{E}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F'}{\\rvec + \\drvec}{90}{\\azimuthvec}\n    \\tdplotsetcoord{G}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{G'}{\\rvec + \\drvec}{90}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{H}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    \n    %Axis\n    \\begin{pgfonlayer}{background}\n        \\draw[thick,-latex] (0,0,0) -- (7,0,0) node[pos=1.1]{$\\cartesianCoordinateX$};\n        \\draw[thick,-latex] (0,0,0) -- (0,7,0) node[pos=1.05]{$\\cartesianCoordinateY$};\n        \\draw[thick,-latex] (0,0,0) -- (0,0,6) node[pos=1.05]{$\\cartesianCoordinateZ$};\n    \\end{pgfonlayer}\n    \n    %Help Lines\n    \\begin{pgfonlayer}{background}\n        %Up\n        \\draw[thick, black] (O) -- (A) node[pos=0.6, above left, black] {$\\sphericalCoordinateRadius$};\n        \\draw (O) -- (B);\n        \\draw (O) -- (C);\n        \\draw[dashed] (O) -- (D);\n        %Down\n        \\draw (O) -- (F');\n        \\draw (O) -- (G');\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        %%Help Curves\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotsetthetaplanecoords{\\azimuthvec+\\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, dashed]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        %\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n        \\node[rotate=13] at (3,4.45,0) {$\\sphericalCoordinateRadius\\sin\\sphericalCoordinateElevation d\\sphericalCoordinateAzimuth$};\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec+\\drvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n    \\end{pgfonlayer}\n    \n    \n    %Angles\n    \\begin{pgfonlayer}{foreground}\n        %Phi, dPhi\n        \\tdplotdrawarc[-stealth]{(O)}{0.9}{0}{\\azimuthvec}{anchor=north}{$\\sphericalCoordinateAzimuth$}\n        \\tdplotdrawarc[-stealth]{(O)}{1.5}{\\azimuthvec}{\\azimuthvec + \\dazimuthvec}{}{}\n        \\node at (1.4,1.9,0) {$ d\\sphericalCoordinateAzimuth$};\n        \n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \n        %Theta, dTheta\n        \\tdplotdrawarc[tdplot_rotated_coords, -stealth]{(0,0,0)}{1.2}{90}{\\elevationvec + \\delevationvec}{}{}\n        %\\node at (0,0.3,1.3) {$\\sphericalCoordinateElevation$};\n        \\node at (1,1.25,0.55) {$\\sphericalCoordinateElevation$};\n        \\tdplotdrawarc[tdplot_rotated_coords, stealth-]{(0,0,0)}{2.}{\\elevationvec}{\\elevationvec + \\delevationvec}{anchor=south west}{$ d\\sphericalCoordinateElevation$}\n    \\end{pgfonlayer}\n    \n    %Differential Volume\n    \n    %%Lines\n    \\begin{pgfonlayer}{foreground}\n        \\draw[thick] (A) -- (E) node[midway, above left]{$ d\\sphericalCoordinateRadius$};\n        \\draw[thick] (B) -- (F);\n        \\draw[thick] (C) -- (G);\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        \\draw[dashed, thick] (D) -- (H);\n    \\end{pgfonlayer}\n    \n    \n    %%Curved\n    \\begin{pgfonlayer}{background}\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{below left}{$\\sphericalCoordinateRadius d\\sphericalCoordinateElevation$}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-30.3813}{-8.6492}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{17.2983}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{17.2983}{}{}\n    \\end{pgfonlayer}\n    \n    %Fill Color\n    \\begin{pgfonlayer}{main}\n        %Front\n        \\fill[black, opacity=0.15] (E) to (A)  to[bend left=4] (B) to (F) to[bend right=4] cycle;\n        \\fill[black, opacity=0.6] (E) to[bend left=4] (F)  to[bend left=2] (G) to[bend right=6.5] (H) to[bend right=4] cycle;\n        \\fill[black, opacity=0.4] (F) to[bend left=2] (G) to[bend left=1.5] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        %Back\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to[bend left=6] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to (H) to[bend right=2.5] (E) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (D) to (H) to[bend left=6] (G) to[bend right=2] (C) to[bend right=6] cycle;\n    \\end{pgfonlayer}\n        \n\\end{tikzpicture}"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html#temporal-differentials",
    "href": "documentation/fundamentals/coordinate_systems.html#temporal-differentials",
    "title": "2.1 Coordinate Systems",
    "section": "Temporal Differentials",
    "text": "Temporal Differentials"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html#global-reference-frames",
    "href": "documentation/fundamentals/coordinate_systems.html#global-reference-frames",
    "title": "2.1 Coordinate Systems",
    "section": "Global Reference Frames",
    "text": "Global Reference Frames\nGlobal reference frames are used for calculations on a planetary scale, thus providing a coordinate system based on a planetary body, like the Moon.\nMoon -&gt; selenocentric\nEarth -&gt; geocentric\nSun -&gt; heliocentric\nIf not specified otherwise, all global coordinate systems are subsolar coordinate systems, meaning that the orientation of their base vectors is based on the Sun’s position. The category can be further divided into two subcategories based on their respective type of coordinates: Cartesian and spherical.\n\nGlobal Cartesian Coordinate Systems\nPositional vectors of the global cartesian coordinate system are defined as \\[\\begin{equation}\n    {}_{\\small\\text{G}}\\boldsymbol{\\mathbf{x}}= \\begin{bmatrix}\n        {}_{\\small\\text{G}}x\\\\\n        {}_{\\small\\text{G}}y\\\\\n        {}_{\\small\\text{G}}z\n    \\end{bmatrix} \\qquad\\text{with } {}_{\\small\\text{G}}x\\in\\mathbb{R},\\;{}_{\\small\\text{G}}y\\in\\mathbb{R},\\;{}_{\\small\\text{G}}z\\in\\mathbb{R},\n\\end{equation}\\] while velocities are defined as their first temporal derivative, and since all global base vectors \\(\\hat{\\boldsymbol{\\mathbf{e}}}_i\\) are time-invariant, it resolves to \\[\\begin{align}\n    {}_{\\small\\text{G}}\\dot{\\boldsymbol{\\mathbf{x}}} = \\frac{d}{dt} \\left( {}_{\\small\\text{G}}\\boldsymbol{\\mathbf{x}}\\right) &= \\frac{d}{dt} \\left( {}_{\\small\\text{G}}x\\hat{\\boldsymbol{\\mathbf{e}}}_x+ {}_{\\small\\text{G}}y\\hat{\\boldsymbol{\\mathbf{e}}}_y+ {}_{\\small\\text{G}}z\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) = {}_{\\small\\text{G}}\\dot x\\hat{\\boldsymbol{\\mathbf{e}}}_x+ {}_{\\small\\text{G}}\\dot y\\hat{\\boldsymbol{\\mathbf{e}}}_y+ {}_{\\small\\text{G}}\\dot z\\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix}\n        {}_{\\small\\text{G}}\\dot x\\\\\n        {}_{\\small\\text{G}}\\dot y\\\\\n        {}_{\\small\\text{G}}\\dot z\n    \\end{bmatrix}\n    \\\\ & \\text{with } {}_{\\small\\text{G}}\\dot x\\in\\mathbb{R},\\;{}_{\\small\\text{G}}\\dot y\\in\\mathbb{R},\\;{}_{\\small\\text{G}}\\dot z\\in\\mathbb{R}. \\label{eq:global_cartesian_velocity} \\nonumber\n\\end{align}\\]\nThe coordinate system is fixed in place, with its origin at the center of the planetary body, and its base vectors pointing in the direction of the planetary axes, shown in Figure 2. The base vectors are defined as \\(\\hat{\\boldsymbol{\\mathbf{e}}}_x\\) pointing towards the Sun, \\(\\hat{\\boldsymbol{\\mathbf{e}}}_y\\) pointing towards positive longitude (east), and \\(\\hat{\\boldsymbol{\\mathbf{e}}}_z\\) pointing towards positive latitude (north). The base vectors are orthogonal to each other. Note that in the figure below, the global subscript was omitted for the simplicity of the visualization.\n\n Figure LaTeX\n\n\n\n\n\n\nFigure 2: Minimal and simplified sketch of the global, cartesian, subsolar, selenocentric coordinate system. The dashed lines indicate the Moon’s orbit around the Sun. All sizes and distances are not to scale.\n\n\n\n\n\n\n\n\n\n\nGlobal Spherical Coordinate Systems"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html#local-reference-frames",
    "href": "documentation/fundamentals/coordinate_systems.html#local-reference-frames",
    "title": "2.1 Coordinate Systems",
    "section": "Local Reference Frames",
    "text": "Local Reference Frames\nLocal reference frames are used for calculations on a smaller scale. One example is the calculation of thermal desorption velocities (see Thermal Sorption), which only depends on the local surface temperature.\n\nLocal Cartesian Coordinate Systems\n\n\nLocal Spherical Coordinate Systems"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html#transformations",
    "href": "documentation/fundamentals/coordinate_systems.html#transformations",
    "title": "2.1 Coordinate Systems",
    "section": "Transformations",
    "text": "Transformations\nOften it is useful to describe one problem in a different reference frame than another, requiring a transformation between the two.\n\nTo Global Cartesian Positions\nLet \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\) be a global spherical position vector given in spherical elements. The transformation to a global cartesian position vector \\(\\boldsymbol{\\mathbf{x}}= \\left[x, y, z\\right]^T\\) is identical to the transformation presented in Eq. \\(\\eqref{eq:cartesian_coordinate_spherical_elements}\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}= \\begin{bmatrix}\n        r\\cos\\vartheta\\cos\\varphi\\\\\n        r\\sin\\vartheta\\cos\\varphi\\\\\n        r\\sin\\varphi\n    \\end{bmatrix} = \\begin{bmatrix}\n        x\\\\\n        y\\\\\n        z\n    \\end{bmatrix}\n\\end{equation}\\] with \\(r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right]\\).\n\n\nTo Global Spherical Positions\nLet \\(\\boldsymbol{\\mathbf{x}}= \\left[x, y, z\\right]^T\\) be a global cartesian position vector given in cartesian elements. The transformation to a global spherical position vector \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\) is identical to the transformation presented in Eq. \\(\\eqref{eq:spherical_coordinate_cartesian_elements}\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}= \\begin{bmatrix}\n        \\sqrt{x^2 + y^2 + z^2} \\\\\n        \\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\\\\n        \\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\n    \\end{bmatrix}\n\\end{equation}\\] with \\(x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\\)\n\n\nTo Global Cartesian Velocities\nLet \\({}_{\\small\\text{L}}\\boldsymbol{\\mathbf{v}}= \\left[v_x, v_y, v_z\\right]^T\\) be a local cartesian velocity vector given in cartesian elements, and \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\) be a global spherical position vector given in spherical elements. The transformation to a global cartesian velocity vector \\(\\dot{\\boldsymbol{\\mathbf{x}}} = \\left[\\dot x, \\dot y, \\dot z\\right]^T\\) is given by \\[\\begin{equation}\n    {}_{\\small\\text{G}}\\dot{\\boldsymbol{\\mathbf{x}}} = \\begin{bmatrix}\n        -v_x\\sin\\vartheta- v_y\\cos\\vartheta\\sin\\varphi+ v_z\\cos\\vartheta\\cos\\varphi\\\\\n        v_x\\cos\\vartheta- v_y\\sin\\vartheta\\sin\\varphi+ v_z\\sin\\vartheta\\cos\\varphi\\\\\n        v_y\\cos\\varphi+ v_z\\sin\\varphi\n    \\end{bmatrix}\n\\end{equation}\\] with \\(v_x\\in\\mathbb{R},\\;v_y\\in\\mathbb{R},\\;v_z\\in\\mathbb{R}\\) and \\(r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right]\\).\n\n\nTo Global Spherical Velocities\n\n\nTo Local Cartesian Positions\n\n\nTo Local Cartesian Velocities"
  },
  {
    "objectID": "documentation/fundamentals/moon.html",
    "href": "documentation/fundamentals/moon.html",
    "title": "2.6 The Moon",
    "section": "",
    "text": "Some intro text"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#measurements-and-modeling",
    "href": "documentation/fundamentals/moon.html#measurements-and-modeling",
    "title": "2.6 The Moon",
    "section": "Measurements and Modeling",
    "text": "Measurements and Modeling\nAboard the LRO the DLRE gathered infrared data of the lunar surface to create temperature maps of the Moon.\n\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Based on a Diviner measurement snapshot.\n\n\n\n\n\n\n\n(b) Based on the average Diviner measurements.\n\n\n\n\n\n\n\n\n\n(c) Based on the analytic function of Butler (1997).\n\n\n\n\n\n\n\n(d) Based on the analytic function of Hurley et al. (2015)\n\n\n\n\nFigure 2: Global, stationary lunar surface temperature maps. Coordinates given with respect to the subsolar point at \\((\\Theta_{ss}, \\Phi_{ss}) = (0,0)\\), presented in local time and subsolar latitude.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = GeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction lunarSurfaceTemperaturesDivinerAverage(name=\"lunarSurfaceTemperatureDivinerAverage\")\n    fig, ga, theta, phi = _default_()\n    \n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner_avg(theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\")\n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesDiviner(name=\"lunarSurfaceTemperatureDiviner\")\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesBUTLER(name=\"lunarSurfaceTemperatureBUTLER\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_BUTLER1997(theta, phi)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesHURLEY(name=\"lunarSurfaceTemperatureHURLEY\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_HURLEY2015(theta, phi)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\nFor the exact design, a custom theme was loaded in the preamble of the document.\n\n\n\n diviner.png \n diviner_average.png \n butler.png \n hurley.png \n\n\n\n\n\n\n\n\n\n\n\n\nAnimation of Diviner Temperature Snapshots\n\n\n\n\n\n\n Animations Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Selenographic coordinate system.\n\n\n\n\n\n\n\n(b) Subsolar coordinate system.\n\n\n\n\nFigure 3: Animations of Diviner lunar surface temperature measurements in a Moon-centered (selenographic) and a “fixed”, solar-based (subsolar) coordinate system. Both animations contain the identical 18 individual snapshots. Note that (a) does not have a local time x-axis, but a selenographic one, which has been omitted for clarity.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes, Printf\n\ncmap = ColorSchemes.lipari\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = MyLTGeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction anim_raw_diviner(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n    ga.xticklabelcolor = :white\n    ga.xlabelcolor = :white\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        T = lunar_surface_temperatures_diviner((step-1)*2*pi/steps, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T\n        \n        save(joinpath(@__DIR__, \"anim_raw_diviner\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\n\nfunction anim_raw_diviner_fixed(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        Nstep = floor(Int64, (step-1)*N/steps)\n        T = lunar_surface_temperatures_diviner(Nstep/N * 2pi, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T[vcat(Nstep+1:N, 1:Nstep), :]\n        \n        save(joinpath(@__DIR__, \"anim_raw_diviner_fixed\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\nThe code above creates individual .png files which are subsequently converted into animated .gifs.\n\n\n\n anim_raw_diviner.gif \n anim_raw_diviner_fixed.gif \n\n\n\n\n\n\n\n\nButler (1997) proposed an analytical surface temperature distribution based on the solar zenith angle \\(\\psi_s\\) with regard to the local surface normal, assuming a perfectly spherical Moon, see Figure 2. Given the subsolar position \\(\\left(\\Theta_{ss}, \\Phi_{ss}\\right)\\), longitude and latitude respectively, the cosine of the zenith angle can be calculated as \\(\\cos\\psi_s = \\cos\\Theta_{ss} \\cdot \\cos\\Phi_{ss}\\). All measurements of the lunar surface temperatures on the dayside suggest a \\(\\cos^{1/4}\\) shape with regard to the solar zenith angle (Hurley et al., 2015; Vasavada et al., 2012), though such models break down on the nightside. By introducing a cutoff at the terminators alongside a defined nightside temperature and shifting the distribution up, Butler (1997) arrived at \\[\\begin{equation}\n    T(\\psi_s) = \\begin{cases}\n        250\\,\\mathrm{K} \\cdot \\cos^{1/4} (\\psi_s) + 100\\,\\mathrm{K}, \\qquad & \\text{ if } \\psi_s \\leq 90\\,\\mathrm{\\degree}, \\\\\n        100\\,\\mathrm{K}, & \\text{ if } \\psi_s &gt; 90\\,\\mathrm{\\degree}.\n    \\end{cases} \\label{eq:lunar_surface_temperatures_BUTLER}\n\\end{equation}\\]\n\n\n lunar_surface_temperatures_BUTLER1997\nHurley et al. (2015) proposed another model to further improve the analytical description of the lunar surface temperatures, which included a combination of a cosine-law dependence on the dayside and a 6-term polynomial fitted cooling function for the nightside: \\[\\begin{equation}\n    T(\\Theta_{ss}, \\Phi_{ss}) = \\begin{cases}\n        262\\,\\mathrm{K} \\cdot \\cos^{1/2} \\left( \\psi_s \\right) + 130\\,\\mathrm{K}, \\qquad & \\text{ if } \\left|\\Theta_{ss}\\right| &lt; 90\\,\\mathrm{\\degree}, \\\\\n        \\left( \\sum_{i=0}^5 a_i \\Theta_{ss}^i \\right) + 35\\,\\mathrm{K} \\left( \\sin \\overline{\\Phi_{ss}} - 1\\right), \\qquad & \\text{ else.}\n    \\end{cases} \\label{eq:lunar_surface_temperatures_HURLEY}\n\\end{equation}\\] with the longitude \\(\\Theta_{ss}\\) and the subsolar co-latitude \\(\\overline{\\Phi_{ss}} = \\pi/2 - \\Phi_{ss}\\). The coefficients of the polynomial fit are \\(a = \\left[444.738,\\; -448.937,\\; 239.668,\\; -63.8844,\\; 8.34064,\\; -0.423502 \\right]\\) in kelvin. Note that the longitude has to be used in radians and must be positively defined on the range of \\(\\Theta_{ss} \\in \\left(\\pi/2, 3\\pi/2\\right)\\) for the nightside.\n\n\n lunar_surface_temperatures_HURLEY2015\n\n\n Figure Julia - Mean Julia - RMS Downloads\n\n\n\n\n\n\n\n\n\n(a) Statistical temperature difference mean.\n\n\n\n\n\n\n\n(b) Root mean squared error of temperature differences.\n\n\n\n\nFigure 4: Statistical comparison of the lunar surface temperatures models with Diviner measurements. Temperature difference based on analytical functions by Butler (1997), Eq. \\(\\eqref{eq:lunar_surface_temperatures_BUTLER}\\), and Hurley et al. (2015), Eq. \\(\\eqref{eq:lunar_surface_temperatures_HURLEY}\\), compared to the averaged Diviner measurements and evaluated on grid points, equally distributed and weighted with their respective surface area. Comparisons are represented by their statistical mean (a) and their root mean squared error (b), applied globally (circles), on the dayside (squares), and on the nightside (diamonds).\n\n\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_rms(N=18, name=\"temperature_comparison_rms\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, sqrt(mean(dTBlat.^2)))  \n        push!(eBd, sqrt(mean(dTBlatd.^2)))\n        push!(eBn, sqrt(mean(dTBlatn.^2)))\n        push!(eH, sqrt(mean(dTHlat.^2)))  \n        push!(eHd, sqrt(mean(dTHlatd.^2)))\n        push!(eHn, sqrt(mean(dTHlatn.^2)))\n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"RMS Temperature Differences [K]\",\n        yticks=0:20:70,)\n    ylims!(0, 70)\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n        [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false,\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_mean(N=18, name=\"temperature_comparison_mean\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, mean(dTBlat))   \n        push!(eBd, mean(dTBlatd)) \n        push!(eBn, mean(dTBlatn)) \n        push!(eH, mean(dTHlat))   \n        push!(eHd, mean(dTHlatd)) \n        push!(eHn, mean(dTHlatn)) \n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"Mean Temperature Differences [K]\")\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n    [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\n\n mean.pdf   mean.svg   mean.png \n rms.pdf   rms.svg   rms.png \n\n\n\n\n\nThe two presented analytical models of the lunar surface temperatures have been compared with the averaged DLRE measurements. Figure 4 shows this statistical analysis of the temperatures difference of the Butler (1997) and Hurley et al. (2015) calculated as \\(\\Delta T_i = T_i - T_\\text{Diviner}\\) for each analytical model \\(i\\), evaluated on \\(270e3\\) surface points, globally distributed using the HEALPix method.\nThe left side shows the statistical mean of said temperature differences as a function of subsolar latitude for both models, both globally as well as exclusively on the dayside and nightside of the Moon. Up to \\(\\Phi_{ss}=60\\,\\mathrm{\\degree}\\), the Hurley et al. (2015) model has global means very close to zero, with slight deviations for the exclusive day- and night side. Closer to the poles, the model tends towards positive temperature differences, peaking at around \\(35\\,\\mathrm{K}\\) above the Diviner model on the sunlit side. Using the model by Butler (1997) this effect is even more pronounced with the means starting below zero at the equator and continuously increasing with higher latitudes. Final values close to the poles reach temperature differences of more than \\(60\\,\\mathrm{K}\\) on the dayside.\nTo further investigate the two models, the rms value of the temperature differences \\[\\begin{equation}\n    \\Delta T_{\\text{rms}, i} = \\sqrt{\\frac{1}{N_j} \\cdot \\sum_j^{N_j} \\left(\\Delta T_{i,j}\\right)^2},\n\\end{equation}\\] for \\(N_j\\) applicable positions \\(j\\) is shown on the right side of Figure 4. In comparison with the previously shown statistical mean, the rms shows the spread of the temperatures around the mean. For all cases, globally, dayside, and nightside, the Hurley et al. (2015) model has lower rms values, which are less than \\(10\\,\\mathrm{K}\\) for latitude uo to \\(60\\,\\mathrm{\\degree}\\). Closer to the poles and similar to the mean value, the dayside temperatures tend to deviate the most, peaking at \\(43\\,\\mathrm{K}\\) at \\(80\\,\\mathrm{\\degree}\\). Generally, a steadily increasing behaviour with higher latitudes can be observed. For the Butler (1997) model, the rms values start considerably higher with the worst deviations on the dayside of the Moon. For roughly \\(50\\,\\mathrm{\\degree}\\) from the equator, the values decrease to the lowest value of \\(17\\,\\mathrm{K}\\) before sharply increasing polewards of it."
  },
  {
    "objectID": "documentation/fundamentals/moon.html#permanently-shadowed-regions",
    "href": "documentation/fundamentals/moon.html#permanently-shadowed-regions",
    "title": "2.6 The Moon",
    "section": "Permanently Shadowed Regions",
    "text": "Permanently Shadowed Regions\nSchörghofer et al. (2021) investigated the sizes of PSRs and found that their total area in the northern polar region (poleward of \\(80\\,\\mathrm{\\degree}\\)) is around \\(1.3\\times 10^{\\mathrm{4}}\\,\\mathrm{km^{\\mathrm{2}}}\\), while the southern polar region has a total area of \\(1.6\\times 10^{\\mathrm{4}}\\,\\mathrm{km^{\\mathrm{2}}}\\)."
  },
  {
    "objectID": "documentation/fundamentals/moon.html#interplanetary-magnetic-field",
    "href": "documentation/fundamentals/moon.html#interplanetary-magnetic-field",
    "title": "2.6 The Moon",
    "section": "Interplanetary Magnetic Field",
    "text": "Interplanetary Magnetic Field"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#electric-surface-potential",
    "href": "documentation/fundamentals/moon.html#electric-surface-potential",
    "title": "2.6 The Moon",
    "section": "Electric Surface Potential",
    "text": "Electric Surface Potential\nIn space, objects typically charge to a potential where the total current is zero, mainly from ambient electrons, ions, and photoelectron emission. In the case of the Moon, this implies that the lunar surface typically attains a negative potential in shadow, roughly equivalent to the electron temperature, and a positive potential in sunlight, approximately matching the photoelectron temperature (a few \\(\\,\\mathrm{eV}\\)). (Halekas et al., 2005)\nAccording to Futaana et al. (2012), the Moon’s absence of a considerable atmosphere and global magnetic field fosters direct interaction between its surface and the solar wind, resulting in the accumulation of electrostatic charges. The lunar surface potential varies based on factors like location, time of day, and prevailing solar wind conditions. Due to the majority of incoming plasma impacting the sunlit side of the Moon and getting adsorbed or neutralized, a plasma void wake structure forms downstream on the lunar night side. Through photoelectrons, the lunar dayside typically maintains a positive electrostatic potential of around +20 V, while the absence of photons on the opposite side leads to pronounced negative charges, reaching as low as -200 V. (Halekas et al., 2005; Wurz et al., 2022)"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#magnetic-anomalies",
    "href": "documentation/fundamentals/moon.html#magnetic-anomalies",
    "title": "2.6 The Moon",
    "section": "Magnetic Anomalies",
    "text": "Magnetic Anomalies"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#missions",
    "href": "documentation/fundamentals/moon.html#missions",
    "title": "2.6 The Moon",
    "section": "Missions",
    "text": "Missions\n\nDensity Projections\nDue to the scarcity of ground-based data, satellite measurements at varying altitudes are often used in the investigation of planetary exospheres. In order to compare measurements at different altitudes, the data must be projected into a common altitude, which usually is the exobase altitude, which is the surface of the planetary body given surface-bounded exospheres.\nChamberlain (1963) derived a model for the exospheric particle number density \\(n\\left(r\\right)\\) as a function of the radial distance from the center of the planetary body, based on the assumption of a hydrostatic equilibrium and a Maxwellian velocity distribution, see section Velocity Distributions: \\[\\begin{equation}\n    % \\numberDensity(\\radius) = \\numberDensity(\\radius+\\height) \\cdot \\partitionFunction \\cdot \\exp \\left(\\relativeEnergy\\left(\\radius\\right) - \\relativeEnergy\\left(\\radius+\\height\\right) \\right)\n    n= \\tilde n\\cdot \\zeta\\cdot \\exp \\left(\\epsilon- \\tilde\\epsilon\\right)\n    \\label{eq:chamberlain_projection}\n\\end{equation}\\] with the known number density \\(\\tilde n= n(\\tilde r)\\) at some known radial distance \\(\\tilde r= r+ h\\) with \\(r, h\\in\\mathbb{R}^+\\), relative potential energies \\(\\epsilon\\), and a partition function \\(\\zeta\\). If the radial distance is equal to the radius of the planetary body, the number density is equal to the surface number density \\(n_0\\). Equation \\(\\eqref{eq:chamberlain_projection}\\) is the general form of the isothermal barometric law (Chamberlain, 1963).\n projection_CHAMBERLAIN1963\nThe relative energy of the projection function is given as absolute potential energy in units of thermal energy \\(k_BT\\): \\[\\begin{equation}\n    \\epsilon\\left(r\\right) = \\left| - \\frac{m\\hat mG}{k_BTr} \\right|\n    \\label{eq:relative_potential_energy}\n\\end{equation}\\] with the mass \\(m\\) of the particle, the mass \\(\\hat m\\) of the planetary body, and the gravitational constant \\(G\\) (Chamberlain, 1963). Both, \\(\\epsilon= \\epsilon\\left(r\\right)\\) and \\(\\tilde\\epsilon= \\epsilon\\left(r+h\\right)\\), are required for the partition function \\(\\zeta\\), which is the linear combination of three individual partition functions which are describing particles in ballistic orbits, \\(\\zeta_{bal}\\), particles in satellite orbits, \\(\\zeta_{sat}\\), and particles that are on escape trajectories, \\(\\zeta_{esc}\\): \\[\\begin{align}\n    \\zeta_{bal} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{sat} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{esc} &= \\frac{1}{\\sqrt{\\pi}} \\left( \\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\right. \\nonumber \\\\\n    &\\left. \\qquad \\cdot \\left(\\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right) \\right) \\\\[4mm]\n    \\Rightarrow \\zeta&= \\zeta_{bal} + \\zeta_{sat} + \\zeta_{esc}\n\\end{align}\\] with the gamma and lower incomplete gamma function, \\(\\Gamma\\) and \\(\\gamma\\), respectively (Cook et al., 2013).\n\n\nLACE\nThe LACE (Lunar Atmospheric Composition Experiment) on the Apollo 17 mission was part of the ALSEP (Apollo Lunar Surface Experiments Package) to investigate the composition and variation of the Moon’s exosphere. Specifically designed for the mission, the instrument consisted of a small, remotely operated package containing a mass spectrometer coupled with a pressure sensor. With its opening oriented upward, it was able to measure the downward stream of particles at the lunar surface at the Apollo 17 landing location, the Taurus-Littrow Valley. On December 27, 1971, the instrument was activated to start the data acquisition process \\(50\\,\\mathrm{h}\\) after local sunset to operate through one entire lunar night. Increasing exospheric number densities at the morning-terminator as well as higher outgassing rates led to elevated background gas levels and prompted the temporary suspension of operations during the lunar day, except a short check near \\(12\\,\\mathrm{h}\\) local time. In total, the LACE measured the nighttime densities for nine lunations. (Hoffman, 1975; Killen et al., 2019)\nThe instrument’s mass spectrometer measured the mass per unit charge ratio up to a maximum of \\(110\\,\\mathrm{}\\) in three mass ranges \\(1\\,\\mathrm{}\\) to \\(4\\,\\mathrm{}\\), \\(12\\,\\mathrm{}\\) to \\(48\\,\\mathrm{}\\), and \\(27.4\\,\\mathrm{}\\) to \\(110\\,\\mathrm{}\\) termed low, medium, and high. A triple-channel analyzer was able to capture data from all three ranges simultaneously as counts per \\(0.6\\,\\mathrm{s}\\) at every voltage step (Hoffman, 1975). Note that due to the measurement technique ambiguous data points of particles with double mass being doubly ionized were taken (Killen et al., 2019).\n\n\nLADEE\nThe LADEE (Lunar Atmosphere and Dust Environment Explorer) mission was created in 2008 to address the goals identified in the decadal survey report “Scientific Context for Exploration of the Moon”, which highlighted the lunar atmosphere as a priority for future lunar science missions. Among its main mission objectives was to determine the composition of the lunar exosphere, as well as its distribution and variability. On April 18th, 2014, LADEE was decommissioned through impact into the Moon after around \\(100\\,\\mathrm{d}\\) of nominal science operations. The gathered data was processed and submitted to the NASA PDS (Planetary Data System) for public access (Hine & Delory, 2014). The NMS (Neutral Mass Spectrometer) aboard the spacecraft measured the mass distribution of neutral species over a mass-to-charge range between \\(2\\,\\mathrm{}\\) to \\(150\\,\\mathrm{}\\). With its retrograde, equatorial orbit around the Moon, LADEE conducted systematic surveys of helium, neon, and argon densities confined in a \\(\\pm23\\,\\mathrm{\\degree}\\) near-equatorial band with altitudes ranging between \\(4\\,\\mathrm{}\\) and \\(61\\,\\mathrm{km}\\) (Benna et al., 2015).  pds-atmospheres.nmsu.edu  last visited: May 2023\n\n Figure Julia Download\n\n\n\n\n\n\n\n\n\n(a) Helium surface number densities.\n\n\n\n\n\n\n\n\n\n(b) Neon surface number densities.\n\n\n\n\n\n\n\n\n\n(c) Argon surface number densities.\n\n\n\n\nFigure 5: Helium (a), neon (b), and argon (c) surface number densities, based on derived data of the LADEE mission and projected to the surface based on Chamberlain (1963) barometric model. Maximum densities are highlighted with a red marker and the respective numeric value of the surface number density. The data was taken from the PDS (Hine & Delory, 2014). Gray areas indicate lunar nighttime.\n\n\n\n\nusing .ExESS\nusing DataFrames, CSV\nDATA_PATH = joinpath(@__DIR__, \"..\", \"..\", \"data\", \"ladee_data_derived\")\n\n#::. processing functions\nfunction get_file_names()\n    dirs = readdir(DATA_PATH)\n    dirs = filter(x -&gt; occursin(\"20\", x), dirs)\n    files = String[]\n    for dir in dirs\n        new_files = readdir(joinpath(DATA_PATH, dir))\n        new_files = filter(x -&gt; occursin(r\"csv$\", x), new_files)\n        files = vcat(files, joinpath.(dir, new_files))\n    end\n    return files\nend\nfunction get_file_names(element::String)\n    files = get_file_names()\n    files = filter(x -&gt; occursin(lowercase(element), x), files)\n    return files\nend\n\nfunction load_data(file::String)\n    df = DataFrame(CSV.File(joinpath(DATA_PATH, \"$file\")))\n    return df\nend\n\nfunction load_all_data(element::String)\n    files = get_file_names(element)\n    df = DataFrame()\n    for file in files\n        df = vcat(df, load_data(file))\n    end\n    return df\nend\n\nfunction find_max(df::DataFrame)\n    idxs = Int64[]\n    for (idx, val) in enumerate(df[:,14])\n        if !isnan(val); push!(idxs, idx); end\n    end\n    n = df[idxs,14]\n    val, idx = findmax(n)\n    return val, df[idx, 13], df[idx,12]\nend\n\n#::. plotting functions\nfunction plot_lat(element::String; kwargs...)\n    df = load_all_data(element)\n    plot_lat(df, element; kwargs...)\n    return nothing\nend\nfunction plot_lat(df::DataFrame, element::String; stdfilter=1.0, cmap=reverse(ColorSchemes.deep))\n    idxs = df[:,15] ./ df[:,14] .&lt; stdfilter\n\n    #::. figure and axis setup\n    fig = Figure(resolution=(1000,230))\n    ax = MyLTGeoAxis(fig[1, 1];\n        xlabelpadding=30,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax, -30, 30)\n    night_shade(ax)\n\n    #::. data\n    sc = scatter!(ax, df[idxs, 13]/24*360 .- 180, df[idxs, 12];\n        color=df[idxs, 14],\n        colormap=cmap,\n        colorrange=(0, 2e4),\n        markersize=2)\n\n    #::. plot maximum\n    nmax, lonmax, latmax = find_max(df[idxs,:])\n    scatter!(ax, lonmax/24*360 .- 180, latmax; color=\"red\", markersize=10, marker=:utriangle)\n    text!(ax, lonmax/24*360 .- 180, latmax; text=\"$(round((nmax/1e3); digits=1))\", halign=:left, valign=:bottom, color=\"red\")\n\n    #::. colorbar\n    Colorbar(fig[1,2], sc;\n        label=\"$element Abundance [10³/cm³]\",\n        ticks=([0,5000,10000,15000,20000], [\"0\", \"5\", \"10\", \"15\", \"20\"]),\n        highclip=cmap[end] |&gt; RGB{Colors.N0f8})\n    \n    #::. custom x-axis labels\n    ax2 = MyLTGeoAxis(fig[1, 1];\n        spinewidth = 0,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax2, -40, 30)\n    hidedecorations!(ax2)\n    text!(ax2, -140, -30; text= \"0\")\n    text!(ax2,  -63, -30; text= \"6\")\n    text!(ax2,   11, -30; text=\"12\")\n    text!(ax2,   89, -30; text=\"18\")\n    text!(ax2,  165, -30; text=\"24\")\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.pdf\"), fig)\n    # save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.svg\"), fig) # too big!\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.png\"), fig, px_per_unit=4)\n    return nothing\nend\n\n\n#::.\nget_all() = load_all_data(\"He\"), load_all_data(\"Ne\"), load_all_data(\"Ar\")\nfunction run_all(dfHe, dfNe, dfAr; T=250, kwargs...)\n    dfHe_p, dfNe_p, dfAr_p = copy(dfHe), copy(dfNe), copy(dfAr)\n    dfHe_p[:,14] .= projection_CHAMBERLAIN1963.(dfHe_p[:, 14], LUNAR_RADIUS .+ dfHe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(4))\n    dfNe_p[:,14] .= projection_CHAMBERLAIN1963.(dfNe_p[:, 14], LUNAR_RADIUS .+ dfNe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(20))\n    dfAr_p[:,14] .= projection_CHAMBERLAIN1963.(dfAr_p[:, 14], LUNAR_RADIUS .+ dfAr_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(40))\n    plot_lat(dfHe_p, \"He\"; kwargs...)\n    plot_lat(dfNe_p, \"Ne\"; kwargs...)\n    plot_lat(dfAr_p, \"Ar\"; kwargs...)\nend\n\n\n\n LADEE_n0_Helium.png \n LADEE_n0_Neon.png \n LADEE_n0_Argon.png"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#densities-by-exospheric-species",
    "href": "documentation/fundamentals/moon.html#densities-by-exospheric-species",
    "title": "2.6 The Moon",
    "section": "Densities by Exospheric Species",
    "text": "Densities by Exospheric Species\nThis section lists referenced values of the lunar exosphere surface densities, generally provided as a number density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\). Some references provide their values in terms of a column density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-2}}}\\right]\\), which includes the respective measurements column height, i.e., the illuminated line of sight of brightness measurements like LAMP.\nSee the additional information section in this section’s appendix to find details about some sources, their assumptions, and their measurement methods.\n\nAtomic Hydrogen – \\(\\ce{H}\\)\n\n\nTable 1: Overview of reported hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nupper limit, UVS Apollo 17\n\\(1.0 \\times 10^1\\)\nFastie et al. (1973)\n\n\nupper limit\n\\(1.7 \\times 10^1\\)\nFeldman & Morrison (1991)  Gladstone et al. (2009)\n\n\nLAMP\n\\(1.4 \\times 10^{-1}\\)\nGladstone et al. (2009)\n\n\nmodel predictions, dayside\n\\(8.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit\n\\(2.4 \\times 10^1\\)\nCook et al. (2013)\n\n\n\n\n\n\nMolecular Hydrogen – \\(\\ce{H2}\\)\n\n\nTable 2: Overview of reported molecular hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nmodel predictions, dayside  model predictions, nightside\n\\(2.0 \\times 10^3\\)  \\(1.2 \\times 10^4\\)\nHodges et al. (1973)\n\n\nLACE, upper limit, dayside  LACE, upper limit, nightside\n\\(6.0 \\times 10^3\\)  \\(6.5 \\times 10^4\\)\nHoffman et al. (1973)\n\n\nUVS Apollo 17, upper limit\n\\(1.2 \\times 10^4\\)\nFastie et al. (1973)\n\n\nApollo, upper limit, dayside  Apollo, upper limit, nightside\n\\(2.5 \\text{ to } 9.9 \\times 10^3\\)  \\(1.0 \\text{ to } 15.0 \\times 10^4\\)\nHeiken et al. (1991), chap 3.10\n\n\nupper limit  expected LAMP density\n\\(9.0 \\times 10^3\\)  \\(1.1 \\times 10^4\\)\nGladstone et al. (2009)\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2}\\)\n\\(2.1 \\times 10^3\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit, dusk  LAMP, upper limit, dawn\n\\(1.3 \\text{ to } 2.1 \\times 10^3\\)  \\(1.8 \\text{ to } 2.4 \\times 10^3\\)\nCook et al. (2013)\n\n\nLAMP, “effective”  LAMP, nightside, dusk  LAMP, nightside, dawn\n\\(0.8 \\text{ to } 1.6 \\times 10^3\\)  \\(0.5 \\text{ to } 1.5 \\times 10^3\\)  \\(0.9 \\text{ to } 1.9 \\times 10^3\\)\n Stern et al. (2013)\n\n\nCHACE, at latitudes: \\(20\\text{ to }50\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(50\\text{ to }70\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(70\\text{ to }90\\,\\mathrm{\\degree}\\)\n\\(4.0 \\text{ to } 6.0 \\times 10^2\\)  \\(5.0 \\text{ to } 6.5 \\times 10^2\\)  \\(6.5 \\text{ to } 8.5 \\times 10^2\\) \n Thampi et al. (2015)\n\n\nmodel predictions, equator, dayside  model predictions, equator, nightside  model predictions, equator, dayside, in magnetotail  model predictions, equator, nightside, in magnetotail\n\\(1.5 \\text{ to } 2.2 \\times 10^3\\)  \\(3.0 \\text{ to } 4.2 \\times 10^3\\)  \\(0.4 \\text{ to } 0.7 \\times 10^3\\)  \\(1.0 \\text{ to } 1.5 \\times 10^3\\)\n Tucker et al. (2021)\n\n\n\n\n\n\nHelium – \\(\\ce{He}\\)\n\n\nTable 3: Overview of reported helium surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(1.6 \\times 10^3\\)  \\(3.8 \\times 10^4\\)\nHodges et al. (1973)\n\n\nupper limit, dayside  upper limit, nightside\n\\(2.0 \\times 10^3\\)  \\(4.0 \\times 10^4\\)\nHoffman et al. (1973)\n\n\n\n\n\n\nHydroxyl – \\(\\ce{OH}\\)\n\n\nTable 4: Overview of reported hydroxyl surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]OH}\\)\n\\(1.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\n\n\n\n\nWater – \\(\\ce{H2O}\\)\n\n\nTable 5: Overview of reported water surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2O}\\)\n\\(2.9 \\times 10^3\\)\nWurz et al. (2012)\n\n\n\n\n\n\nNeon – \\(\\ce{Ne}\\)\n\n\nTable 6: Overview of reported Neon surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(4.0 \\text{ to } 7.0 \\times 10^3\\)  \\(1.0 \\text{ to } 2.0 \\times 10^5\\)\nHodges et al. (1973)\n\n\nsolar zenith angle:    \\(+168\\degree\\)    \\(-136\\degree\\)    \\(-112\\degree\\)    \\(-89\\degree\\)  \\(\\Rightarrow\\) average\n \\(9.4 \\times 10^4\\)  \\(7.7 \\times 10^4\\)  \\(7.1 \\times 10^4\\)  \\(8.7 \\times 10^4\\)  \\(8.2 \\times 10^4\\) \n   Hoffman et al. (1973)\n\n\n\n\n\n\nArgon – \\(\\ce{Ar}\\)"
  },
  {
    "objectID": "documentation/documentation.html",
    "href": "documentation/documentation.html",
    "title": "Preface",
    "section": "",
    "text": "Authors\nAlexander Smolka\n\n\nLicense\nLicense\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/trajectories/non-ballistic_trajectories.html",
    "href": "documentation/trajectories/non-ballistic_trajectories.html",
    "title": "5.2 Non-Ballistic Trajectories",
    "section": "",
    "text": "CitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "ExESS",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 Alexander Smolka\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html",
    "href": "documentation/trajectories/ballistic_trajectories.html",
    "title": "5.1 Ballistic Trajectories",
    "section": "",
    "text": "Intro"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "href": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "title": "5.1 Ballistic Trajectories",
    "section": "General Solution",
    "text": "General Solution\n landing_position\nThe following equations, mostly based on orbital mechanics functions presented in J. A. Kegerreis et al. (2017), Walter (2018), and Schoerghofer (2022), assume a perfectly spherical central body with radius \\(r\\) and of mass \\(m\\). Based on the launch velocity vector \\(\\boldsymbol{\\mathbf{v}}\\in\\mathbb{R}^3\\) at the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\), the landing coordinates \\(\\left(\\Theta_1, \\Phi_1\\right)\\) of the ballistic trajectory can be calculated using spherical trigonometry. The velocity vector is assumed to be in local cartesian coordinates, i.e. with \\(v_1\\) and \\(v_2\\) being the components in the horizontal plane and \\(v_3\\) being the vertical component. Starting with the escape velocity \\[\\begin{equation}\n  v_{esc}\\left(r, m\\right) = \\sqrt{\\frac{2 Gm}{r}} \\label{eq:escape_velocity}\n\\end{equation}\\] with the gravitational constant \\(G\\), the central body’s mass \\(m\\), and the radial distance of its center of mass \\(r\\), the relative kinetic energy fraction \\[\\begin{equation}\n  \\epsilon_{kin}\\left(\\boldsymbol{\\mathbf{v}}, v_{esc}\\right) = \\left(\\frac{|\\boldsymbol{\\mathbf{v}}|}{v_{esc}}\\right)^2  \\label{eq:relative_kinetic_energy}\n\\end{equation}\\] can be determined. From the known launch velocity vector, the azimuth angle \\[\\begin{equation}\n  \\alpha\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\begin{cases}\n      \\cos^{-1}\\left(v_1/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2\\geq0\\\\\n      -\\cos^{-1}\\left(v_1/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2&lt;0\n    \\end{cases} \\label{eq:azimuth_angle}\n\\end{equation}\\] and the zenith angle \\[\\begin{equation}\n  \\psi\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\tan^{-1}\\left(\\frac{\\sqrt{v_1^2 + v_2^2}}{v_3}\\right)  \\label{eq:zenith_angle}\n\\end{equation}\\] can be extracted. The latter is subsequently used for the determination of the eccentricity \\[\\begin{equation}\n  e\\left(\\epsilon_{kin}, \\psi\\right) = \\sqrt{1 - 4 \\epsilon_{kin}\\cdot (1 - \\epsilon_{kin}) \\cdot \\sin^2 \\psi}.  \\label{eq:eccentricity}\n\\end{equation}\\] With both the \\(e\\) and the relative kinetic energy \\(\\epsilon_{kin}\\) known, the true anomaly at launch \\[\\begin{equation}\n  \\theta_0 = \\theta\\left(e, \\epsilon_{kin}\\right) = \\cos^{-1}\\left(\\frac{1}{e} \\cdot \\left(\\frac{1 - e^2}{2-2 \\epsilon_{kin}} -1 \\right)\\right)  \\label{eq:true_anomaly}\n\\end{equation}\\] as well as the landing position \\(\\theta_1 = 2\\pi - \\theta_0\\), can be calculated, leading to the angular difference between the landing and launch true anomaly \\(\\theta_1 - \\theta_0 = 2\\pi - 2\\theta= \\Delta\\theta\\).\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 1: Sketch the spherical trigonometry problem of the landing position calculation. The ground track distance is given as an angular distance of \\(\\Delta\\theta\\), complemented by all additional angular arguments used for the derivation of the landing position.\n\n\n\n\n\\tdplotsetmaincoords{70}{135}\n\\begin{tikzpicture}[tdplot_main_coords, scale=1.25]\n\n    %::. \"coordinate system\" and sphere lines\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (0,0,3);\n    \\tdplotdrawarc[TUMGrayLight, dashed]{(0,0,0)}{3}{-1}{110}{}{}\n    \\tdplotdrawarc[TUMGrayLight, dashed]{(0,0,1.460)}{2.573}{-3}{110}{}{}\n\n    %::. start point\n    \\pgfmathsetmacro{\\psx}{2.433}\n    \\pgfmathsetmacro{\\psy}{0.973}\n    \\pgfmathsetmacro{\\psz}{1.460}\n\n    \\node[anchor=east, yshift=-3] at (\\psx, \\psy, \\psz) {\\footnotesize launch};\n\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (2.7854, 1.1142, 0);\n    \\draw[TUMGrayLight, dashed] (\\psx, \\psy, 0) -- (\\psx, \\psy, \\psz);\n\n    \\tdplotgetpolarcoords{\\psx}{\\psy}{\\psz}\n    \\tdplotsetthetaplanecoords{\\tdplotresphi}\n\n    \\tdplotdrawarc[latex-, tdplot_rotated_coords]{(0,0,0)}{3}{\\tdplotrestheta}{90}{anchor=east}{$\\latitude_0$}\n    \\tdplotdrawarc[tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=east}{$\\overline{\\latitude_0}$}\n\n    %::. endpoint\n    \\pgfmathsetmacro{\\pex}{0.045}\n    \\pgfmathsetmacro{\\pey}{1.785}\n    \\pgfmathsetmacro{\\pez}{2.410}\n\n    \\node[anchor=west, xshift=1] at (\\pex, \\pey, \\pez) {\\footnotesize landing};\n\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (0.0756, 2.999, 0);\n    \\draw[TUMGrayLight, dashed] (\\pex, \\pey, 0) -- (\\pex, \\pey, \\pez);\n\n    \\tdplotgetpolarcoords{\\pex}{\\pey}{\\pez}\n    \\tdplotsetthetaplanecoords{\\tdplotresphi}\n\n    \\tdplotdrawarc[latex-, tdplot_rotated_coords]{(0,0,0)}{3}{\\tdplotrestheta}{90}{anchor=west}{$\\latitude_1$}\n    \\tdplotdrawarc[tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=west, xshift=4}{$\\overline{\\latitude_1}$}\n\n    %::. connection (cross-product for 3D orientation)\n    \\tdplotcrossprod(\\psx,\\psy,\\psz)(\\pex,\\pey,\\pez)\n\n    \\tdplotgetpolarcoords{\\tdplotresx}{\\tdplotresy}{\\tdplotresz}\n    \\tdplotsetrotatedcoords{\\tdplotresphi}{\\tdplotrestheta}{180-\\tdplotrestheta+1}\n\n    \\tdplotdrawarc[very thick, -latex, tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=north, xshift=5}{$\\Delta\\trueAnomaly$}\n\n    %::. longitude\n    \\tdplotdrawarc[latex-latex, thin,]{(0,0,0)}{1.5}{22}{88}{anchor=north}{$\\Delta\\longitude$}\n\n    %::. launch azimuth angle\n    \\tdplotgetpolarcoords{\\psx}{\\psy}{\\psz}\n    \\tdplotsetrotatedcoords{\\tdplotresphi}{\\tdplotrestheta}{0}\n    \\tdplotdrawarc[-latex, thin, tdplot_rotated_coords]{(0,0,3)}{0.6}{93}{135}{anchor=west}{$\\azimuth$}\n\\end{tikzpicture}\nNote that the code above requires the TikZ package tikz-3dplot. Additionally, the code relies on further definitions, for example of the gray-color: \\definecolor{TUMGrayLight}  {RGB}{204, 204, 204} based on the xcolor package.\n\n\n\n landing_position_calc.svg \n landing_position_calc.pdf \n landing_position_calc.png \n\n\n\n\nBased on Butler (1997), J. Kegerreis (2020), and Schoerghofer (2022), the landing position \\(\\left(\\Theta_1, \\Phi_1\\right)\\) can now be calculated using the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\), the traveled true anomaly \\(\\Delta\\theta\\), and the azimuth angle \\(\\alpha\\) of the launch velocity. The problem is sketched in Figure 1, where \\(\\overline{\\Phi_0}\\) and \\(\\overline{\\Phi_1}\\) are the complementary angles of the latitudes, i.e., \\(\\Phi= \\frac{\\pi}{2} - \\overline{\\Phi}\\). Based on the cosine-law of spherical trigonometry, the angular triangle \\(\\left(\\Delta\\theta, \\overline{\\Phi_0}, \\overline{\\Phi_1}\\right)\\) can be used to find \\[\\begin{equation}\n    \\sin\\Phi_1 = \\sin\\Phi_0 \\cdot \\cos\\Delta\\theta+ \\cos\\Phi_0 \\cdot \\sin\\Delta\\theta\\cdot \\sin\\alpha\n\\end{equation}\\] with \\(\\cos\\overline\\Phi= \\sin\\Phi\\) and \\(\\sin\\overline\\Phi= \\cos\\Phi\\), and the same triangle can be used for the calculation of the longitude difference \\(\\Delta\\Theta\\) using the cosine-law \\[\\begin{align}\n    \\cos\\Delta\\theta&= \\sin\\Phi_0 \\cdot \\sin\\Phi_1 + \\cos\\Phi_0 \\cdot \\cos\\Phi_1 \\cdot \\cos\\Delta\\Theta\\\\[3mm]\n    \\Rightarrow\\quad \\cos\\Delta\\Theta&= \\frac{\\cos\\Delta\\theta- \\sin\\Phi_0 \\cdot \\sin\\Phi_1}{\\cos\\Phi_0 \\cdot \\cos\\Phi_1}.\n\\end{align}\\] Note that numerical round-off issues could lead to sine and cosine expressions larger than one. What previous authors did not account for is that due to the periodicity of the cosine, two different cases have to be considered when extracting the \\(\\Delta\\Theta\\): \\[\\begin{equation}\n    \\Delta\\Theta= \\begin{cases} \\Delta\\Theta& \\text{if } \\Delta\\theta\\leq \\pi, \\\\ 2\\pi - \\Delta\\Theta& \\text{else.} \\end{cases}\n\\end{equation}\\] Finally, the landing longitude \\(\\Theta_1\\) can be calculated based on the direction of the launch velocity as \\[\\begin{equation}\n    \\Rightarrow \\Theta_1 = \\Theta_0 + \\mathop{\\mathrm{sgn}}\\left(v_1\\right)\\cdot\\Delta\\Theta,\n\\end{equation}\\] with the signum function \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = 1\\) for \\(v_1\\geq0\\) and \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = -1\\) for \\(v_1&lt;0\\)."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#time-of-flight-calculation",
    "href": "documentation/trajectories/ballistic_trajectories.html#time-of-flight-calculation",
    "title": "5.1 Ballistic Trajectories",
    "section": "Time of Flight Calculation",
    "text": "Time of Flight Calculation\nThe time of flight \\[\\begin{equation}\n  t_{flight}= t_1 - t_0 = P- 2t_0 \\label{eq:time_of_flight}\n\\end{equation}\\] is the time difference between landing, \\(t_1\\), and launching, \\(t_0\\). Due to symmetry reasons, the landing time is \\(t_1 = P-t_0\\), and the expression of Eq. \\(\\eqref{eq:time_of_flight}\\) can be simplified by using the orbital period \\[\\begin{equation}\n  P\\left(a, m\\right) = 2\\pi\\sqrt{\\frac{a^3}{Gm}},  \\label{eq:orbit_period}\n\\end{equation}\\] which requires the mass \\(m\\) of the central body, as well as the semi-major axis of the trajectory’s orbit \\[\\begin{equation}\n  a\\left(r, \\epsilon_{kin}\\right) = \\frac{r}{2 \\cdot \\left(1 - \\epsilon_{kin}\\right)}. \\label{eq:semi_major_axis}\n\\end{equation}\\] The time at launch, \\(t_0\\), can be calculated according to \\[\\begin{equation}\n  t\\left(M, P\\right) = \\frac{M}{2\\pi} \\cdot P\\label{eq:orbit_time}\n\\end{equation}\\] with the mean anomaly at launch \\[\\begin{equation}\n  M\\left(e, E\\right) = E- e\\sin E\\label{eq:mean_anomaly}\n\\end{equation}\\] and the eccentric anomaly at launch \\[\\begin{equation}\n  E\\left(e, \\theta\\right) = \\begin{cases}\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) & \\text{for } 0\\leq\\theta&lt;\\pi\\\\\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) + 2\\pi & \\text{for } \\pi\\leq\\theta&lt;2\\pi\n    \\end{cases}  \\label{eq:eccentric_anomaly}\n\\end{equation}\\] which are based on the previously calculated eccentricity, see Eq. \\(\\eqref{eq:eccentricity}\\), and true anomaly at launch, see Eq. \\(\\eqref{eq:true_anomaly}\\)."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "href": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Simplification for Uniform Gravity",
    "text": "Simplification for Uniform Gravity\nParticles launched with small velocities do not reach altitudes at which the gravitational acceleration changes significantly.\n–&gt;"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#ordinary-differential-equation-of-motion",
    "href": "documentation/trajectories/ballistic_trajectories.html#ordinary-differential-equation-of-motion",
    "title": "5.1 Ballistic Trajectories",
    "section": "Ordinary Differential Equation of Motion",
    "text": "Ordinary Differential Equation of Motion"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#numerical-ode-solver-analysis",
    "href": "documentation/trajectories/ballistic_trajectories.html#numerical-ode-solver-analysis",
    "title": "5.1 Ballistic Trajectories",
    "section": "Numerical ODE Solver Analysis",
    "text": "Numerical ODE Solver Analysis"
  },
  {
    "objectID": "documentation/lunar_water_exosphere/conversion_model.html",
    "href": "documentation/lunar_water_exosphere/conversion_model.html",
    "title": "8.1 Conversion Model",
    "section": "",
    "text": "Poster Figure LaTeX Downloads\n\n\n\nCite as: Smolka, A. and Reiss, P. (2023). Modelling the Lunar Water Cycle Through Coupled Monte Carlo Simulations of the Moon’s Surface and Exosphere, Lunar and Planetary Science Conference, 54, 2023.\n\n\n\n\n\n\\documentclass[tikz,landscape]{standalone}\n\n\\usepackage{geometry}\n    \\geometry{paperheight=78cm, paperwidth=110cm, lmargin=20mm, rmargin=20mm, tmargin=20mm, bmargin=20mm}\n\n\\usepackage{pgfplots}\n    \\pgfplotsset{compat=newest}\n    \\usetikzlibrary{arrows.meta}\n    \\usetikzlibrary{backgrounds}\n    \\usetikzlibrary{calc}\n    \\usetikzlibrary{positioning}\n    \\usetikzlibrary{patterns}\n    \\usetikzlibrary{fit}\n\n\\usepackage[T1]{fontenc}\n\\usepackage[largesc]{newtxtext}\n\n\\usepackage[scaled]{helvet}\n\\usepackage[T1]{fontenc}\n    \\renewcommand\\familydefault{\\sfdefault}\n\n\\usepackage{newtxmath}\n\\usepackage{siunitx}\n\\usepackage{tabularx}\n\\usepackage{booktabs}\n\\usepackage[version=4]{mhchem}\n    \\mhchemoptions{layout=stacked}\n\\usepackage{xcolor}\n    \\definecolor{TUMBlue}        {RGB/cmyk}{  0,101,189 / 1.  ,0.43,0.  ,0.  }\n    \\definecolor{TUMBlack}       {RGB/cmyk}{  0,  0,  0 / 0.  ,0.  ,0.  ,1.  }\n    \\definecolor{TUMBlueDarker}  {RGB/cmyk}{  0, 51, 89 / 1.  ,0.57,0.12,0.7 }\n    \\definecolor{TUMBlueLighter} {RGB/cmyk}{152,198,234 / 0.42,0.09,0.  ,0.  }\n    \\definecolor{TUMOrange}      {RGB}{227, 114, 34}\n    \\definecolor{TUMGreen}       {RGB}{162, 173, 0}\n    \\definecolor{tab10blue}{HTML}{1f77b4}\n    \\definecolor{tab10orange}{HTML}{ff7f0e}\n    \\definecolor{tab10green}{HTML}{2ca02c}  \n    \\definecolor{tab10red}{HTML}{d62728}\n    \\colorlet{pcolor}{tab10red}\n    \\colorlet{hcolor}{black}\n    \\colorlet{h2color}{TUMOrange}\n    \\colorlet{ohcolor}{TUMGreen}\n    \\colorlet{h2ocolor}{TUMBlue}\n\n\n\\newcommand{\\rate}[2]{\n    \\Large\n    \\begin{tabular}{l}\n        \\bfseries #1 \\\\\n        #2\n    \\end{tabular}\n}\n\\newcommand{\\sirange}[3]{\\SI{#1}{}\\,\\text{--}\\,\\SI{#2}{#3}}\n\\newcommand{\\h}[1]{\\textcolor{TUMBlueLighter}{\\textbf{#1}}}\n\n\n% layers\n\\pgfdeclarelayer{H}     % declare background layer\n\\pgfdeclarelayer{H2}    % declare background layer\n\\pgfdeclarelayer{OH}    % declare background layer\n\\pgfdeclarelayer{H2O}   % declare background layer\n\\pgfdeclarelayer{loss}  % declare background layer\n\\pgfsetlayers{background,H2O,OH,H2,H,main,loss}  % set the order of the layers (main is the standard layer)\n\n\\begin{document}\n\\pagestyle{empty}\n\n\n%\n\\begin{tikzpicture}[background rectangle/.style={fill=white},show background rectangle,inner frame sep=30px,\n  sub/.style={circle,draw,line width=4pt,minimum size=140pt,anchor=mid,font={\\bfseries\\Huge},fill=white,align=center},\n  path/.style={line width=2.5pt,-latex,font={\\normalsize},},\n  traj/.style={line width=2.5pt,-latex,font={\\normalsize},},\n  rate/.style={rounded corners,draw,solid,line width=2pt,fill=white,inner sep=5pt,font={\\normalsize},text=black},\n  every label/.style={draw=none,fill=none,font={\\footnotesize\\itshape},text=black},\n  loss/.style={at end,above,xshift=5pt,text=black},\n  source/.style={at end,above,xshift=-5pt,text=red,font={\\bfseries\\Huge},},\n]\n  % variables\n  \\def\\innernodesep{.095\\paperwidth}\n  \\def\\outernodesep{.15\\paperwidth}\n  \\def\\whitelinewidth{8pt}\n\n  % H nodes\n  \\node[hcolor,sub] (HGEXO) at (0,0) {\\ce{H(g)_{exo}}};\n  \\node[hcolor,sub,right=\\innernodesep of HGEXO] (HpGEXO) {\\ce{H+(g)_{exo}}};\n  \\node[hcolor,sub,below=\\innernodesep of HGEXO] (HGREG) {\\ce{H(g)_{reg}}};\n\n\n  % H2 nodes\n  \\node[h2color,sub,right=\\outernodesep of HpGEXO] (H2GEXO) {\\ce{H2(g)_{exo}}};\n  \\node[h2color,sub,right=\\innernodesep of H2GEXO] (H2pGEXO) {\\ce{H2+(g)_{exo}}};\n  \\node[h2color,sub,below=\\innernodesep of H2GEXO] (H2GREG) {\\ce{H2(g)_{reg}}};\n\n\n  % OH nodes\n  \\node[ohcolor,sub,below=0.7*\\outernodesep of HGREG] (OHGEXO) {\\ce{OH(g)_{exo}}};\n  \\node[ohcolor,sub,right=\\innernodesep of OHGEXO] (OHpGEXO) {\\ce{OH+(g)_{exo}}};\n  \\node[ohcolor,sub,below=\\innernodesep of OHGEXO] (OHGREG) {\\ce{OH(g)_{reg}}};\n  \\node[ohcolor,sub,right=\\innernodesep of OHGREG] (OHADREG) {\\ce{OH(ad)_{reg}}};\n\n\n  % H2O nodes  \n  \\node[h2ocolor,sub,right=\\outernodesep of OHpGEXO] (H2OGEXO) {\\ce{H2O(g)_{exo}}};\n  \\node[h2ocolor,sub,right=\\innernodesep of H2OGEXO] (H2OpGEXO) {\\ce{H2O+(g)_{exo}}};\n  \\node[h2ocolor,sub,below=\\innernodesep of H2OGEXO] (H2OGREG) {\\ce{H2O(g)_{reg}}};\n  \\node[h2ocolor,sub,right=\\innernodesep of H2OGREG] (H2OADREG) {\\ce{H2O(ad)_{reg}}};\n\n  % switch to background layer\n  \\begin{pgfonlayer}{H}\n\n  %%% rates\n  %% H\n  \\draw[path,hcolor] (HGEXO.0) -- (HpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate{Photoionization}{\\ce{H(g)_{exo} -&gt; H(g)^+_{exo} }}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (HGREG.180) -- +(-3,0) |- ($(OHADREG.255)+(0,-1)$) -- (OHADREG.255);\n  \\draw[path,hcolor] (HGREG.180) -- +(-3,0) |- ($(OHADREG.255)+(0,-1)$) \n    node[rate,pos=0.125,right,xshift=-10pt,label={below:Griscom (1985); Jones et al. (2021)}]{\n      \\rate\n        {\\ce{OH} Adsorption; Regolith \\ce{H} Annealing}\n        {\\ce{M-O + H(g)_{reg} -&gt; M-OH(ad)_{reg}}}\n  } -- (OHADREG.255);\n\n  \\draw[path,hcolor] (HGREG.75) -- (HGEXO.285)\n    node[rate,midway,right,xshift=-10pt,label={below:Wurz et al. (2022)}]{\n      \\rate\n        {Thermal Desorption \\&\\\\\\textbf{Surface Release}}\n        {\\ce{H(g)_{reg} -&gt; H(g)_{exo}}}\n  };\n\n  \\draw[traj,hcolor] (HGEXO.255) -- (HGREG.105) \n    node[rate,near start,left,xshift=20pt,]{\n      \\rate{Surface Impact}{\\ce{H(g)_{exo} -&gt; H(g)_{reg}}}\n  };\n\n  \\draw[traj,hcolor] (HpGEXO.225) -- (HGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H^+(g)_{exo} -&gt; H(g)_{reg}}}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (HGREG.0) -- (H2GREG.180);\n  \\draw[path,hcolor] (HGREG.0) -- (H2GREG.180)\n    node[rate,pos=0.765,below,yshift=10pt,label={below:~~~~~~~~~~~~~~~~~~~~~~~~~~~~Jones et al. (2018); Jones et al. (2021); Tucker et al. (2018)}] (Htmp1) {\n      \\rate\n        {2$^\\text{nd}$ Order Recombinative Desorption}\n        {\\ce{M-O-H(g)_{reg} + M-OH(ad)_{reg} -&gt; M-O-O-M + H2(g)_{reg}}}\n  };\n\n  \\end{pgfonlayer}\n\n\n  %% H2\n  \\begin{pgfonlayer}{H2}\n  \\draw[path,h2color] (H2GEXO.90) -- +(0,2) -| (HGEXO.90)\n    node[rate,pos=0.15,below,yshift=10pt,label={below:Huebner et al. (1992)}] (H2tmp1) {\n      \\rate\n        {Exospheric Photodissociation}\n        {\\ce{H2(g)_{exo} -&gt; H(g)_{exo} + H(g)_{exo}}\\\\\\ce{H2(g)_{exo} -&gt; H(g)_{exo} + H^+(g)_{exo}}}\n    };\n  \\draw[path,h2color] (H2tmp1.175) -| (HpGEXO.90); \n\n  \\draw[path,h2color] (H2GEXO.0) -- (H2pGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Photoionization}\n        {\\ce{H2(g)_{exo} -&gt; H2(g)^+_{exo} }}\n  };\n\n  \\draw[traj,h2color] (H2pGEXO.225) -- (H2GREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H2^+(g)_{exo} -&gt; H2(g)_{reg}}}\n  };\n\n  \\draw[path,h2color] (H2GREG.75) -- (H2GEXO.285) \n    node[rate,midway,right,xshift=-10pt,label={below:Wurz et al. (2022)}]{\n      \\rate\n        {Thermal Desorption \\&\\\\\\textbf{Surface Release}}\n        {\\ce{H2(g)_{reg} -&gt; H2(g)_{exo}}}\n  };\n\n  \\draw[traj,h2color] (H2GEXO.255) -- (H2GREG.105) \n    node[rate,near start,left,xshift=10pt,]{\n      \\rate{Surface Impact}{\\ce{H2(g)_{exo} -&gt; H2(g)_{reg}}}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (H2GREG.270) -- +(0,-5) -| (HGREG.255);\n  \\draw[path,h2color] (H2GREG.270) -- +(0,-5) -| (HGREG.255)\n    node[rate,pos=0.10,below,yshift=10pt,label={below:Jones et al. (2018); Jones et al. (2021); Tucker et al. (2018)}] (H2tmp2) {\n      \\rate\n        {2$^\\text{nd}$ Order Dissociative Adsorption}\n        {\\ce{M-O + H2(g)_{reg} -&gt; M-OH(ad)_{reg} + M-O + H(g)_{reg}}}\n  };\n  \\draw[white,line width=\\whitelinewidth] (H2tmp2.180) -- +(-1.7,0) |- ($(OHADREG.60)+(0,2.5)$) -- (OHADREG.60);\n  \\draw[path,h2color] (H2tmp2.180) -- +(-1.7,0) |- ($(OHADREG.60)+(0,2.5)$) -- (OHADREG.60);\n  \\end{pgfonlayer}\n\n\n  %% OH\n  \\begin{pgfonlayer}{OH}\n  \\node (H2tmp3) [rate,white,inner sep=3pt,fit=(H2tmp2)] {};\n  \\node (Htmp3) [rate,white,inner sep=4pt,fit=(Htmp1)] {};\n\n  \\draw[path,ohcolor] (OHGREG.75) -- (OHGEXO.285) \n    node[rate,midway,right,xshift=-10pt,]{\n      \\rate{Surface Release}{\\ce{OH(g)_{reg} -&gt; OH(g)_{exo}}}\n  };\n\n  \\draw[traj,ohcolor] (OHGEXO.255) -- (OHGREG.105) \n    node[rate,near start,left,xshift=35pt,]{\n      \\rate{Surface Impact}{\\ce{OH(g)_{exo} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHGEXO.180) -| +(-4.5, 1) |- (HGEXO.165)\n    node[rate,pos=0.12,left,xshift=10pt,label={below:Huebner et al. (1992)}] (OHtmpphoto) {\n      \\rate\n        {Exospheric \\& Adsorbate\\\\\\textbf{Photodissociation}}\n        {\\ce{OH(g)_{exo} $\\Big/$ OH(ad)_{reg}^{sur} -&gt; H(g)_{exo}}}\n  };\n  \\draw[path,ohcolor,arrows=-] (OHADREG.270) -- +(0,-1.5) -| (OHtmpphoto.335);\n\n  \\draw[path,ohcolor] (OHGEXO.0) -- (OHpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Exospheric Photoionization}\n        {\\ce{OH(g)_{exo} -&gt; OH(g)^+_{exo} }}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.90) -- (OHpGEXO.270) \n    node[rate,pos=0.45,above,yshift=-10pt,label={below:}]{\n      \\rate\n        {Adsorbate Photoionization}\n        {\\ce{OH(ad)_{reg}^{sur} -&gt; OH(g)^+_{exo} }}\n  };\n\n  \\draw[path,ohcolor] (OHGREG.15) -- (OHADREG.165) \n    node[rate,midway,above,yshift=-10pt,xshift=-10pt]{\n      \\rate\n        {1$^\\text{st}$ Order Adsorption}\n        {\\ce{OH(g)_{reg} -&gt; OH(ad)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.195) --(OHGREG.345) \n    node[rate,pos=0.6,below,yshift=10pt,xshift=30pt,label={below:Grumpe et al. (2019); Sarantos et al. (2021); Reiss (2018)}]{\n      \\rate\n        {1$^\\text{st}$ Order Desorption}\n        {\\ce{OH(ad)_{reg} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[traj,ohcolor] (OHpGEXO.225) -- (OHGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{OH^+(g)_{exo} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.330) -- (H2OGREG.210)\n    node[rate,pos=0.5,below,yshift=10pt,label={below:Du et al. (2011); Jones et al. (2021)}] (OHtmp1) {\n      \\rate\n        {2$^\\text{nd}$ Order Recombinative Desorption}\n        {\n          \\ce{M-OH(ad)_{reg} + M-OH(ad)_{reg} -&gt; M-O-M + H2O(g)_{reg}}\\\\\n          \\ce{M-OH(ad)_{reg} + M-OH(ad)_{reg} -&gt; M-O-O-M + H2(g)_{reg}}\n        }\n  };  \n  \\draw[path,ohcolor] (OHtmp1.345) |- +(2, -1) -| ($(H2OADREG.0)+(2.5,0)$) |-  (H2GREG.0);\n\n  \\draw[white,line width=\\whitelinewidth] (OHADREG.135) -- (OHGEXO.315);\n  \\draw[path,ohcolor] (OHADREG.135) -- (OHGEXO.315)\n    node[rate,pos=0.25,label={below:DeSimone et al. (2015)~~~~~~~~~~~~~~~~~~~~~~}]{\n      \\rate\n        {Photon Stimulated Desorption}\n        {\\ce{M-OH(ad)_{reg}^{sur} -&gt; OH(g)_{exo}}}\n  };\n\n  % extra path\n  \\draw[white,line width=\\whitelinewidth] (OHADREG.75) |- +(0,2.8) -| ($(Htmp1.180)+(0.9,0)$) |- (H2GREG.195);\n  \\draw[path,ohcolor] (OHADREG.75) |- +(0,2.8)  -| ($(Htmp1.180)+(0.9,0)$) |- (H2GREG.195);\n  \\node (Htmp2) [rate,ohcolor,inner sep=1pt,fit=(Htmp1)] {};\n\n  \\end{pgfonlayer}\n\n\n  %% H2O\n  \\begin{pgfonlayer}{H2O}\n  \\draw[path,h2ocolor] (H2OGREG.75) -- (H2OGEXO.285) \n    node[rate,midway,right,xshift=-10pt,]{\n      \\rate{Surface Release}{\\ce{H2O(g)_{reg} -&gt; H2O(g)_{exo}}}\n  };\n\n  \\draw[traj,h2ocolor] (H2OGEXO.255) -- (H2OGREG.105) \n    node[rate,near start,left,xshift=10pt,]{\n      \\rate{Surface Impact}{\\ce{H2O(g)_{exo} -&gt; H2O(g)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OGEXO.0) -- (H2OpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Exospheric Photoionization}\n        {\\ce{H2O(g)_{exo} -&gt; H2O(g)^+_{exo} }}\n  };\n\n  \\draw[path,h2ocolor] (H2OADREG.90) -- (H2OpGEXO.270) \n  node[rate,pos=0.45,above,yshift=-10pt,label={below:}]{\n    \\rate\n      {Adsorbate Photoionization}\n      {\\ce{H2O(ad)_{reg}^{sur} -&gt; H2O(g)^+_{exo} }}\n};\n\n  \\draw[path,h2ocolor] (H2OGEXO.180) -- (OHpGEXO.0)\n    node[rate,pos=0.4,above,yshift=-10pt,label={below:Huebner et al. (1992)}] (H2Otmp1) {\n      \\rate\n        {Exospheric \\& Adsorbate Photodissociation}\n        {\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + H(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + OH(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + OH^+(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H^+(g)_{exo} + OH(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H2(g)_{exo}}\n        }\n  };\n  \\draw[path,h2ocolor] (H2Otmp1.167) -| (OHGEXO.90);\n  \\draw[path,h2ocolor] (H2Otmp1.160) -| ($(HGEXO.195)+(-3.8,0)$) -- (HGEXO.195);\n  \\draw[path,h2ocolor] (H2Otmp1.150) |- (HpGEXO.0);\n  \\draw[path,h2ocolor] (H2Otmp1.146) |- (H2GEXO.180);\n  \\draw[path,h2ocolor,arrows=-] (H2OADREG.0) -| +(2, 2) |- (H2Otmp1.20);\n\n  \\draw[traj,h2ocolor] (H2OpGEXO.225) -- (H2OGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H2O^+(g)_{exo} -&gt; H2O(g)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OGREG.15) -- (H2OADREG.165) \n    node[rate,midway,above,yshift=-10pt,xshift=-10pt]{\n      \\rate\n        {1$^\\text{st}$ Order Adsorption}\n        {\\ce{H2O(g)_{reg} -&gt; H2O(ad)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OADREG.195) --(H2OGREG.345) \n    node[rate,pos=0.6,below,yshift=10pt,xshift=30pt,label={below:Grumpe et al. (2019); Sarantos et al. (2021); Reiss (2018)}]{\n      \\rate\n        {1$^\\text{st}$ Order Desorption}\n        {\\ce{H2O(ad)_{reg} -&gt; H2O(g)_{reg}}}\n  };\n  \n  \\draw[path,h2ocolor] (H2OGREG.180) -- (OHADREG.0)\n    node[rate,pos=0.45,above,yshift=-10pt,label={above: Jones et al. (2018)}]{\n      \\rate\n        {2$^\\text{nd}$ Order Dissociative Adsorption}\n        {\\ce{M-O-M + H2O(g)_{reg} -&gt; M-OH(ad)_{reg} + M-OH(ad)_{reg}}}\n  };  \n\n  \\draw[white,line width=\\whitelinewidth] (H2OADREG.135) -- (H2OGEXO.315);\n  \\draw[path,h2ocolor] (H2OADREG.135) -- (H2OGEXO.315)\n    node[rate,pos=0.25,label={below:DeSimone et al. (2015)~~~~~~~~~~~~~~~~~~~~~~}]{\n      \\rate\n        {Photon Stimulated Desorption}\n        {\\ce{M-H2O(ad)_{reg}^{sur} -&gt; H2O(g)_{exo}}}\n  };\n\n  \\end{pgfonlayer}\n\n  \\begin{pgfonlayer}{loss}\n     \n    %% H\n    \\draw[white,line width=\\whitelinewidth] ($(HGEXO.135)+(0.5,-0.5)$) -- +(-1.2,1.2); \n    \\draw[path,red,dashed,arrows=latex-] ($(HGEXO.135)+(0.5,-0.5)$) -- +(-1.2,1.2)\n      node[source] {\\LARGE\\ce{p^+_{SW}}}; \n\n    \\draw[white,line width=\\whitelinewidth] ($(HGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,hcolor,dashed] ($(HGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textbf{Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(HpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,hcolor,dashed] ($(HpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n\n      \n    %% H2\n    \\draw[white,line width=\\whitelinewidth] ($(H2GEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2color,dashed] ($(H2GEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textbf{Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2pGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2color,dashed] ($(H2pGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n\n      \n    %% OH\n    \\draw[white,line width=\\whitelinewidth] ($(OHGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textit{\\color{gray}Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(OHpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textit{\\color{gray}Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}};  \n      \n    \\draw[white,line width=\\whitelinewidth] ($(OHADREG.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHADREG.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Sputtering}\\\\\\textbf{Cold-Trapping}\\end{tabular}};  \n\n    \n    %% H2O\n    \\draw[white,line width=\\whitelinewidth] ($(H2OGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textit{\\color{gray}Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2OpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textit{\\color{gray}Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2OADREG.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OADREG.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Sputtering}\\\\\\textbf{Cold-Trapping}\\end{tabular}}; \n    \n  \\end{pgfonlayer}\n\n\\end{tikzpicture}\n\n\\end{document}\n\n\n\n Smolka2023_LPSC_Poster.pdf \n lwcm.pdf   lwcm.svg \n\n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#sec-central_limit_theorem",
    "href": "documentation/fundamentals/stats_mc.html#sec-central_limit_theorem",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "The Central Limit Theorem",
    "text": "The Central Limit Theorem\nLet \\(X_1, X_2, \\dots, X_N\\) be independent random variables which are independent and identically distributed (IID), i.e., identical PDFs \\(w\\left(X_1\\right) = w\\left(X_2\\right) = \\dots = w\\left(X_N\\right)\\). The central limit theorem describes the behavior of the sum of these random variables \\[\\begin{equation}\n    Y= X_1 + X_2 + \\dots + X_N\n\\end{equation}\\] for a large number \\(N\\). An example close to this work is the system of independent particles flying through the lunar exosphere, where the random variable \\(X\\) describes the trajectories of each individual particle and its influence on the exospheric number densities, while the sum \\(Y\\) describes the global exospheric densities of the entire system. While it is by no means a prerequisite that each individual PDF is a Gaussian distribution, the central limit theorem shows that the resulting PDF \\(w\\left(Y\\right)\\) approaches a Gaussian distribution for large \\(N\\), with the means \\(\\langle Y \\rangle = N \\langle X \\rangle\\), and the standard deviations \\(\\sigma_Y= \\sqrt{N} \\sigma_X\\), leading to relative deviations of \\[\\begin{equation}\n    \\frac{\\sigma_Y}{\\langle Y \\rangle} = \\frac{\\sigma_X}{\\sqrt{N}\\langle X \\rangle},\n\\end{equation}\\] which approaches zero for the big \\(N\\). Thus, \\(Y\\) becomes “sharper” with increasing \\(N\\), while being Gaussian distributed: \\[\\begin{equation}\n    w\\left(y\\right) = \\frac{1}{\\sqrt{2 \\pi N \\sigma^2_X}} \\cdot \\exp\\left( -\\frac{\\left( y- \\langle X \\rangle N\\right)^2}{2 \\sigma^2_XN} \\right).\n\\end{equation}\\]"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "href": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Ensemble Averages",
    "text": "Ensemble Averages\nThe analyses of this work will regularly include statements about a statistical ensemble of samples, i.e. of thermodynamic particles in equilibrium. Following Schörghofer (2022) derivation and notation, given any , \\(f(x)\\), the ensemble average of a quantity \\(Y\\) is \\[\\begin{equation}\n    \\langle Y \\rangle = \\int Yf(x)dx. \\label{eq:ensemble_average}\n\\end{equation}\\]"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#basics-simulation-setup",
    "href": "documentation/fundamentals/stats_mc.html#basics-simulation-setup",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Basics Simulation Setup",
    "text": "Basics Simulation Setup\nGenerally speaking, a Monte Carlo simulation is not restricted to any fixed physical system or model but rather describes the method used to simulate the individual problem. Its general structure is presented in Figure 1, showing that a Monte Carlo simulation only consists of an initialization and a loop. The initialization step involves setting up the system and its components, including the specification of the system’s state, the random number generator seed, and setting global parameters, most importantly the number of Monte Carlo steps \\(N\\). The loop then iterates over the \\(N\\) Monte Carlo steps.\n\n Figure LaTeX Downloads\n\n\n\n\n\nFigure 1: Basic Monte Carlo simulation structure. The central piece, the “Monte Carlo Step”, contains the physical model based on both deterministic and probabilistic parts. The probabilistic nature of the individual steps leads to resulting samples which are also probabilistic, but based on an unknown probability distribution. The statistical analysis of the resulting samples leads to the desired statistical properties of the system.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n    connector/.style={draw, circle, thick, minimum size=12pt, fill=white},\n    decision/.style={draw, diamond, aspect=2, thick, rounded corners=2pt, inner sep=3pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main, circle] (START) at (0,0) {\\n{Start}};    \n    \\node[main, below = 1 of START, drop shadow] (INIT) {\\n{Initialization (e.g. setting \\\\ of global parameters)}};\n    \\node[connector, below = 1 of INIT] (CON1) {};\n    \\node[main, below = 1 of CON1, drop shadow] (STEP) {\\n{\\vspace{-2mm}\\\\\\textbf{Monte Carlo Step}\\\\\\vspace{23mm}}};\n        \\node[main, drop shadow] at ($(CON1.90) - (0.4,2.9)$) {\\footnotesize \\n{Deterministic\\\\System}};\n        \\node[main, drop shadow] at ($(CON1.90) - (-0.4,4.25)$) {\\footnotesize \\n{Probabilistic\\\\System}};\n    \\node[decision, below = 1 of STEP] (DEC1) {};\n    \\node[main, below = 1 of DEC1, circle] (END) {\\n{End}};\n\n\n    \\node[right = 0.2 of INIT]  {\\Large$\\Rightarrow$}; \n    \\node[right = 0.8 of INIT]  {{\\n{e.g. number of\\\\ Monte Carlo steps: $N$}}}; \n\n\n    \\node[right = 0.2 of STEP]  {\\Large$\\Rightarrow$}; \n    \\node[right = 0.8 of STEP] (SAMPLES) {{\\n{Samples: \\\\ $\\{\\randomValue_1, \\randomValue_2, \\dots, \\randomValue_N\\}$ }}}; \n\n    \n    %::. connections\n    \\draw[-latex, thick] (START) -- (INIT);\n    \\draw[-latex, thick] (INIT) -- node[midway, right] {$i=1$} (CON1);\n    \\draw[-latex, thick] (CON1) -- (STEP);\n    \\draw[-latex, thick] (STEP) --  (DEC1);\n    \\draw[-latex, thick] (DEC1.180) -| node [near start, below] {$i\\leq N$}  ($(DEC1.180) + (-2,2)$) |- node[near end, above] {$i\\mapsto i+1$} (CON1.180);\n    \\draw[-latex, thick] (DEC1.270) -- node[near start, right] {$i&gt;N$} (END);\n\\end{tikzpicture}\nNote that the code above requires the TikZ package alongside the positioning and shadows libraries. Additionally, the variables like \\randomValue need to be defined in the preamble (i.e. \\(\\newcommand{x}{X}\\)).\n\n\n\n mc_basic.pdf \n mc_basic.svg \n\n\n\n\nIn the context of Monte Carlo simulations, the system under examination is exclusively represented within the iterative process, specifically encapsulated within the Monte Carlo step. This step encompasses various deterministic and probabilistic subsystems, emphasizing the probabilistic aspect inherent to Monte Carlo simulations. While it is unquestionably preferable to solve both the deterministic and probabilistic components of the system analytically, their combination becomes exceedingly complex quite rapidly, necessitating numerical methods. Each Monte Carlo step effectively addresses the system employing probabilistic sampling, engendering not a definitive solution but rather a singular realization of the probabilistic system. As the number of Monte Carlo steps increases, a correspondingly growing quantity of samples is generated. Therefore, collecting these samples enables a comprehensive analysis of the system’s statistical properties.\nIn the context of this work, examples of probabilistic subsystems can be found in many of the underlying physical processes like the energy, velocity, and angle distributions of the various mechanisms in the exosphere and during surface interactions, for example, the section about Thermal Sorption, as well as the handling of probabilistic events like photoionization and -dissociation, sputtering, and Photon and Electron Stimulated Desorption, to just name a few. Additionally, some parameters of the system are either inherently stochastic (like binding energies) or are implemented as such to either account for their uncertainty or to allow for a more realistic simulation. Examples of the latter are the surface geometry and the surface temperatures, which are both modeled as random variables. Examples of deterministic systems are all those calculations that can be performed analytically, like the landing position calculations of purely ballistic trajectories."
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#sampling-from-probability-distributions",
    "href": "documentation/fundamentals/stats_mc.html#sampling-from-probability-distributions",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Sampling from Probability Distributions",
    "text": "Sampling from Probability Distributions\nOne of the most important tasks of any Monte Carlo method is to sample from known probability distributions. This important step can be either done by using a predefined method, like rand (a uniform distribution with the domain \\(\\left[0, 1\\right]\\)) and randn (a normal distribution with the domain \\(\\left(-\\infty, \\infty \\right)\\)) for the Julia Programming language, or by using more complex methods like inversion (Lemieux, 2009). The latter is especially useful when any kind of known, but more complex distribution than a uniform or normal distribution shall be sampled. The main process involves mapping the random number sampled from a uniform distribution between \\(0\\) and \\(1\\) to the CDF of the desired distribution.\nLet \\(R_u\\in\\left[0,1\\right]\\) be the random variable of a uniform distribution with realization \\(r_u\\) of \\(R_u\\sim f(r_u) = 1\\), and let \\(X\\) be the random variable of the desired distribution with realization \\(x\\) of \\(X\\sim f(x)\\). The CDF of \\(X\\), defined as \\(F(X)\\), already matches the domain of \\(R_u\\) and can directly be mapped to it by \\(R_u= F(X)\\). Inversion now inverts the statement to \\(X= F^{-1}(R_u)\\) to obtain the realization \\(x\\) of \\(X\\) from the realization \\(r_u\\) of \\(R_u\\).\n\n\n\n\n\n\nInversion example: \\(f(x) = \\frac{1}{2}\\cos x\\)\n\n\n\n\n\nWhile this approach appears to be quite simple, it greatly depends on the difficulty to derive the CDF’s inverse \\(F^{-1}\\). For example, let the PDF of the random variable \\(X\\in\\left[-\\pi / 2, \\pi / 2 \\right]\\) be given by \\[\\begin{equation}\n    x\\sim f(x) = \\frac{1}{2}\\cos x\n\\end{equation}\\] (which is the elevation angle distribution of the Maxwell-Boltzmann velocity distribution). The CDF can easily be derived as \\[\\begin{equation}\n    F(x) = \\frac{1}{2} \\left( \\sin x+ 1 \\right).\n\\end{equation}\\] We can now draw a random uniform number \\(r_u\\) of \\(R_u\\in\\left[0, 1\\right]\\), set this equal to \\(F(x)\\), and solve for \\(x\\) to obtain the inverse CDF \\(F^{-1}(r_u)\\): \\[\\begin{align}\n    r_u&= \\frac{1}{2} \\left( \\sin x+ 1 \\right) \\\\\n    \\sin x&= 2 r_u- 1 \\\\\n    x&= \\sin^{-1} \\left( 2 r_u- 1 \\right).\n\\end{align}\\]\nTEST THIS HERE!!!"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html",
    "href": "documentation/fundamentals/numerical_grids.html",
    "title": "2.2 Numerical Grids",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#sec-structured_2d_grids",
    "href": "documentation/fundamentals/numerical_grids.html#sec-structured_2d_grids",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured\nThe global, structured, two-dimensional grid is discretizing the surface of a perfectly spherical body of fixed radius \\(r\\) using a regular, structured grid with a fixed angular resolution \\(\\Delta\\vartheta\\times \\Delta\\varphi\\), in azimuth and elevation direction, respectively. Since the definition includes spherical elements, the grid is created in global spherical coordinates \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\); see the section Cartesian and Spherical Coordinates.\n\n\n GlobalStructured2DGrid: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\) - \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\nCoordinate Calculation\nThe spherical coordinates, the azimuth \\(\\vartheta\\) and elevation \\(\\varphi\\), are created as follows: \\[\\begin{alignat}{4}\n    \\vartheta_i &= - \\pi + \\frac{\\pi}{N_\\vartheta} + (i-1)\\Delta\\vartheta& \\quad\\text{for } i \\in \\{1, \\dots, N_\\vartheta\\} & \\quad\\text{with } \\Delta\\vartheta= \\frac{2\\pi}{N_\\vartheta} \\label{eq:gs2dgrid_azimuth} \\\\\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi& \\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\} & \\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi} \\label{eq:gs2dgrid_elevation}\n\\end{alignat}\\] where \\(N_\\vartheta\\) and \\(N_\\varphi\\) define the number of elements in the azimuth and elevation direction, respectively. The created points of the grid are located in the center of each rectangular grid cell, i.e., at \\(\\Delta\\vartheta/ 2 = \\pi /N_\\vartheta\\) and \\(\\Delta\\varphi/ 2 = \\pi / \\left(2N_\\varphi\\right)\\) of each elements sides. Let \\(k\\) be a common index with \\(k = (i-1)N_\\varphi+ j\\), then every grid element’s coordinate can be written as \\(\\boldsymbol{\\mathbf{r}}_k = \\left(r, \\vartheta_i, \\varphi_j\\right)\\).\n\n\n coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\)   surfacecoords: identical to coords\n\n\n\n\n\n\nAzimuth Periodicity\n\n\n\nDue to the \\(2\\pi\\)-periodicity of the azimuth angle \\(\\vartheta\\), the structure, which is the constant \\(\\Delta\\vartheta\\) angular distance between elements, has to be shown across its periodic boundaries: \\[\\begin{align*}\n    \\vartheta_1 + 2\\pi - \\vartheta_{N_\\vartheta} &= \\left(- \\pi + \\frac{\\pi}{N_\\vartheta}\\right) + 2\\pi - \\left(- \\pi + \\frac{\\pi}{N_\\vartheta} + (N_\\vartheta-1)\\frac{2\\pi}{N_\\vartheta} \\right) = \\frac{2\\pi}{N_\\vartheta} = \\Delta\\vartheta\n\\end{align*}\\]\n\n\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 1: Global, structured, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e., radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_2d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_proj(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_3d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if abs(theta) &gt;= 90; continue; end\n        theta -= 180/N_theta\n        x = [cosd(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [sind(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        z = [sin(x) for x in range(-pi/2,pi/2,100)]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all()\n    gs2dgrid_2d(20,10)\n    gs2dgrid_proj(20,10)\n    gs2dgrid_3d(20,10)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer, main, foreground layer}\n\n    \\node (2d) at (0pt,0pt) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_2d.pdf}};\n    \\node[below right = 0 and -3.7 of 2d] (proj) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -1.4 and -1.5 of proj] (3d) {\\includegraphics[width=0.4\\textwidth, trim={0 30pt 0 0}, clip]{./gs2dgrid_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] (3d.70) to [in=0, out=90] node[near end, xshift=0, yshift=20]{\\footnotesize{spherical projection}} (2d.15);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, xshift=20, yshift=-25]{\\footnotesize{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nPlease ensure that the used .pdf files are at the correct location.\n\n\n\n figure.pdf   figure.sng \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\nFigure 1 shows an example of a spherical surface discretization based on the global, structured, two-dimensional grid. Elements were created based on Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\) with \\(N_\\vartheta= 20\\) elements in azimuth and \\(N_\\varphi= 10\\) elements in elevation, leading to a total of \\(200\\) grid elements and, thus, coordinates \\(\\boldsymbol{\\mathbf{r}}_k\\) for \\(k\\in\\{1,\\dots,200\\}\\). The grid resolution is \\(\\Delta\\vartheta\\times\\Delta\\varphi= 18\\,\\mathrm{\\degree}\\times18\\,\\mathrm{\\degree}\\). The figure shows three different views of the same numerical discretization. The top left in a conventional axis making use of the two-dimensionality of the grid, with the azimuth angle \\(\\vartheta\\) on the horizontal axis and the elevation angle \\(\\varphi\\) on the vertical axis. This view highlights the structured nature of the discretization scheme with equally resolved angular elements across the entire domain. The centered graph is a projected view of the spherical coordinates, visualized on a flattened spherical surface based on a projection method (Jenny et al., 2008). While this flattened surface is neither a conformal nor an equal-area projection of an actual sphere, it provides a good and easily understandable visual representation of the spherical nature of the grid. The structure of the discretization scheme is still visible, while the accumulation of grid elements in the polar region becomes apparent. This accumulation is a direct result of the spherical nature of the grid, where the same angular resolution \\(\\Delta\\vartheta\\times\\Delta\\varphi\\) leads to a smaller area of the grid elements in the polar region. The bottom right graph depicts the same discretization scheme in a conventional, cartesian coordinate system, which shows the grid in its physical, three-dimensional form, where the polar grid elements are undistorted. Note that this last representation of the grid only shows half of the sphere (\\(x&gt; 0\\)) since the other half is identical due to the symmetry of the spherical coordinate system.\nThe transformation from one of the visualizations to another is termed either a or a in Figure 1, depending on the type of coordinate system of the destination. The compilation of the three shown views helps to understand both the structural nature of the grid and the general downside of using such a simple discretization scheme, i.e., the clumping of elements around the poles. As already apparent from the area calculation seen in Eq. \\(\\eqref{eq:area_gs2dgrid}\\), the surface coverage of each element on the same elevation is equal, while it decreases with \\(\\sin\\varphi\\rightarrow 0\\) towards the poles.\n\n\nArea Calculation\nWith the same index notation, the area of each spherical grid element can be calculated as the integral over its angles at each angular position: \\[\\begin{align}\n    A_k &= \\int_{\\vartheta_i-\\frac{\\Delta\\vartheta}{2}}^{\\vartheta_i+\\frac{\\Delta\\vartheta}{2}} \\int_{\\varphi_j-\\frac{\\Delta\\varphi}{2}}^{\\varphi_j+\\frac{\\Delta\\varphi}{2}} r^2 \\cos \\left( \\varphi\\right) d\\varphi d\\vartheta\\\\\n    \\Rightarrow\\qquad A_k &= r^2 \\cdot \\Delta\\vartheta\\cdot \\left(\\sin\\left(\\varphi_j + \\frac{\\Delta\\varphi}{2}\\right) - \\sin\\left(\\varphi_j - \\frac{\\Delta\\varphi}{2}\\right)\\right).\n    \\label{eq:area_gs2dgrid}\n\\end{align}\\] Note that the definition for the area is independent of the azimuth angle \\(\\vartheta\\), thus equal across all \\(N_\\vartheta\\) elements in the azimuth direction.\n\n\n areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)\n\n\nContinuous to Discrete Mapping\nIn many applications of numerical grids, it is necessary to map coordinates in the continuous domain to the discrete grid points, i.e., to find the grid element the continuous coordinate is located in. For the structural grid, the problem can be defined in terms of the shared index \\(k\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\boldsymbol{\\mathbf{r}}_k = \\left[r, \\vartheta_k, \\varphi_k\\right]^T\\), or in terms of the individual indices \\(i\\) and \\(j\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\left[r, \\vartheta_i, \\varphi_j\\right]\\) with \\(k = (i-1)N_\\varphi+ j\\). The latter approach can be analytically solved for the azimuth and elevation indices using the function, \\(\\lceil\\bullet\\rceil\\), to round the floating-point calculations to the next higher integer index: \\[\\begin{align}\n    i &= \\left\\lceil \\frac{\\left(\\vartheta+\\pi\\right)N_\\vartheta}{2\\pi} \\right\\rceil = \\left\\lceil \\frac{\\vartheta+\\pi}{\\Delta\\vartheta} \\right\\rceil, \\label{eq:gs2dgrid_coord2idx_azimuth}\\\\\n    j &= \\left\\lceil \\frac{\\left(\\varphi+\\pi/2\\right)N_\\varphi}{\\pi} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil. \\label{eq:gs2dgrid_coord2idx_elevation}\n\\end{align}\\] Numerical problems can arise around the boundaries of the numerical grid due to \\(\\lceil 0 \\rceil = 0\\). As no zeroth grid element exists, the inputs must be pretreated to avoid this problem. For the azimuth angle, the angle is mapped to the half-open interval \\(\\left(-\\pi, \\pi\\right]\\), thus if \\(\\vartheta=-\\pi\\) then \\(\\vartheta\\mapsto \\vartheta+ 2\\pi\\). The elevation is mapped to the open interval \\(\\left(-\\pi/2, \\pi/2\\right)\\) and should \\(|\\varphi| = \\pi/2\\) then \\(\\varphi\\mapsto \\varphi- \\mathop{\\mathrm{sgn}}\\left(\\varphi\\right)\\epsilon\\), with the machine accuracy \\(\\epsilon\\) being the smallest floating point number available to the machine.\n\n\ncoord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\n\nEquatorial Symmetry\nFor some applications, equatorial symmetry of the underlying problem can be assumed, which can be exploited to reduce the number of grid elements. In this case, the grid is only defined for \\(\\varphi\\in \\left[0, \\pi/2\\right)\\), and the elevation is subsequently calculated similar to Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\): \\[\\begin{equation}\n    \\varphi_j = \\frac{\\pi}{4N_\\varphi} + (j-1)\\Delta\\varphi\\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\}  \\quad\\text{with}\\quad \\Delta\\varphi= \\frac{\\pi}{2N_\\varphi}\n    \\label{eq:gs2dgrid_eqsim_elevation}\n\\end{equation}\\] This also changes the function mapping continuous coordinates to specific and discrete grid elements; see Eq. \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\): \\[\\begin{equation}\n    j = \\left\\lceil \\frac{\\left|\\varphi\\right| \\cdot N_\\varphi}{\\pi/2} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil.\n    \\label{eq:gs2dgrid_eqsim_coord2idx_elevation}\n\\end{equation}\\] Taking the absolute value of the elevation angle in the equation above ensures that the function is defined for the entire sphere. Still, the mapping always projects the coordinate onto the upper hemisphere.\n\n\n GlobalStructuredGrid_EqSim Eqs. \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\) - \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)   areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)   coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\)   coord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced\nIn order to counter the disadvantages of the full grid, the reduced, structured grid was introduced. The main goal of this discretization scheme is to keep the advantages of the structured grid as much as possible while reducing the number of elements, especially those at high elevation angles. Mathematically speaking, during the creation of the grid, the individual elements are as close as possible to equal area squares with a constant, physical resolution of \\(\\left(r\\cdot\\cos\\varphi\\cdot\\Delta\\vartheta\\right)\\times\\left(r\\cdot\\Delta\\varphi\\right)\\).\n\nCoordinate Calculation\nThe coordinates for the grid are calculated by iterating over the fixed number \\(N_\\varphi\\) of elevation angles (which calculation is equal to the standard, structured grid, see Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\)), which lead to a variable number \\(\\left(N_\\vartheta\\right)_j\\) of azimuth angles for each elevation angle \\(\\varphi_j\\): \\[\\begin{alignat}{3}\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi&&\\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi}  \\label{eq:gs2dgrid_reduced_elevation} \\\\\n    &\\Rightarrow\\quad \\left(N_\\vartheta\\right)_j = \\left\\lceil \\frac{2\\pi\\varphi_j}{\\pi N_\\varphi} \\right\\rceil \\label{eq:gs2dgrid_reduced_azimuth_elements} \\\\\n    \\vartheta_{i,j} &= - \\pi + \\frac{\\pi}{\\left(N_\\vartheta\\right)_j} + (i-1)\\Delta\\vartheta_j &&\\quad\\text{with } \\Delta\\vartheta_j = \\frac{2\\pi}{\\left(N_\\vartheta\\right)_j} \\label{eq:gs2dgrid_reduced_azimuth}\n\\end{alignat}\\] for \\(j \\in \\{1, \\dots, N_\\varphi\\}\\) and \\(i \\in \\{1, \\dots, \\left(N_\\vartheta\\right)_j\\}\\), respectively.\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 2: Global, structured, reduced, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e., radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_reduced_2d(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n    ylims!(ax, -90, 90)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_proj(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_3d(N_phi=10;)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            if abs(theta) &gt;= 90; continue; end\n            phi0, phi1 = -90 + (i-1)*180/length(grid.N_theta), -90 + i*180/length(grid.N_theta)\n            \n            x = [cosd(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            y = [sind(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            z = [sind(x) for x in range(phi0,phi1,100)]\n\n            lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all(N=10)\n    gs2dgrid_reduced_2d(N)\n    gs2dgrid_reduced_proj(N)\n    gs2dgrid_reduced_3d(N)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer, main, foreground layer}\n\n    \\node (2d) at (0pt,0pt) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_reduced_2d.pdf}};\n    \\node[below right = 0 and -3.7 of 2d] (proj) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_reduced_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -1.4 and -1.5 of proj] (3d) {\\includegraphics[width=0.4\\textwidth, trim={0 30pt 0 0}, clip]{./gs2dgrid_reduced_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] (3d.70) to [in=0, out=90] node[near end, xshift=-20, yshift=25]{\\footnotesize{spherical projection}} (2d.15);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, xshift=30, yshift=-25]{\\footnotesize{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nPlease ensure that the used .pdf files are at the correct location.\n\n\n\n figure.pdf   figure.png \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nEquatorial Symmetry"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#spiral",
    "href": "documentation/fundamentals/numerical_grids.html#spiral",
    "title": "2.2 Numerical Grids",
    "section": "Spiral",
    "text": "Spiral\n\nCoordinate Calculation\nPoints on a spherical surface \\(\\mathbb{S}^2\\) which form a path in the form of a spiral can be expressed in spherical coordinates of the form \\[\\begin{equation}\n    \\vartheta=L\\varphi, \\qquad 0 \\leq \\varphi\\leq \\pi\n\\end{equation}\\] with the polar angle \\(\\varphi\\) and the azimuth \\(\\vartheta\\), or the latitude and longitude, respectively (Hardin et al., 2016). The factor \\(L\\) gives the slope of the spiral. One generation method of \\(N\\) points defines the two spherical coordinates as \\[\\begin{align}\n    L =& \\; \\sqrt{N\\pi}, \\\\\n    h_k =& \\; 1 -\\frac{2k-1}{N}, \\\\\n    \\varphi_k =& \\; \\cos^{-1}(h_k), \\\\\n    \\vartheta_k =& \\; L\\varphi_k\n\\end{align}\\] for \\(k = 1,\\dots, N\\), where the slope \\(L\\) is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by \\(2\\pi\\) in \\(\\vartheta\\) (Hardin et al., 2016).\nA specialized method of creating a set of spiral points implements the Fibonacci sequence \\[\\begin{equation}\n    \\left\\{ F_k \\right\\} = \\left\\{1, 1, 2, 3, 5, 8, 13, \\dots \\right\\}\n\\end{equation}\\] and the golden ratio \\(\\varphi = \\frac{1 + \\sqrt{5}}{2}.\\) The general algorithm defines a lattice of points on the square \\(\\left[ 0,1 \\right)^2\\), which is subsequently mapped to a unit sphere using the Lambert cylindrical equal-area projection \\(\\Lambda\\): \\[\\begin{equation}\n    \\Lambda(x,y) = \\begin{bmatrix} \\sqrt{1-(2y-1)^2}\\cdot\\cos\\left(2\\pi x\\right) \\\\ \\sqrt{1-(2y-1)^2}\\cdot\\sin\\left(2\\pi x\\right), 2y-1 \\end{bmatrix}\n\\end{equation}\\] in Cartesian coordinates, and \\[\\begin{equation}\n    \\Lambda(x,y) = \\begin{bmatrix}\\cos^{-1}(2y-1) \\\\ 2\\pi x\\end{bmatrix} = \\begin{bmatrix}\\varphi\\\\ \\vartheta\\end{bmatrix}\n\\end{equation}\\] in spherical coordinates. The points \\((x, y)\\) on the square \\(\\left[ 0,1 \\right)^2\\) are created through \\[\\begin{equation}\n    (\\tilde x, y)_{F_k} = \\left( \\frac{iF_{k-1}}{F_k} , \\frac{i}{F_k} \\right), \\qquad 0 \\leq i \\leq F_k\n\\end{equation}\\] where \\(x= \\tilde x- \\lfloor \\tilde x\\rfloor\\) as just the fractional part of \\(\\tilde x\\) (Hardin et al., 2016). While this implementation can only be applied for \\(N+1\\) elements, where \\(N \\in \\{ F_k \\}\\), a more general approach involves the golden ratio \\(\\varphi\\). Based on Binet’s formula the calculation of \\((x, y)\\) can be changed to \\[\\begin{equation}\n    (\\tilde x, y)_{N} = \\left( \\frac{i}{\\varphi}, \\frac{i}{N} \\right), \\qquad 0 \\leq i \\leq N.\n\\end{equation}\\]\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nAnalysis of Point Distribution\nAlmost all points have equal distances from one another. Numerical analyses of the Fibonacci-based spiral sequence \\(\\omega_N\\) in Hardin et al. (2016) found minimal separations to appear at the poles with value \\(|x_1 - x_4|, \\, x_i\\in\\omega_N\\) and maximum hole in the lattice to occurs in the triangle \\((x_2, x_3, x_5)\\)."
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#healpix",
    "href": "documentation/fundamentals/numerical_grids.html#healpix",
    "title": "2.2 Numerical Grids",
    "section": "HEALPix",
    "text": "HEALPix\nHEALPix, Hierarchical Equal Area iso-Latitude Pixelization (Hardin et al., 2016), was developed by NASA to have three distinct properties, which are that\n\nthe sphere is hierarchically tessellated into curvilinear quadrilaterals,\nthe pixelization is an equal area partition of \\(\\mathbb{S}^2\\), and\nthe point sets are distributed along fixed lines of latitude.\n\n\nCoordinate Calculation\nThe generation of such points firstly requires a division of the sphere into twelve equal-area, four-sided pixels. These areas are defined through the following boundaries: \\[\\begin{align}\n    |\\cos\\varphi| &gt; \\frac{2}{3}, & \\qquad \\vartheta= m\\frac{\\pi}{2},\\\\\n    \\cos\\varphi= \\frac{-2-4m}{3} + \\frac{8\\vartheta}{3\\pi}, & \\qquad \\frac{m\\pi}{2} \\leq \\vartheta\\leq \\frac{(m+1)\\pi}{2}, \\\\\n    \\cos\\varphi= \\frac{2-4m}{3}-\\frac{8\\vartheta}{3\\pi}, & \\qquad \\frac{-(m+1)\\pi}{2} \\leq \\vartheta\\leq \\frac{-m\\pi}{2}.\n\\end{align}\\] with \\(m \\in \\left\\{0,1,2,3\\right\\}\\). These pixels can be further partitioned into a \\(k \\times k\\) grid of sub-pixels of the same shape and area. The points of the set are located in the centers of each pixel. The subdivision leads to \\(k\\) iso-latitudinal rings at the polar region \\(|\\cos\\varphi|&gt;2/3\\): \\[\\begin{equation}\n    |\\cos\\varphi_i|=1-\\frac{i^2}{3k^2}, \\qquad \\vartheta_j=\\frac{\\pi}{2i} \\left( j - \\frac{1}{2} \\right),\n\\end{equation}\\] with every \\(i\\)-th ring having \\(4i\\) equally spaced points. Closer to the equatorial region, \\(2k-1\\) iso-latitudinal rings with \\(4k\\) points each emerge. These points are indexed by \\(k \\leq |i| \\leq 2k\\) and \\(1 \\leq j \\leq 4k\\): \\[\\begin{equation}\n    |\\cos\\varphi_i| = \\frac{4}{3} - \\frac{2i}{3k}, \\qquad \\vartheta_j = \\frac{\\pi}{2k} \\left( j - \\frac{s}{2} \\right)\n\\end{equation}\\] with \\(s = (i-k+1) \\mod 2\\), which describes the phase shift between the rings. This configuration produces a set of \\(N=12k^2\\) points (Hardin et al., 2016).\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured",
    "href": "documentation/fundamentals/numerical_grids.html#structured",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-1",
    "href": "documentation/fundamentals/numerical_grids.html#structured-1",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured\nThe local, structured, three-dimensional grid is discretizing the volume of a rectangular domain into \\(N_x\\times N_y\\times N_z\\) grid elements. If not otherwise specified, the horizontal resolution is constant over the entire domain, being \\[\\begin{equation}\n    \\frac{x_{max} - x_{min}}{N_x} \\times \\frac{y_{max} - y_{min}}{N_y}.\n\\end{equation}\\] The vertical resolution can either be constant over the entire domain or be distributed exponentially. Due to its structured, rectangular nature, the local structured grid is defined in cartesian coordinates in cartesian elements: \\(\\boldsymbol{\\mathbf{x}}= \\left[x, y, z\\right]^T\\).\n\n\n LocalStructured3DGrid: Eqs. \\(\\eqref{eq:local_structure_3d_grid_x}\\), \\(\\eqref{eq:local_structure_3d_grid_y}\\), and \\(\\eqref{eq:local_structure_3d_grid_z_regular}\\) or \\(\\eqref{eq:local_structure_3d_grid_z_exp}\\)\n\nCoordinate Calculation\nThe horizontal discretization of the local structured grid is simply dividing the surface into \\(N_x\\) and \\(N_y\\) equal, rectangular elements. With the grid points of each element being centered in the horizontal plane, the individual coordinates can be calculated as \\[\\begin{alignat}{3}\n    x_i &= x_{min} + \\frac{x_{max} - x_{min}}{N_x} \\cdot \\left(i - \\frac{1}{2}\\right) & \\quad\\text{for } i \\in \\{1, \\dots, N_x\\} \\label{eq:local_structure_3d_grid_x}\\\\\n    y_j &= y_{min} + \\frac{y_{max} - y_{min}}{N_y} \\cdot \\left(j - \\frac{1}{2}\\right) & \\quad\\text{for } j \\in \\{1, \\dots, N_y\\}. \\label{eq:local_structure_3d_grid_y}\n\\end{alignat}\\]\nThe heights of the local structured grid can be regularly distributed like the horizontal discretization shown in Eqs. \\(\\eqref{eq:local_structure_3d_grid_x}\\) and \\(\\eqref{eq:local_structure_3d_grid_y}\\) or be distributed exponentially. The former results in the definition of the \\(N_z\\) vertical grid elements as \\[\\begin{equation}\n    z_k = z_{min} + \\frac{z_{max} - z_{min}}{N_z} \\cdot \\left(k - \\frac{1}{2}\\right) \\quad\\text{for } k \\in \\{1, \\dots, N_z\\}. \\label{eq:local_structure_3d_grid_z_regular}\n\\end{equation}\\] Note that the \\(z_k\\) grid points are also vertically centered in their respective grid element, with Eq. \\(\\eqref{eq:local_structure_3d_grid_z_regular}\\) creating an equal spacing between the grid elements.\nThe second option distributes the heights of the local structured grid exponentially. To derivate the height of the \\(k\\)-th vertical grid element \\(z_k\\), we start at the basic 3-free-parameter exponential function: \\[\\begin{equation}\n    z_k = a + b \\exp\\left(c\\right)^k.\n\\end{equation}\\] We can now add two constraints to this function: first, the bottom of the local grid, which is the zeroth element of the grid, is \\(z_0=0\\), and the last element of the grid at the \\(k = N_z\\) index has to be at the maximum height of the grid, \\(z_{N_z} = z_{max}\\). With these two conditions, two of the three free parameters can be solved, leaving only the exponential shape parameter \\(c\\): \\[\\begin{equation}\n    z_k = z_{max} \\cdot \\frac{\\exp\\left(c\\right)^k - 1}{\\exp\\left(c\\right)^{N_z} - 1}.\n\\end{equation}\\] The local, structured grids in this work add another condition to the function to further simplify it and to ensure similar spacings for varying grid sizes, which is \\(c = 1/N_z\\), which further reduces the equation to \\[\\begin{equation}\n    z_k = z_{max} \\cdot \\frac{\\exp\\left(\\frac{1}{N_z}\\right)^k - 1}{e - 1}  \\quad\\text{for } k \\in \\{1, \\dots, N_z\\}\n\\end{equation}\\] with Euler’s constant \\(e\\). This addition leads to an equal ratio between the maximum grid height and the first element, invariant of the number of vertical grid elements. If more control over the slope of the exponential function is necessary, other simplifications for the parameter \\(c\\) can also be chosen like \\(c=2/N_z\\). Note that for increasing values of \\(c\\), the “curviness” of the distribution of \\(z_k\\) increases, which leads to smaller elements close to the bottom and bigger elements close to the top of the grid. To also have the grid points vertically (exponentially)&lt; centered in their respective element, the exponent \\(k\\) can be shifted by \\(0.5\\) downwards to \\[\\begin{equation}\n    z_k = z_{max} \\cdot \\frac{\\exp\\left(\\frac{1}{N_z}\\right)^{\\left(k - \\frac{1}{2}\\right)} - 1}{e - 1}  \\quad\\text{for } k \\in \\{1, \\dots, N_z\\},  \\label{eq:local_structure_3d_grid_z_exp}\n\\end{equation}\\] Figure 3 shows the exponential distribution of heigh elements using the approach described above. Figure 3 (a) displays the influence of varying numbers of vertical grid elements from the bottom to the top, while Figure 3 (b) presents its dependence on the shape factor \\(c\\).\n\n\n coords: Eqs. \\(\\eqref{eq:local_structure_3d_grid_x}\\), \\(\\eqref{eq:local_structure_3d_grid_y}\\), and \\(\\eqref{eq:local_structure_3d_grid_z_regular}\\) or \\(\\eqref{eq:local_structure_3d_grid_z_exp}\\)   surfacecoords: identical to the first two Eqs. used in coords, at \\(z= z_{min}\\)\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Exponential distribution of grid elements for varying number of grid points \\(N_z\\).\n\n\n\n\n\n\n\n(b) Exponential distribution of grid elements for varying shape factors \\(c\\).\n\n\n\n\nFigure 3: Exemplary visualization of the exponential distribution of vertical grid elements of the local structured three-dimensional grid for varying number of grid points \\(N_z\\) and shape factors \\(c\\).\n\n\n\n\n\n\n\n\n exponential_heights.svg \n\n\n\n\nThe total of Eqs. \\(\\eqref{eq:local_structure_3d_grid_x}\\), \\(\\eqref{eq:local_structure_3d_grid_y}\\), and \\(\\eqref{eq:local_structure_3d_grid_z_regular}\\) or \\(\\eqref{eq:local_structure_3d_grid_z_exp}\\) define the local structured grid in three dimensions. Figure 4 shows two examples of these discretization schemes, Figure 4 (a) with a regular distribution of the vertical grid elements and Figure 4 (b) with an exponential distribution of the vertical grid elements.\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Regular vertical spacing.\n\n\n\n\n\n\n\n(b) Exponential vertical spacing.\n\n\n\n\nFigure 4: Exemplary local structured 3D grid of a cube with a total of \\(5 \\times 2 \\times 7\\) elements in \\(x\\), \\(y\\), and \\(z\\) direction.\n\n\n\n\nusing .ExESS\nusing CairoMakie\n\n#::. functions\nfunction ls3dgrid(;xrange=(0,10), yrange=(0,10), zrange=(0,10), N_x=5, N_y=5, N_z=5)\n    # prepare figure & axis\n    fig = Figure(; resolution=(450,400))\n    ax = Axis3(fig[1,1];\n        aspect = :data)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    xlims!(ax, -2, 10)\n    ylims!(ax, -2, 10)\n\n    # create grid and get grid points\n    grid = LocalStructured3DGrid(xrange, yrange, zrange, N_x, N_y, N_z)\n    X = hcat(vec.(grid.coords)...)'\n\n    # grid points\n    scatter!(ax, X[:,1], X[:,2], X[:,3]; color=:black, markersize=6)\n\n    # lines\n    for x in range(xrange[1], xrange[2], N_x+1), z in range(zrange[1], zrange[2], N_z+1)\n        lines!(ax, [x, x], [yrange[1], yrange[2]], [z, z]; color=(:black, 0.5))\n    end\n    for x in range(xrange[1], xrange[2], N_x+1), y in range(yrange[1], yrange[2], N_y+1)\n        lines!(ax, [x, x], [y, y], [zrange[1], zrange[2]]; color=(:black, 0.5))\n    end\n    for y in range(yrange[1], yrange[2], N_y+1), z in range(zrange[1], zrange[2], N_z+1)\n        lines!(ax, [xrange[1], xrange[2]], [y, y], [z, z]; color=(:black, 0.5))\n    end\n\n    # brackets (only work with default values for xrange, yrange, zrange)\n    bracket!(ax, Point3f(0,0,0), Point3f(10,0,0); orientation=:down, offset=10, text=L\"N_x=%$N_x\")\n    bracket!(ax, Point3f(0,0,0), Point3f(0,10,0); orientation=:down, offset=10, text=L\"N_y=%$N_y\")\n    bracket!(ax, Point3f(10,0,0), Point3f(25.5,18,0); orientation=:down, offset=10, text=L\"N_z=%$N_z\")\n\n    # save figure\n    save(joinpath(@__DIR__, \"ls3dgrid.pdf\"), fig)\n    save(joinpath(@__DIR__, \"ls3dgrid.svg\"), fig)\n    save(joinpath(@__DIR__, \"ls3dgrid.png\"), fig, px_per_unit=4)\nend\nfunction ls3dgrid_exp(;xrange=(0,10), yrange=(0,10), zrange=(0,10), N_x=5, N_y=5, N_z=5, c=2)\n    # prepare figure & axis\n    fig = Figure(; resolution=(450,400))\n    ax = Axis3(fig[1,1];\n        aspect = :data)\n    hidedecorations!(ax)\n    hidespines!(ax)\n    xlims!(ax, -2, 10)\n    ylims!(ax, -2, 10)\n\n    # create grid and get grid points\n    grid = LocalStructured3DGrid_Exponential(xrange, yrange, zrange, N_x, N_y, N_z; c=c)\n    X = hcat(vec.(grid.coords)...)'\n\n    # grid points\n    scatter!(ax, X[:,1], X[:,2], X[:,3]; color=:black, markersize=6)\n\n    # lines\n    for x in range(xrange[1], xrange[2], N_x+1), k in 1:N_z+1\n        Z = unique(X[:,3] |&gt; Vector{Float16})\n        z = k == 1 ? zrange[1] : k == N_z+1 ? zrange[2] : (Z[k-1] + Z[k])/2\n        lines!(ax, [x, x], [yrange[1], yrange[2]], [z, z]; color=(:black, 0.5))\n    end\n    for x in range(xrange[1], xrange[2], N_x+1), y in range(yrange[1], yrange[2], N_y+1)\n        lines!(ax, [x, x], [y, y], [zrange[1], zrange[2]]; color=(:black, 0.5))\n    end\n    for y in range(yrange[1], yrange[2], N_y+1), k in 1:N_z+1\n        Z = unique(X[:,3] |&gt; Vector{Float16})\n        z = k == 1 ? zrange[1] : k == N_z+1 ? zrange[2] : (Z[k-1] + Z[k])/2\n        lines!(ax, [xrange[1], xrange[2]], [y, y], [z, z]; color=(:black, 0.5))\n    end\n\n    # brackets (only work with default values for xrange, yrange, zrange)\n    bracket!(ax, Point3f(0,0,0), Point3f(10,0,0); orientation=:down, offset=10, text=L\"N_x=%$N_x\")\n    bracket!(ax, Point3f(0,0,0), Point3f(0,10,0); orientation=:down, offset=10, text=L\"N_y=%$N_y\")\n    bracket!(ax, Point3f(10,0,0), Point3f(25.5,18,0); orientation=:down, offset=10, text=L\"N_z=%$N_z\")\n\n    # save figure\n    save(joinpath(@__DIR__, \"ls3dgrid_exp.pdf\"), fig)\n    save(joinpath(@__DIR__, \"ls3dgrid_exp.svg\"), fig)\n    save(joinpath(@__DIR__, \"ls3dgrid_exp.png\"), fig, px_per_unit=4)\nend\n\nls3dgrid(; N_x=5, N_y=2, N_z=7)\nls3dgrid_exp(; N_x=5, N_y=2, N_z=7)\n\n\n\n regular.pdf   regular.svg   regular.png \n exponential.pdf   exponential.svg   exponential.png \n\n\n\n\nAs with the grids introduced before, it is helpful to introduce another index, which combines the three indices \\(i\\), \\(j\\), and \\(k\\) into a single index \\(l \\in \\left\\{ 1, \\dots, N_x\\cdot N_y\\cdot N_z\\right\\}\\), since it closer represents the way the grid is stored and used numerically. The mapping from the three-dimensional index \\(l\\) to the three-dimensional indices \\(i\\), \\(j\\), and \\(k\\) is: \\[\\begin{equation}\n    l = (k - 1) \\cdot N_x\\cdot N_y+ (j - 1) \\cdot N_x+ i.\n\\end{equation}\\] In the example above in Figure 4, a total number of \\(70\\) grid points are created in the local, structured, three-dimensional grid as \\(\\boldsymbol{\\mathbf{x}}_l\\) for \\(l \\in \\left\\{ 1, \\dots, 70 \\right\\}\\).\n\n\nArea and Volume Calculation\nThe area and volume calculations make use of the above-introduced common index, \\(l\\): \\[\\begin{align}\n    \\Delta x_i &= \\frac{x_{max} - x_{min}}{N_x} \\qquad \\text{for } i \\in \\left\\{1, \\dots, N_x\\right\\} \\label{eq:ls3dgrid_dx} \\\\[2mm]\n    \\Delta y_j &= \\frac{y_{max} - y_{min}}{N_y}  \\qquad \\text{for } j \\in \\left\\{1, \\dots, N_y\\right\\} \\label{eq:ls3dgrid_dy} \\\\[2mm]\n    \\Delta z_k &= \\begin{cases}\n        \\frac{z_2 - z_1}{2} + \\left(z_1 - z_{min} \\right) & \\text{for } k = 1 \\\\\n        \\frac{z_{k + 1} - z_{k - 1}}{2} & \\text{for } k \\in \\{2, \\dots, N_z- 1\\} \\\\\n        \\frac{z_{N_z} - z_{N_z- 1}}{2} + \\left( z_{max} - z_{N_z} \\right) & \\text{for } k = N_z\n    \\end{cases} \\label{eq:ls3dgrid_dz} \\\\[2mm]\n    \\Rightarrow\\quad A_l &= \\Delta x_i \\cdot \\Delta y_j \\label{eq:ls3dgrid_area} \\\\\n    \\Rightarrow\\quad V_l &= A_l \\cdot \\Delta z_k \\label{eq:ls3dgrid_volume}\n\\end{align}\\]\n\n\n\n\n\n\nVolume-Closure\n\n\n\n\n\nOne can easily check that the volume calculation presented in Eqs. \\(\\eqref{eq:ls3dgrid_dx}\\) to \\(\\eqref{eq:ls3dgrid_volume}\\) are indeed covering the entire volume defined by the coordinate boundaries \\(x_{min}\\), \\(x_{max}\\), \\(y_{min}\\), \\(y_{max}\\), \\(z_{min}\\), and \\(z_{max}\\) by summing up all volumes \\(V_l\\):\n\\[\\begin{align*}\n    V &= \\sum_{l = 1}^{N_x\\cdot N_y\\cdot N_z} V_l \\\\\n    &= \\sum_{i = 1}^{N_x} \\sum_{j = 1}^{N_y} \\sum_{k = 1}^{N_z} \\Delta x_i \\cdot \\Delta y_j \\cdot \\Delta z_k \\\\\n    &= \\left(\\frac{x_{max} - x_{min}}{N_x} \\cdot N_x\\right) \\cdot \\left(\\frac{y_{max} - y_{min}}{N_y} \\cdot N_y\\right) \\cdot \\sum_{k = 1}^{N_z} \\Delta z_k \\\\\n\\end{align*}\\]\nWhile the first two sums are trivial, the third can also be expanded by including all terms from the cases of Eq. \\(\\eqref{eq:ls3dgrid_dz}\\), which conveniently cancels out all grid points \\(z_k\\) and leaves only the boundaries: \\(z_{max} - z_{min}\\):\n\\[\\begin{equation*}\n    V = \\left(x_{max} - x_{min} \\right) \\cdot \\left(y_{max} - y_{min} \\right) \\cdot \\left(z_{max} - z_{min} \\right).\n\\end{equation*}\\]\n\n\n\n\n\nContinuous to Discrete Mapping"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-topography",
    "href": "documentation/fundamentals/numerical_grids.html#structured-topography",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Topography",
    "text": "Structured, Topography\nplaceholder"
  },
  {
    "objectID": "documentation/fundamentals/properties_data.html#atomic-weights",
    "href": "documentation/fundamentals/properties_data.html#atomic-weights",
    "title": "2.7 General Properties and Data",
    "section": "Atomic Weights",
    "text": "Atomic Weights\n\n Table LaTeX\n\n\n\n\nTable 1: Subset of standard atomic weights by Prohaska et al. (2022) relevant to this work. The values are provided either as an interval (indicated with to) or as a single value with some measurement uncertainty and natural variation (indicated with +/-).\n\n\n\n\n\n\n\n\n\n\n#\nElement\nSymbol\nValue\n\n\n\n\n\n\n1\nHydrogen\nH\n1.007 840\nto\n1.008 110\n\n\n2\nHelium\nHe\n4.002 602\n+/-\n0.000 002\n\n\n6\nCarbon\nC\n12.009 600\nto\n12.011 600\n\n\n8\nOxygen\nO\n15.999 030\nto\n15.999 770\n\n\n10\nNeon\nNe\n20.179 700\n+/-\n0.000 600\n\n\n18\nArgon\nAr\n39.792 000\nto\n39.963 000\n\n\n\n\n\n\n\\begin{table}[tb]\n    \\centering\n    \\caption{Subset of standard atomic weights by \\citet{Prohaska2022} relevant to this work. The values are provided either as an interval (indicated with \\emph{to}) or as a single value with some measurement uncertainty and natural variation (indicated with $\\pm$.)}\n    \\begin{tabularx}{.99\\textwidth}{r X l X c X}\n        \\toprule\n        \\textbf{\\#} & \\textbf{Element} & \\textbf{Symbol} & \\multicolumn{3}{c}{Standard Atomic Weight} \\\\\n        \\midrule\n         1 & Hydrogen & \\ce{H}    & \\num{1.007840}   & to    & \\num{1.008110} \\\\\n         2 & Helium   & \\ce{He}   & \\num{4.002602}   & $\\pm$ & \\num{0.000002} \\\\\n         6 & Carbon   & \\ce{C}    & \\num{12.009600}  & to    & \\num{12.011600} \\\\\n         8 & Oxygen   & \\ce{O}    & \\num{15.999030}  & to    & \\num{15.999770} \\\\\n        10 & Neon     & \\ce{Ne}   & \\num{20.179700}  & $\\pm$ & \\num{0.000600} \\\\\n        18 & Argon    & \\ce{Ar}   & \\num{39.792000}  & to    & \\num{39.963000} \\\\\n        \\bottomrule\n    \\end{tabularx}\n    \\label{tab:atomic_weights}\n\\end{table}\nThe code above requires the following LaTeX packages: booktabs, mhchem, multirow, siunitx, and tabularx. Additionally, the reference to Prohaska2022 must be available in the respective .bib file."
  },
  {
    "objectID": "documentation/introduction/introduction.html",
    "href": "documentation/introduction/introduction.html",
    "title": "1. Introduction",
    "section": "",
    "text": "Space exploration has always captivated humanity’s imagination, driving scientific inquiry and technological advancement to unprecedented heights. While the Moon’s surface has been a focal point of human exploration, its tenuous exosphere, a fragile envelope of particles and gases, has long remained an understudied frontier. Recent decades have witnessed remarkable strides in our understanding of extraterrestrial exospheres, with a particular focus on the Moon’s exosphere and its intricate interactions with the lunar surface.\nAdvances in space exploration have unveiled the Moon’s exosphere as a realm of astonishing complexity. Notable missions such as the Lunar Reconnaissance Orbiter (LRO) have played a pivotal role in unraveling the mysteries of the lunar exosphere. The orbiter mission has not only provided the most highly resolved images of the Moon’s surface, see Fig. 1 showing high-resolution mosaic images of the lunar’s north and south poles, but the Lyman Alpha Mapping Project (LAMP) (Gladstone et al., 2009) aboard LRO has studied the exosphere by analyzing the scattering of ultraviolet sunlight. Additionally, the Lunar Atmosphere and Dust Environment Explorer (LADEE) mission’s Neutral Mass Spectrometer (NMS) (Benna et al., 2015) provided valuable insights into the composition of the exosphere and its temporal variations. These missions collectively painted a new picture of the Moon - a dynamic world with a delicate exosphere shaped by intricate surface interactions.\nHowever, the first endeavors to investigate the lunar exosphere were already made decades earlier, during the Apollo program, during which the Lunar Atmosphere Composition Experiment (LACE) instrument was deployed on the Moon’s surface by Apollo 17 as part of the Apollo Lunar Surface Experiment Package (ALSEP) (Chang, 1972). LACE marked the first direct detection of exospheric species, capturing trace amounts of noble gases and demonstrating the existence of a lunar atmosphere. This historic endeavor laid the foundation for our present understanding, highlighting the complexity of the lunar exosphere and the need for continued exploration.\nIn the broader scope of planetary science, beyond the lunar realm, lies a captivating tapestry of exospheric phenomena across our solar system. Among these, Mercury, the closest planet to the Sun, has beckoned explorers and researchers alike. Pioneering missions such as NASA’s MESSENGER (MErcury Surface, Space ENvironment, GEochemistry, and Ranging) have revealed the intricate details of Mercury’s exosphere. MESSENGER’s observations have unraveled the complex interplay between the planet’s surface and its tenuous envelope of gases, shedding light on the origins of exospheric constituents and their dynamic behavior in response to solar wind interactions. Through these missions, the study of exospheres extends its reach beyond Earth’s celestial companion, contributing valuable insights to the broader understanding of planetary atmospheres and their interactions with the space environment."
  },
  {
    "objectID": "documentation/introduction/introduction.html#sec-sota",
    "href": "documentation/introduction/introduction.html#sec-sota",
    "title": "1. Introduction",
    "section": "State of the Art",
    "text": "State of the Art\nOne of the first modelers of the lunar exosphere was Hodges et al. (1973), who analyzed light noble gases as well as volatile molecular hydrogen and compared their results with data from the Apollo missions. Their Monte Carlo approach of tracking individual particles through the tenuous atmosphere until eventually lost to one of the implemented loss mechanisms was pioneering work that still inspires new models today. With Chamberlain (1963), Armand (1977), and Huebner et al. (1992) setting the theoretical foundation of exospheric density projections, thermal velocity distributions, and lunar exospheric photoreaction rates, respectively, models became increasingly adapted to predicting number densities in surface-bounded exospheres.\nWhile previously, only single-species simulations with mostly noble gases were performed, Crider & Vondrak (2002) were among the first to investigate the highly reactive hydrogen exosphere, which includes reaction pathways to allow conversions from atomic hydrogen to more complex molecules like water. Their research led to a heightened interest in the role of the planetary surface in exosphere densities and compositions. Farrell et al. (2015), Farrell et al. (2017), B. M. Jones et al. (2018), B. Jones et al. (2021), Tucker et al. (2018), Tucker et al. (2021), Grumpe et al. (2019) are among the leading researchers to investigate the proton/hydrogen interaction with lunar regolith, trying to untangle the highly complex physical and chemical reaction environment of the lunar surface.\nA more complete list of relevant publications about the state-of-the-art modeling approaches regarding surface-bounded exosphere, their respective surface, various involved processes, and auxiliary research can be found in Table 1.\n\n\n\n\n\n\n\nState-of-the-Art - Table 1\n\n\n\n\n\n\n Table LaTeX\n\n\n\n\nTable 1: List of relevant publications about modeling of surface-bounded exospheres, their respective surfaces, or auxiliary research.\n\n\n\n\n\n\nReference\nDescription / Highlights\n\n\n\n\nChamberlain (1963)\nTHEORY EXOSPHERE\n“Planetary coronae and atmospheric evaporation”\n\nanalytical model of density distributions in planetary atmospheres/exospheres\nassumes an isothermal, spherically symmetric, and globally uniform atmosphere\ndeveloped a scaled barometric scaling for exospheric number densities at varying altitudes\n\n\n\nVogel (1966)\nTHEORY EXOSPHERE\n“Molecular fluxes in the lunar atmosphere”\n\ntheoretical model of molecular fluxes in the lunar exosphere\nproposed an analytical framework to calculate elliptical trajectories and the respective landing positions on the Moon\n\n\n\nHodges et al. (1973)\nEXOSPHERE\n“Composition and dynamics of lunar atmosphere”\n\nfirst \\(\\ce{H2}, \\ce{He}, \\ce{Ne}\\), and \\(\\ce{Ar}\\) model of the lunar exosphere\ncompared model results with preliminary Apollo 17 data\n\n\n\nArmand (1977)\nTHEORY\n“Classical theory of desorption rate velocity distribution of desorbed atoms; Possibility of a compensation effect”\n\nproposed the theory of desorption velocity distributions (Maxwell-Boltzmann Flux Distribution, MBFD)\n\n\n\nSmith et al. (1978)\nEXOSPHERE\n“Monte Carlo modeling of exospheric bodies: Mercury”\n\nMonte Carlo model of Mercury’s exosphere\nMBFD distributed particle velocities\n\n\n\nHuebner et al. (1992)\nTHEORY\n“Solar photo rates for planetary atmospheres and atmospheric pollutants”\n\nprovides a comprehensive overview of photoreaction rates widely used for modeling the lunar exosphere\n\n\n\nButler (1997)\nTHEORY EXOSPHERE\n“The migration of volatiles on the surfaces of Mercury and the Moon”\n\nMonte Carlo exosphere model of Mercury and the Moon, specifically \\(\\ce{H2O}\\) and \\(\\ce{CO2}\\)\nproposed an analytic function to approximate the lunar surface temperature\nextension of Vogel (1966) trajectory calculation\n\n\n\nCrider & Vondrak (2002)\nEXOSPHERE\n“Hydrogen migration to the lunar poles by solar wind bombardment of the Moon”\n\nMonte Carlo simulation of exospheric hydrogen migration on the Moon\nlists a variety of conversion paths for solar wind protons to \\(\\ce{H}\\), \\(\\ce{H2}\\), \\(\\ce{OH}\\), and \\(\\ce{H2O}\\)\ncomments on the high inaccuracies of the implementation of the chemical and physical reactions\n\n\n\nChaufray et al. (2009)\nEXOSPHERE\n“Lunar Argon cycle modeling”\n\nMonte Carlo model of the lunar argon exosphere\ninvestigated the accumulation of \\(\\ce{Ar}\\) in PSRs\n\n\n\nPoppe et al. (2013)\nEXOSPHERE\n“The self-sputtered contribution to the lunar exosphere”\n\nfirst self-sputtering model of the lunar exosphere\nself-sputtering is a significant source of neutrals (locally comparable to solar wind and micrometeoroid bombardment)\n\n\n\nGrava et al. (2014)\nEXOSPHERE\n“Lunar exospheric argon modeling”\n\nMonte Carlo model of the lunar argon exosphere, based on Chaufray et al. (2009)\ncompared model predictions with LACE, LAMP, and LADEE measurements\nfound that charge exchange is a relevant argon loss process and that cold-trapping losses are comparable to ionization fluxes\n\n\n\nSchorghofer (2014)\nEXOSPHERE\n“Migration calculations for water in the exosphere of the Moon: dusk-dawn asymmetry, heterogeneous trapping, and D/H fractionation”\n\nMonte Carlo model of exospheric water migration of the Moon, based on Butler (1997)\npresents a dusk-dawn asymmetry of hydrogenous species\n\n\n\nFarrell et al. (2015)\nSURFACE\n“Solar wind implantation into lunar regolith: hydrogen retention in a surface with defects”\n\nMonte Carlo model of solar wind implantation into the lunar surface regolith\nsystematically studied distributions of activation energies to simulate hydrogen retention and \\(\\ce{OH}\\) formation\n\n\n\nHurley et al. (2015)\nTHEORY\n“An analytic function of lunar surface temperature for exospheric modeling”\n\npresents an analytic approximation of the lunar surface temperatures based on Diviner measurements\nimproved the analytical approach of Butler (1997)\ntemperature model does not include topographical, temporal, or compositional features\n\n\n\nPrem et al. (2015)\nEXOSPHERE\n“Transport of water in a transient impact-generated lunar atmosphere”\n\nhybrid DSMC approach to investigate water transport in impact-generated lunar atmosphere, combining a continuum description of the dense plume with a Monte Carlo model of the tenuous water vapor exosphere\nunsteady and three-dimensional simulations\n\n\n\nHurley et al. (2016)\nEXOSPHERE\n“Understanding temporal and spatial variability of the lunar helium atmosphere using simultaneous observations from LRO, LADEE, and ARTEMIS”\n\nMonte Carlo model of the lunar surface-bounded helium exosphere\nsuggests that endogenic helium provides roughly a third of the Moon’s exospheric helium\nbuilt on previous works by Killen & Ip (1999), Hodges et al. (1973), Butler (1997), Grava et al. (2014), and more\n\n\n\nMoores (2016)\nEXOSPHERE\n“Lunar water migration in the interval between large impacts: heterogeneous delivery to permanently shadowed regions, fractionation, and diffusive barriers”\n\nMonte Carlo simulation to examine water delivery to lunar PSRs\nimpactor water delivery (based on Prem et al. (2015)) and ballistic migration included as water sources\nexplicitly modeled the high-latitude regions, including several PSRs\nextended Crider & Vondrak (2002) and Schorghofer (2014) for higher latitudes\n\n\n\nFarrell et al. (2017)\nSURFACE\n“The statistical mechanics of solar wind hydroxylation at the Moon, within lunar magnetic anomalies, and at Phobos”\n\nextension of the previous model (Farrell et al., 2015), presents a formalism to statistically describe hydrogen implantation into the lunar surface and subsurface diffusion of \\(\\ce{H}\\) using a Monte Carlo simulation\nused distributed activation energies in the physical model\n\n\n\nHurley et al. (2017)\nEXOSPHERE\n“Contributions of solar wind and micrometeoroids to molecular hydrogen in the lunar exosphere”\n\nMonte Carlo model (extension of previous model (Hurley et al., 2016)) to investigate spatial distribution of \\(\\ce{H2}\\) in the lunar exosphere\nexamined the contributions of micrometeoroids and solar wind particles\nfound that micrometeoroids are an insufficient source to reproduce LAMP \\(\\ce{H2}\\) measurements\n\n\n\nJ. A. Kegerreis et al. (2017)\nEXOSPHERE\n“Evidence for a localized source of the argon in the lunar exosphere”\n\nMonte Carlo model of the lunar \\(\\ce{Ar}\\) exosphere, based on the works of Smith et al. (1978), Hodges et al. (1973), and Butler (1997)\nincludes seasonal effects to study long-term variations\n\n\n\nB. M. Jones et al. (2018)\nSURFACE\n“Solar wind-induced water cycle on the Moon”\n\nchemical kinetics model of lunar surficial \\(\\ce{OH}\\) and \\(\\ce{H2O}\\), investigating the long-term evolution\nbased on solar wind proton delivery as the main source of the simulated water cycle\nfocuses on recombinative desorption as the primary water formation pathway\n\n\n\nPrem et al. (2018)\nTHEORY SURFACE\n“The influence of surface roughness on volatile transport on the Moon”\n\nnumerical thermal model for a rough lunar surface\nextension of Hurley et al. (2015) thermal model\n\n\n\nTucker et al. (2018)\nEXOSPHERE SURFACE\n“Solar wind implantation into the lunar regolith: Monte Carlo simulations of H retention in a surface with defects and the H2 exosphere”\n\nMonte Carlo-based simulation of solar wind implantation into the lunar lunar regolith to study \\(\\ce{H}\\) retention and implications for the \\(\\ce{H2}\\) exosphere\nmodeled hydrogen diffusion and recombination to \\(\\ce{H2}\\)\nincludes Gaussian distributions of activation energies\nbased on models by Killen & Ip (1999), Farrell et al. (2015), Farrell et al. (2017), and Hurley et al. (2017)\n\n\n\nGrumpe et al. (2019)\nSURFACE\n“Time-of-day-dependent behavior of surficial lunar hydroxyl/water: Observations and modeling”\n\nreaction kinetics model as an extension of Farrell et al. (2015) and Farrell et al. (2017) Monte Carlo simulation\ninvestigates \\(\\ce{H}\\), \\(\\ce{OH}\\), and \\(\\ce{H2O}\\) concentrations, based on both solar wind and micrometeoroid influx\nincludes a 1D lateral heat conduction model with surface roughness dependence\n\n\n\nKillen et al. (2019)\nEXOSPHERE\n“The Lunar Neon Exosphere Seen in LACE data”\n\nMonte Carlo simulation of the lunar neon exosphere\ncomparison with Apollo 17’s LACE data\nsuggests that theoretical photodissociation losses are too low to reproduce \\(\\ce{Ne}\\) measurements\n\n\n\nPrem et al. (2019)\nEXOSPHERE\n“Coupled DSMC-Monte Carlo radiative transfer modeling of gas dynamics in a transient impact-generated lunar atmosphere”\n\nextension of the Monte Carlo model of Prem et al. (2015) to include the influence of radiative heat transfer and shielding of an impact-generated atmosphere\napplies new model to simulate a \\(\\ce{H2O}\\) exosphere\nfinds that gas-gas radiative transfer is playing an important role, significantly influencing water vapor transport to the night-side\nincludes a chapter on numerical validations of the presented model\n\n\n\nGrava et al. (2020)\nEXOSPHERE\n“LRO/LAMP observations of the lunar helium exosphere: constraints on thermal accommodation and outgassing rate”\n\nMonte Carlo simulation of lunar exospheric helium to investigate source rates and thermal accommodation\ncompares modelled \\(\\ce{He}\\) densities with LAMP measurements\nsuggests the best description of lunar helium assuming full thermal accommodation and an MBFD distribution of kinetic energies\nfinds that endogenic \\(\\ce{He}\\) provides about 20% of the lunar helium exosphere as compared to solar wind source\n\n\n\nJ. Kegerreis (2020)\nTHEORY EXOSPHERE\n“Planetary giant impacts, simulating collisions and their consequences”\n\nMonte Carlo simulation of the lunar argon exosphere and comparison with LADEE data\napplied altitude fitting based on Chamberlain (1963) projection model to compare predicted densities with satellite data\nuses the landing position calculation proposed by Butler (1997)\n\n\n\nSchörghofer (2020)\nTHEORY EXOSPHERE\n“Thermodynamics of surface-bounded exospheres”\n\nthermodynamical investigation of exospheric densities based on various velocity distributions\nprovides statistical averaged and exact solutions for short ballistic flights, assuming constant gravitational acceleration\n\n\n\nGrava et al. (2021)\nREVIEW EXOSPHERE\n“Volatiles and refractories in surface-bounded exospheres in the inner solar system”\n\nreview of exospheric models of surface-bounded exospheres in the inner solar system, focusing on the Moon and Mercury\nconsiders various volatiles, refractories, ions, and ENAs\n\n\n\nB. Jones et al. (2021)\nSURFACE\n“Thermal evolution of water and hydrogen from Apollo lunar regolith grains”\n\nsimulated TPD process and comparison with TPD experiment\nconsidered several hydrogen-based species and their concentrations on the surface, in the subsurface and void space subsurface, and in gaseous form\nspecifically discussed recombinative desorption as the main pathway of water formation\n\n\n\nSarantos & Tsavachidis (2021)\nSURFACE\n“Lags in desorption of lunar volatiles”\n\ncomputer-generated lunar regolith packing to model random walks of argon and water particles to simulate gas transport\nsuggests subsurface diffusion and desorption-readsorption of gas particles leads to a lag in the exospheric density signature\n\n\n\nSchörghofer et al. (2021)\nREVIEW SURFACE\nEXOSPHERE\n“Water group exospheres and surface interactions on the Moon, Mercury, and Ceres”\n\nreview of hydrogen-based exospheric particles and their interaction with their planetary surface\nreports on the status of observations, theory, and laboratory measurements\n\n\n\nTucker et al. (2021)\nSURFACE EXOSPHERE\n“On the effect of magnetospheric shielding on the lunar hydrogen cycle”\n\nMonte Carlo model to investigate \\(\\ce{H}\\) implantation, conversion to \\(\\ce{OH}\\), and subsequent outgassing of \\(\\ce{H2}\\)\nsimulates the Moon’s passage through Earth’s magnetotail, eliminating the solar wind proton source, to which the hydrogen both on the surface as well as in the exosphere responds quickly\ngeneral model based on previous work of Tucker et al. (2018)\n\n\n\nMorrissey et al. (2022)\nSURFACE\n“Simulating the diffusion of hydrogen in amorphous silicates: a ‘jumping’ migration process and its implications for solar wind implanted lunar volatiles”\n\nmolecular dynamics simulation to describe the \\(\\ce{H}\\) movement in amorphous silica on an atomistic level\nuses insights to infer hydrogen diffusion in planetary regoliths\nexamines the degassing of water group particles and its influence on the lunar exosphere\nbaseline comparison with previous models of Farrell et al. (2015), Farrell et al. (2017), B. Jones et al. (2021), and Tucker et al. (2021)\n\n\n\nPoppe et al. (2022)\nEXOSPHERE\n“A comprehensive model for pickup ion formation at the Moon”\n\ntwo-part analytic model describing the lunar exospheric neutrals density distributions and the ionization and charged-particle dynamics of pickup ions based on the modeled neutral distributions\nincludes 18 different exospheric ion species\n\n\n\nSchörghofer (2022)\nTHEORY EXOSPHERE\n“Statistical thermodynamics of surface-bounded exospheres”\n\nbuilding on Schörghofer (2020)\nprovides an analytic description of velocity distributions and exact solutions for emerging density profiles\n\n\n\nWurz et al. (2022)\nREVIEW THEORY\nSURFACE\n“Particles and Photons as Drivers for Particle Release from the Surfaces of the Moon and Mercury”\n\nreview of surface interactions of exospheric particles\nincludes space weathering, thermal releases, MMIV, PSD and ESD, physical and chemical sputtering, and particle reflections\n\n\n\nMilillo (2023)\nREVIEW EXOSPHERE\nSURFACE\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSchörghofer & Rufu (2023)\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSchörghofer (2023)\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSmolka et al. (2023)\nEXOSPHERE\n“Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions”\n\nMonte Carlo simulation framework to simultaneously model multiple hydrogen-based exospheric species\nincludes several, uncertain conversion reactions, coupling the species with each other\nsuggests that surface reaction with hydrogen can significantly change exospheric dynamics around the terminator regions\n\n\n\nTeolis et al. (2023)\nREVIEW EXOSPHERE\nSURFACE\n“Surface exospheric interactions”\n\nreview of descriptions, current developments, and issues of exosphere-surface interactions\nincludes discussions of thermal accommodation, volatile diffusion, and cold-trapping\n\n\n\n\n\n\n\n\\setlength\\LTleft{0pt}\n\\setlength\\LTright{0pt}\n\\footnotesize\n\\begin{longtable}{@{}p{.25\\textwidth} p{.73\\textwidth}@{}}\n    \\toprule\n    Reference(s), \\emph{Tags} & \\textbf{Title}, Description/Highlights \\\\\n    \\midrule\n    \\endhead\n    \\bottomrule\n    \\endfoot\n\n    \\citet{Chamberlain1963}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Planetary coronae and atmospheric evaporation\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item analytical model of density distributions in planetary atmospheres/exospheres\n        \\item assumes an isothermal, spherically symmetric, and globally uniform atmosphere\n        \\item developed a scaled barometric scaling for exospheric number densities at varying altitudes\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Vogel1966}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Molecular fluxes in the lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item theoretical model of molecular fluxes in the lunar exosphere\n        \\item proposed an analytical framework to calculate elliptical trajectories and the respective landing positions on the Moon\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hodges1973}\\newline\\emph{Exosphere} & \\textbf{\"Composition and dynamics of lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item first $\\ce{H2}$, $\\ce{He}$, $\\ce{Ne}$, and $\\ce{Ar}$ model of the lunar exosphere\n        \\item compared model results with preliminary Apollo 17 data\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Armand1977}\\newline\\emph{Theory} & \\textbf{\"Classical theory of desorption rate velocity distribution of desorbed atoms; Possibility of a compensation effect\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item proposed the theory of desorption velocity distributions (Maxwell-Boltzmann Flux Distribution, MBF)\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Smith1978}\\newline\\emph{Exosphere} & \\textbf{\"Monte Carlo modeling of exospheric bodies: Mercury\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of Mercury's exosphere\n        \\item MBF distributed particle velocities\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Huebner1992}\\newline\\emph{Theory} & \\textbf{\"Solar photo rates for planetary atmospheres and atmospheric pollutants\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item provides a comprehensive overview of photoreaction rates widely used for modeling the lunar exosphere\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Butler1997}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"The migration of volatiles on the surfaces of Mercury and the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo exosphere model of Mercury and the Moon, specifically $\\ce{H2O}$ and $\\ce{CO2}$   \n        \\item proposed an analytic function to approximate the lunar surface temperature\n        \\item extension of \\citet{Vogel1966} trajectory calculation\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Crider2002}\\newline\\emph{Exosphere} & \\textbf{\"The migration of volatiles on the surfaces of Mercury and the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation of exospheric hydrogen migration on the Moon\n        \\item lists a variety of conversion paths for solar wind protons to $\\ce{H}$, $\\ce{H2}$, $\\ce{OH}$, and $\\ce{H2O}$    \n        \\item comments on the high inaccuracies of the implementation of the chemical and physical reactions\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Chaufray2009}\\newline\\emph{Exosphere} & \\textbf{\"Lunar Argon cycle modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of the lunar argon exosphere\n        \\item investigated the accumulation of $\\ce{Ar}$ in PSRs  \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Poppe2013}\\newline\\emph{Exosphere} & \\textbf{\"The self-sputtered contribution to the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item first self-sputtering model of the lunar exosphere\n        \\item self-sputtering is a significant source of neutrals (locally comparable to solar wind and micrometeoroid bombardment) \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2014}\\newline\\emph{Exosphere} & \\textbf{\"Lunar exospheric argon modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of the lunar argon exosphere, based on \\citet{Chaufray2009}\n        \\item compared model predictions with LACE, LAMP, and LADEE measurements\n        \\item found that charge exchange is a relevant argon loss process and that cold-trapping losses are comparable to ionization fluxes\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schorghofer2014}\\newline\\emph{Exosphere} & \\textbf{\"Migration calculations for water in the exosphere of the Moon: dusk-dawn asymmetry, heterogeneous trapping, and D/H fractionation\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of exospheric water migration of the Moon, based on \\citet{Butler1997}\n        \\item presents a dusk-dawn asymmetry of hydrogenous species \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Farrell2015}\\newline\\emph{Surface} & \\textbf{\"Solar wind implantation into lunar regolith: hydrogen retention in a surface with defects\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of solar wind implantation into the lunar surface regolith\n        \\item systematically studied distributions of activation energies to simulate hydrogen retention and $\\ce{OH}$ formation    \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2015}\\newline\\emph{Theory} & \\textbf{\"An analytic function of lunar surface temperature for exospheric modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item presents an analytic approximation of the lunar surface temperatures based on Diviner measurements\n        \\item improved the analytical approach of \\citet{Butler1997}\n        \\item temperature model does not include topographical, temporal, or compositional features\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2015}\\newline\\emph{Exosphere} & \\textbf{\"Transport of water in a transient impact-generated lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item hybrid DSMC approach to investigate water transport in impact-generated lunar atmosphere, combining a continuum description of the dense plume with a Monte Carlo model of the tenuous water vapor exosphere\n        \\item unsteady and three-dimensional simulations\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2016}\\newline\\emph{Exosphere} & \\textbf{\"Understanding temporal and spatial variability of the lunar helium atmosphere using simultaneous observations from LRO, LADEE, and ARTEMIS\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of the lunar surface-bounded helium exosphere\n        \\item suggests that endogenic helium provides roughly a third of the Moon's exospheric helium\n        \\item built on previous works by \\citet{Killen1999}, \\citet{Hodges1973}, \\citet{Butler1997}, \\citet{Grava2014}, and more    \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Moores2016}\\newline\\emph{Exosphere} & \\textbf{\"Lunar water migration in the interval between large impacts: heterogeneous delivery to permanently shadowed regions, fractionation, and diffusive barriers\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation to examine water delivery to lunar PSRs\n        \\item impactor water delivery (based on \\citet{Prem2015}) and ballistic migration included as water sources \n        \\item explicitly modeled the high-latitude regions, including several PSRs\n        \\item extended \\citet{Crider2002} and \\citet{Schorghofer2014} for higher latitudes   \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Farrell2017}\\newline\\emph{Surface} & \\textbf{\"The statistical mechanics of solar wind hydroxylation at the Moon, within lunar magnetic anomalies, and at Phobos\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item extension of the previous model \\citep{Farrell2015}, presents a formalism to statistically describe hydrogen implantation into the lunar surface and subsurface diffusion of $\\ce{H}$ using a Monte Carlo simulation\n        \\item used distributed activation energies in the physical model\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2017}\\newline\\emph{Exosphere} & \\textbf{\"Contributions of solar wind and micrometeoroids to molecular hydrogen in the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model (extension of previous model \\citep{Hurley2016}) to investigate spatial distribution of $\\ce{H2}$ in the lunar exosphere  \n        \\item examined the contributions of micrometeoroids and solar wind particles\n        \\item found that micrometeoroids are an insufficient source to reproduce LAMP $\\ce{H2}$ measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Kegerreis2017}\\newline\\emph{Exosphere} & \\textbf{\"Evidence for a localized source of the argon in the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model of the lunar $\\ce{Ar}$ exosphere, based on the works of \\citet{Smith1978}, \\citet{Hodges1973}, and \\citet{Butler1997}\n        \\item includes seasonal effects to study long-term variations\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Jones2018}\\newline\\emph{Surface} & \\textbf{\"Solar wind-induced water cycle on the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item chemical kinetics model of lunar surficial $\\ce{OH}$ and $\\ce{H2O}$, investigating the long-term evolution\n        \\item based on solar wind proton delivery as the main source of the simulated water cycle\n        \\item focuses on recombinative desorption as the primary water formation pathway\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2018}\\newline\\emph{Surface}\\newline\\emph{Theory} & \\textbf{\"The influence of surface roughness on volatile transport on the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item numerical thermal model for a rough lunar surface\n        \\item extension of \\citet{Hurley2015} thermal model\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Tucker2018}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{\"Solar wind implantation into the lunar regolith: Monte Carlo simulations of H retention in a surface with defects and the H2 exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo-based simulation of solar wind implantation into the lunar lunar regolith to study $\\ce{H}$ retention and implications for the $\\ce{H2}$ exosphere \n        \\item modeled hydrogen diffusion and recombination to $\\ce{H2}$\n        \\item includes Gaussian distributions of activation energies\n        \\item based on models by \\citet{Killen1999}, \\citet{Farrell2015}, \\citet{Farrell2017}, and \\citet{Hurley2017}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grumpe2019}\\newline\\emph{Surface} & \\textbf{\"Time-of-day-dependent behavior of surficial lunar hydroxyl/water: Observations and modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item reaction kinetics model as an extension of \\citet{Farrell2015} and \\citet{Farrell2017} Monte Carlo simulation\n        \\item investigates $\\ce{H}$, $\\ce{OH}$, and $\\ce{H2O}$ concentrations, based on both solar wind and micrometeoroid influx\n        \\item includes a 1D lateral heat conduction model with surface roughness dependence\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Killen2019}\\newline\\emph{Exosphere} & \\textbf{\"The lunar neon exosphere seen in LACE data\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation of the lunar neon exosphere\n        \\item comparison with Apollo 17's LACE data\n        \\item suggests that theoretical photodissociation losses are too low to reproduce $\\ce{Ne}$ measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2019}\\newline\\emph{Exosphere} & \\textbf{\"Coupled DSMC-Monte Carlo radiative transfer modeling of gas dynamics in a transient impact-generated lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item extension of the Monte Carlo model of \\citet{Prem2015} to include the influence of radiative heat transfer and shielding of an impact-generated atmosphere\n        \\item applies new model to simulate a $\\ce{H2O}$ exosphere\n        \\item finds that gas-gas radiative transfer is playing an important role, significantly influencing water vapor transport to the night-side\n        \\item \\emph{includes a chapter on numerical validations of the presented model}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2020}\\newline\\emph{Exosphere} & \\textbf{\"LRO/LAMP observations of the lunar helium exosphere: constraints on thermal accommodation and outgassing rate\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation of lunar exospheric helium to investigate source rates and thermal accommodation\n        \\item compares modelled $\\ce{He}$ densities with LAMP measurements\n        \\item suggests the best description of lunar helium assuming full thermal accommodation and an MBF distribution of kinetic energies\n        \\item finds that endogenic $\\ce{He}$ provides about $\\SI{20}{\\percent}$ of the lunar helium exosphere as compared to solar wind source\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Kegerreis2020}\\newline\\emph{Exosphere} & \\textbf{\"Planetary giant impacts, simulating collisions and their consequences\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation of the lunar argon exosphere and comparison with LADEE data\n        \\item applied altitude fitting based on \\citet{Chamberlain1963} projection model to compare predicted densities with satellite data\n        \\item uses the landing position calculation proposed by \\citet{Butler1997}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2020}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Thermodynamics of surface-bounded exospheres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item thermodynamical investigation of exospheric densities based on various velocity distributions\n        \\item provides statistical averaged and exact solutions for short ballistic flights, assuming constant gravitational acceleration\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2021}\\newline\\emph{Review}\\newline\\emph{Exosphere} & \\textbf{\"Volatiles and refractories in surface-bounded exospheres in the inner solar system\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of exospheric models of surface-bounded exospheres in the inner solar system, focusing on the Moon and Mercury\n        \\item considers various volatiles, refractories, ions, and ENAs\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Jones2021}\\newline\\emph{Surface} & \\textbf{\"Thermal evolution of water and hydrogen from Apollo lunar regolith grains\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item simulated TPD process and comparison with TPD experiment\n        \\item considered several hydrogen-based species and their concentrations on the surface, in the subsurface and void space subsurface, and in gaseous form\n        \\item specifically discussed recombinative desorption as the main pathway of water formation\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Sarantos2021}\\newline\\emph{Surface} & \\textbf{\"Lags in desorption of lunar volatiles\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item computer-generated lunar regolith packing to model random walks of argon and water particles to simulate gas transport\n        \\item suggests subsurface diffusion and desorption-readsorption of gas particles leads to a lag in the exospheric density signature\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2021}\\newline\\emph{Review}\\newline\\emph{Surface}\\newline\\emph{Exosphere} & \\textbf{\"Water group exospheres and surface interactions on the Moon, Mercury, and Ceres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of hydrogen-based exospheric particles and their interaction with their planetary surface\n        \\item reports on the status of observations, theory, and laboratory measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Tucker2021}\\newline\\emph{Surface}\\newline\\emph{Exosphere} & \\textbf{\"On the effect of magnetospheric shielding on the lunar hydrogen cycle\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo model to investigate $\\ce{H}$ implantation, conversion to $\\ce{OH}$, and subsequent outgassing of $\\ce{H2}$\n        \\item simulates the Moon's passage through Earth's magnetotail, eliminating the solar wind proton source, to which the hydrogen both on the surface as well as in the exosphere responds quickly\n        \\item general model based on previous work of \\citet{Tucker2018}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Morrissey2022}\\newline\\emph{Surface} & \\textbf{\"Simulating the diffusion of hydrogen in amorphous silicates: a ‘jumping’ migration process and its implications for solar wind implanted lunar volatiles\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item molecular dynamics simulation to describe the $\\ce{H}$ movement in amorphous silica on an atomistic level\n        \\item uses insights to infer hydrogen diffusion in planetary regoliths\n        \\item examines the degassing of water group particles and its influence on the lunar exosphere\n        \\item baseline comparison with previous models of \\citet{Farrell2015}, \\citet{Farrell2017}, \\citet{Jones2021}, and \\citet{Tucker2021}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Poppe2022}\\newline\\emph{Exosphere} & \\textbf{\"A comprehensive model for pickup ion formation at the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item two-part analytic model describing the lunar exospheric neutrals density distributions and the ionization and charged-particle dynamics of pickup ions based on the modeled neutral distributions\n        \\item includes 18 different exospheric ion species\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2022}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Statistical thermodynamics of surface-bounded exospheres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item building on \\citet{Schoerghofer2020}\n        \\item provides an analytic description of velocity distributions and exact solutions for emerging density profiles\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Wurz2022}\\newline\\emph{Review}\\newline\\emph{Theory}\\newline\\emph{Surface} & \\textbf{\"Particles and Photons as Drivers for Particle Release from the Surfaces of the Moon and Mercury\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of surface interactions of exospheric particles\n        \\item includes space weathering, thermal releases, MMIV, PSD and ESD, physical and chemical sputtering, and particle reflections\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Milillo2023}\\newline\\emph{Review}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2023} & \n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2023a} & \n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Smolka2023}\\newline\\emph{Exosphere} & \\textbf{\"Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte Carlo simulation framework to simultaneously model multiple hydrogen-based exospheric species\n        \\item includes several, uncertain conversion reactions, coupling the species with each other\n        \\item suggests that surface reaction with hydrogen can significantly change exospheric dynamics around the terminator regions\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Teolis2023}\\newline\\emph{Review}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{\"Surface exospheric interactions\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of descriptions, current developments, and issues of exosphere-surface interactions\n        \\item includes discussions of thermal accommodation, volatile diffusion, and cold-trapping\n    \\end{itemize} \\\\ \\midrule\n\\end{longtable}\nPlease note that the code above requires the longtable package and all necessary references in the bibliography."
  },
  {
    "objectID": "documentation/introduction/introduction.html#the-problem-of-scales",
    "href": "documentation/introduction/introduction.html#the-problem-of-scales",
    "title": "1. Introduction",
    "section": "The Problem of Scales",
    "text": "The Problem of Scales\nOne of the most prominent problems for exosphere models is based on the enormous difference in physical scales between relevant processes. While the dimensions of the respective planetary object and its topographic features are around hundreds of kilometers, surface and subsurface processes like particle releases or diffusion are described on micro and sometimes down to atomic scales (Milillo, 2023)."
  },
  {
    "objectID": "documentation/drivers/photoreactions.html",
    "href": "documentation/drivers/photoreactions.html",
    "title": "3.3 Photoreactions",
    "section": "",
    "text": "Some Intro"
  },
  {
    "objectID": "documentation/drivers/photoreactions.html#photoionization-rates",
    "href": "documentation/drivers/photoreactions.html#photoionization-rates",
    "title": "3.3 Photoreactions",
    "section": "Photoionization Rates",
    "text": "Photoionization Rates\n\n\n Figure Julia Download\n\n\n\n\n\nFigure 1: Photoionization rates for Hydrogen, Helium, Oxygen, and Neon during the period between 1978 and 2012, derived by a multilinear model of Bochsler et al. (2013). The data is displayed as daily and yearly averages, with the extreme values of the yearly averages highlighted by dashed horizontal lines.\n\n\n\n\nusing DelimitedFiles, Statistics\n\n#::. utility functions\nfunction read_table(path::String=joinpath(@__DIR__, \"photoionization_rates_BOCHSLER2013.csv\"))\n    table = readdlm(path, ',', Float64, '\\n', header=true)\n    return table[1], table[2]\nend\n\nfunction photoionization_rates_BOCHSLER2013(N::Integer)\n    tab, _ = read_table()\n    t, k = tab[:,3], tab[:,N]\n    return t, k\nend\n \nfunction photoionization_rates_BOCHSLER2013(elem::Symbol)\n    N = elem == :H ? 4 :\n        elem == :He ? 5 :\n        elem == :O ? 6 :\n        elem == :Ne ? 7 : error(\"Element not supported\")\n    return photoionization_rates_BOCHSLER2013(N)\nend\n\nH_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(4)\nHe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(5)\nO_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(6)\nNe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(7)\n\n\n#::. postprocessing functions\nfunction smoothing(k::AbstractVector; n=5)\n    return [mean(k[max(1,i-n):min(length(k),i+n)]) for i in 1+n:length(k)-n]\nend\n\n\n#::. plotting functions\nfunction plot_k_all(name::String=\"photoionization_rates_BOCHSLER2013\"; n=5)\n    t, kH  = photoionization_rates_BOCHSLER2013(:H)\n    _, kHe = photoionization_rates_BOCHSLER2013(:He)\n    _, kO  = photoionization_rates_BOCHSLER2013(:O)\n    _, kNe = photoionization_rates_BOCHSLER2013(:Ne)\n\n    t_smooth = t[1+n:end-n]\n    kH_smooth = smoothing(kH; n=n)\n    kHe_smooth = smoothing(kHe; n=n)\n    kO_smooth = smoothing(kO; n=n)\n    kNe_smooth = smoothing(kNe; n=n)\n\n    kH_smooth_max = findmax(kH_smooth)\n    kHe_smooth_max = findmax(kHe_smooth)\n    kO_smooth_max = findmax(kO_smooth)\n    kNe_smooth_max = findmax(kNe_smooth)\n\n    kH_smooth_min = findmin(kH_smooth)\n    kHe_smooth_min = findmin(kHe_smooth)\n    kO_smooth_min = findmin(kO_smooth)\n    kNe_smooth_min = findmin(kNe_smooth)\n\n    #\n    fig = Figure(resolution=(1200,600), fontsize=16)\n\n    ax1 = Axis(fig[1,1]; yticks=[1.0, 1.3, 1.6]); hidexdecorations!(ax1; grid=false);\n    scatter!(ax1, t, kH; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax1, t_smooth, kH_smooth; color=TUMBlack)\n    scatter!(ax1, t_smooth[kH_smooth_max[2]], kH_smooth_max[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax1, t_smooth[kH_smooth_min[2]], kH_smooth_min[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,1], \"Hydrogen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax2 = Axis(fig[2,1]; xlabel=\"Year\", yticks=[1.0, 1.5, 2.0])\n    scatter!(ax2, t, kHe; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax2, t_smooth, kHe_smooth; color=TUMBlack)\n    scatter!(ax2, t_smooth[kHe_smooth_max[2]], kHe_smooth_max[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax2, t_smooth[kHe_smooth_min[2]], kHe_smooth_min[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,1], \"Helium\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax3 = Axis(fig[1,2]; yticks=([3, 5, 7], [\"3.0\",\"5.0\",\"7.0\"])); hidexdecorations!(ax3; grid=false);\n    scatter!(ax3, t, kO; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax3, t_smooth, kO_smooth; color=TUMBlack)\n    scatter!(ax3, t_smooth[kO_smooth_max[2]], kO_smooth_max[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax3, t_smooth[kO_smooth_min[2]], kO_smooth_min[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,2], \"Oxygen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax4 = Axis(fig[2,2]; xlabel=\"Year\", yticks=([2.0, 4.0, 6.0],[\"2.0\",\"4.0\",\"6.0\"]))\n    ld = scatter!(ax4, t, kNe; color=TUMBlueLighter, markersize=2.5)\n    ly = lines!(ax4, t_smooth, kNe_smooth; color=TUMBlack)\n    scatter!(ax4, t_smooth[kNe_smooth_max[2]], kNe_smooth_max[1]; color=TUMBlack)\n    lmax = hlines!(ax4, kNe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax4, t_smooth[kNe_smooth_min[2]], kNe_smooth_min[1]; color=TUMBlack)\n    lmin = hlines!(ax4, kNe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,2], \"Neon\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    Label(fig[:,0], \"Photoionization Rate [10⁻⁷ s⁻¹]\", rotation=pi/2)\n\n\n    da = MarkerElement(color=TUMBlueLighter, marker=:circle, markersize=12)\n    ya = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    mm = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    Legend(fig[0,:], [da,ya,mm], [\"day average\", \"year average\", \"maximum/minimum year averages\"]; orientation=:horizontal)\n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n photoionization_rates_BOCHSLER.png   photoionization_rates_BOCHSLER.pdf \n data.csv"
  },
  {
    "objectID": "documentation/drivers/solar_wind.html#protons-and-electrons",
    "href": "documentation/drivers/solar_wind.html#protons-and-electrons",
    "title": "3.1 Solar Wind",
    "section": "Protons and Electrons",
    "text": "Protons and Electrons\nAbout \\(96\\,\\mathrm{\\%}\\) of all ions are protons (Futaana et al., 2012).\nProton density of the solar wind measured by Mariner 2 varied between \\(\\left(1 - 50\\right)\\,\\mathrm{cm^{\\mathrm{-3}}}\\), with an average daily average of \\(5\\,\\mathrm{cm^{\\mathrm{-3}}}\\) protons (Neugebauer & Snyder, 1966)."
  },
  {
    "objectID": "documentation/drivers/solar_wind.html#ions-and-heavier-elements",
    "href": "documentation/drivers/solar_wind.html#ions-and-heavier-elements",
    "title": "3.1 Solar Wind",
    "section": "Ions and Heavier Elements",
    "text": "Ions and Heavier Elements\nThe majority of the remaining ions are alpha particles, i.e., helium nuclei \\(\\ce{He++}\\), making up about \\(4\\,\\mathrm{\\%}\\) of the solar wind ion particles (Futaana et al., 2012)."
  },
  {
    "objectID": "documentation/drivers/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "href": "documentation/drivers/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "api/api.html",
    "href": "api/api.html",
    "title": "Code",
    "section": "",
    "text": "The ExESS package is structured into four main parts, which are the four main folders in the /src directory:"
  },
  {
    "objectID": "api/api.html#repository-structure",
    "href": "api/api.html#repository-structure",
    "title": "Code",
    "section": "Repository Structure",
    "text": "Repository Structure\n\n\nExESS/  \n├── data/  \n├── res/  \n├── src/  \n│  ├── base/  \n│  ├── exospheres/  \n│  ├── grids/  \n│  ├── surfaces/  \n│  └── ExESS.jl  \n├── test/  \n├── . . .  \n└── README.md"
  },
  {
    "objectID": "api/api.html#source-files",
    "href": "api/api.html#source-files",
    "title": "Code",
    "section": "Source Files",
    "text": "Source Files\n\n\nBase Functionalities – base/\nExESS/src/base/ contains basic functionality that is used at multiple places in the code, e.g., physical constants, coordinate system definitions, utility functions, and some probability distributions.\n\nconstants.jl\n\ncs.jl\ndistributions.jl\nutils.jl\n\n\n\nExospheres – exospheres/\nExESS/src/exospheres/ contains all scripts that define functions that have something to do with simulating the exosphere. Due to the assumption of surface-bounded exospheres, Monte Carlo methods are the preferred simulation tool as each particle of the exosphere can be simulated independently. Implemented functionalities are mostly based on ballistic trajectory calculations.\n\ntrajectories.jl\nlanding_position.jl\nutils.jl\n\n\n\nNumerical Grids – grids/\nExESS/src/grids/ contains all numerical discretization methods used in this package. While most functions can be called with AbstractVector inputs, their main use is meant to be in conjunction with the previously defined custom coordinate systems.\n\nglobal_healpix_2d_grids.jl\n\nglobal_spiral_2d_grids.jl\n\nglobal_structured_2d_grids.jl\n\nglobal_structured_3d_grids.jl\n\nlocal_structured_3d_grids.jl\n\ntypes.jl\n\nutils.jl\n\n\n\nSurfaces – surfaces/\nExESS/src/surfaces/ contains all functions that are used to calculate surface properties, e.g., surface temperatures, reaction kinetics, thermal conductivities, and diffusion coefficients.\n\ndensity.jl\n\nporosity.jl\n\nreaction_rates.jl\n\nregolith.jl\n\ntemperature.jl\n\nthermal_conductivity_parzinger2014.jl\n\nutils.jl"
  },
  {
    "objectID": "api/exospheres/utility.html#usage",
    "href": "api/exospheres/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/exospheres/utility.html#examples",
    "href": "api/exospheres/utility.html#examples",
    "title": "Utility",
    "section": "Examples",
    "text": "Examples"
  },
  {
    "objectID": "api/exospheres/utility.html#api",
    "href": "api/exospheres/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nescape_velocity – Function\n\n\n\n\n\n[1] escape_velocity(r::Real, m::Real)\nCalculates the magnitude of the escape velocity for an orbital radius r and body mass m.\n\n\n\n\n\n\n\n\n\n\nscale_height – Function\n\n\n\n\n\n[1] scale_height(T, m::Real; R::Real=LUNAR_RADIUS, M::Real=LUNAR_MASS)\nCalculates the scale height of a particle with mass m, given the thermal energy based on the thermodynamic equilibrium temperature T, in the exosphere of a planetary body with radius R and mass M.\nDefault values for the planetary body are corresponding to the Moon.\n\n\n\n\n\n\n\n\n\n\nprojection_CHAMBERLAIN1963 – Function\n\n\n\n\n\n[1] projection_CHAMBERLAIN1963(n1::Real, r1::Real, r2::Real, T::Real, m::Real; M::Real=LUNAR_MASS)\nCalculates the number density of particles of mass m at radial distance r2 given the number density n1 at radial distance r1, assuming constant temperature T.\nAssumes hydrostatic equilibrium and perfect-gas law with isotropic gas pressure, resulting in the generalized form of the isothermal barometric law. The calculation is based on the equation (14) in Chamberlain (1963).\nRerences\n\nChamberlain, 1963, “Planetary coronae and atmospheric evaporation”\nCook et al. 2013, “New upper limits on numerous atmospheric species in the native lunar atmosphere”"
  },
  {
    "objectID": "api/exospheres/landing_position.html",
    "href": "api/exospheres/landing_position.html",
    "title": "Landing Position",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/exospheres/landing_position.html#usage",
    "href": "api/exospheres/landing_position.html#usage",
    "title": "Landing Position",
    "section": "Usage",
    "text": "Usage\nx0 = GlobalSphericalPosition(LUNAR_RADIUS, 0, 0)\nv0 = LocalCartesianVelocity(100, 100, 0)\nx1 = landing_position(x0, v0)\nt  = time_of_flight(x0, v0)"
  },
  {
    "objectID": "api/exospheres/landing_position.html#examples",
    "href": "api/exospheres/landing_position.html#examples",
    "title": "Landing Position",
    "section": "Examples",
    "text": "Examples"
  },
  {
    "objectID": "api/exospheres/landing_position.html#api",
    "href": "api/exospheres/landing_position.html#api",
    "title": "Landing Position",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlanding_position – Function\n\n\n\n\n\n[1] landing_position(x0::AbstractVector, v0::AbstractVector; kwargs...)\n[2] landing_position(x0::AbstractPosition, v0::AbstractVelocity; kwargs...)\nCalculates the landing position of a particle starting at position x0 (global spherical coordinates: radius, longitude, latitude), with initial velocity v0 (local cartesian coordinates: x (east), y (north), z (up)), flying on a ballistic trajectory, i.e., only influenced by graviational forces.\nReturns the landing position in global spherical coordinate as r, lon, lat ([1]) or as GlobalSphericalPosition(r, lon, lat) ([2]).\nKey-Word Arguments\n\n\n\nField\nValue\nUnit\nDescription\n\n\n\n\nm\nLUNAR_MASS\n[kg]\nmass of planetary object\n\n\n\nReferences\n\nN. Schörghofer: “USER GUIDE: Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces”, https://github.com/nschorgh/Planetary-Code-Collection\nB. J. Butler, 1997, “The migration of volatiles on the surfaces of Mercury and the Moon,” Journal of Geophysical Research, vol. 102, no. E8, pp. 19,283–19,291, doi: 10.1029/97JE01347.\nKegerreis et al., 2017, “Evidence for a localized source of the argon in the lunar exosphere”, Journal of Geophysical Research: Planets, American Geophysical Union (AGU), 122, 2163-2181\n\n\n\n\n\n\n\n\n\n\n\ntime_of_flight – Function\n\n\n\n\n\n[1] time_of_flight(x0::AbstractVector, v0::AbstractVector; kwargs...)\nReferences\n\nN. Schörghofer: “USER GUIDE: Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces”, https://github.com/nschorgh/Planetary-Code-Collection\nB. J. Butler, 1997, “The migration of volatiles on the surfaces of Mercury and the Moon,” Journal of Geophysical Research, vol. 102, no. E8, pp. 19,283–19,291, doi: 10.1029/97JE01347.\nKegerreis et al., 2017, “Evidence for a localized source of the argon in the lunar exosphere”, Journal of Geophysical Research: Planets, American Geophysical Union (AGU), 122, 2163-2181"
  },
  {
    "objectID": "api/exospheres/landing_position.html#benchmarks",
    "href": "api/exospheres/landing_position.html#benchmarks",
    "title": "Landing Position",
    "section": "Benchmarks",
    "text": "Benchmarks\nJulia Version Information\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 1 on 8 virtual cores\n\n\n\nBenchmark\nMinimum [ns]\nMedian [ns]\n\n\n\n\nFunction: landing_position\n1215.498\n1227.366\n\n\nFunction: time_of_flight\n1032.094\n1047.41\n\n\n\nFunction: landing_position\nBenchmarkTools.Trial: 7539 samples with 500 evaluations.\n Range (min … max):  1.215 μs …  11.601 μs  ┊ GC (min … max): 0.00% … 87.11%\n Time  (median):     1.227 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.323 μs ± 749.768 ns  ┊ GC (mean ± σ):  4.86% ±  7.47%\n\n  █▇▂▁▂▅▅▄▃▂▂▂▂▁▂     ▁                                       ▂\n  █████████████████████▇▅▇▆▅▆▆▅▅▅▅▄▆▄▅▃▄▃▄▄▄▁▁▃▄▃▁▃▃▁▁▄▁▃▁▁▁▃ █\n  1.22 μs      Histogram: log(frequency) by time      1.83 μs &lt;\n\n Memory estimate: 688 bytes, allocs estimate: 16.\nFunction: time_of_flight\nBenchmarkTools.Trial: 8605 samples with 500 evaluations.\n Range (min … max):  1.032 μs …  49.322 μs  ┊ GC (min … max): 0.00% … 93.44%\n Time  (median):     1.047 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.157 μs ± 853.498 ns  ┊ GC (mean ± σ):  4.64% ±  6.67%\n\n  █▃▃▄▂▂▂▁▁                                                   ▁\n  ████████████▇▇▇▆▆▇▆▆▅▆▅▄▅▅▅▄▅▄▄▄▃▃▄▂▃▄▃▄▄▄▃▄▄▂▄▅▄▅▃▃▄▃▃▃▂▄▄ █\n  1.03 μs      Histogram: log(frequency) by time      2.45 μs &lt;\n\n Memory estimate: 528 bytes, allocs estimate: 11."
  },
  {
    "objectID": "api/base/constants.html#usage",
    "href": "api/base/constants.html#usage",
    "title": "Constants",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/constants.html#api",
    "href": "api/base/constants.html#api",
    "title": "Constants",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nBase - Constants\n\n\n\n\n\nAVOGADRO_CONSTANT:         6.022141e+23 [mol-1]\nBOLTZMANN_CONSTANT:        1.380650e-23 [m2 kg s-2 K-1]\nELEMENTARY_CHARGE:         1.602177e-19 [C]\nGRAVITATIONAL_CONSTANT:    6.674080e-11 [m3 kg-1 s-2]\nPLANCK_CONSTANT:           6.626070e-34 [m2 kg s-1]\nSTEFAN_BOLTZMANN_CONSTANT: 5.670000e-08 [W m-2 K-4]\nUNIVERSAL_GAS_CONSTANT:    8.314463e+00 [J K-1 mol-1]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - Particle Masses\n\n\n\n\n\nAMU_H:                     1.007975 [u]\nAMU_He:                    4.002602 [u]\nAMU_O:                    15.999400 [u]\nAMU_Ne:                   20.179700 [u]\nAMU_Ar:                   39.877500 [u]\n\nAMU_H2:                    2.015950 [u]\nAMU_OH:                   17.007375 [u]\nAMU_H2O:                  18.015350 [u]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - The Moon\n\n\n\n\n\nLUNAR_DAY:                 2.548800e+06 [s]\nLUNAR_MASS:                7.247673e+22 [kg]\nLUNAR_RADIUS:              1.737400e+06 [m]\nLUNAR_g0:                  1.602472e+00 [m s-2]\nLUNAR_vesc:                2.359718e+03 [m s-1]"
  },
  {
    "objectID": "api/base/cs.html",
    "href": "api/base/cs.html",
    "title": "Coordinate Systems",
    "section": "",
    "text": "Coordinates in ExESS are implemented as their custom, three-dimensional vectors, which are based on their scope, the coordinate system, and their physical type. The scope can either be Global[...] or Local[...], which is referring to a fixed planetary system or a local reference frame, respectively. The coordinate system is either [...]Cartesian[...] or [...]Spherical[...], which is referring to a Cartesian or spherical coordinate system, respectively. The physical type is either [...]Position or [...]Velocity, which is referring to a position or velocity vector, respectively."
  },
  {
    "objectID": "api/base/cs.html#conversions",
    "href": "api/base/cs.html#conversions",
    "title": "Coordinate Systems",
    "section": "Conversions",
    "text": "Conversions\n\nLocal-to-Global\nIn general, local-to-global conversions are not possible without providing additional information. The main problem is that local coordinates inherently convey less information (i.e., where in the “global world” the local reference frame is located)."
  },
  {
    "objectID": "api/grids/local_structured_3d_grids.html#type-structure",
    "href": "api/grids/local_structured_3d_grids.html#type-structure",
    "title": "Local, Structured, 3D Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/local_structured_3d_grids.html#usage",
    "href": "api/grids/local_structured_3d_grids.html#usage",
    "title": "Local, Structured, 3D Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/local_structured_3d_grids.html#api",
    "href": "api/grids/local_structured_3d_grids.html#api",
    "title": "Local, Structured, 3D Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nLocalStructured3DGrid – Struct\n\n\n\n\n\n[1] LocalStructured3DGrid(T::Type, xrange::Tuple, yrange::Tuple, zrange::Tuple, N_x::Int64, N_y::Int64, N_z::Int64)\n[2] LocalStructured3DGrid(xrange::Tuple, yrange::Tuple, zrange::Tuple, N_x::Int64, N_y::Int64, N_z::Int64)\n[3] LocalStructured3DGrid(xrange::Tuple, yrange::Tuple, z2::Real, N_x::Int64, N_y::Int64, N_z::Int64)\nLocal structured volume grid (3D) of type LocalStructured3DGrid{T} over a rectangular domain."
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#type-structure",
    "href": "api/grids/global_structured_3d_grids.html#type-structure",
    "title": "Global, Structured, 3D Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#usage",
    "href": "api/grids/global_structured_3d_grids.html#usage",
    "title": "Global, Structured, 3D Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#api",
    "href": "api/grids/global_structured_3d_grids.html#api",
    "title": "Global, Structured, 3D Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalStructured3DGrid – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid([T::Type,] r0::Real, h::AbstractVector, N_theta::Int64, N_phi::Int64)\n[3] GlobalStructured3DGrid([T::Type,] r::AbstractVector, N_theta::Int64, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_EqSim([T::Type,] r0::Real, h::AbstractVector, N_theta::Int64, N_phi::Int64)\n[3] GlobalStructured3DGrid_EqSim([T::Type,] r::AbstractVector, N_theta::Int64, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a hemisphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_Reduced – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_Reduced{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_Reduced([T::Type,] r0::Real, h::AbstractVector, N_phi::Int64)\n[3] GlobalStructured3DGrid_Reduced([T::Type,] r::AbstractVector, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_Reduced_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_Reduced_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_Reduced_EqSim([T::Type,] r0::Real, h::AbstractVector, N_phi::Int64)\n[3] GlobalStructured3DGrid_Reduced_EqSim([T::Type,] r::AbstractVector, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3]."
  },
  {
    "objectID": "additionals/code_examples/2d_3d_landing_position_comparison/index.html",
    "href": "additionals/code_examples/2d_3d_landing_position_comparison/index.html",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "",
    "text": "In this example, the landing position of a particle is calculated in two different ways: a two-dimensional approach based on spherical trigonometry proposed by Butler (1997) and refined by Schoerghofer (2022), and a three-dimensional approach which solves the ODE of the trajectory numerically. The two approaches are compared in terms of accuracy and computational efficiency."
  },
  {
    "objectID": "additionals/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position",
    "href": "additionals/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "2D Landing Position",
    "text": "2D Landing Position\nWe can now calculate the landing position of the particle using the two-dimensional approach (for a detailed description of the algorithm, see the documentation):\n\nx_landing_2d = landing_position(x0, v0)\n\nGlobalSphericalPosition{Float64}(1.7374e6, 0.018438792639089627, 0.007374965418890142)\n\n\nSince we gave the function landing_position inputs in the format of the ExESS-defined coordinates, the output is also in the same format, i.e., a GlobalSphericalPosition. We can immediately check that the landing position is indeed on the surface of the Moon by looking at the first component of the output: 1.7374e6, which is the radius of the Moon in meters."
  },
  {
    "objectID": "additionals/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position-1",
    "href": "additionals/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position-1",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "3D Landing Position",
    "text": "3D Landing Position\nWe can do the same calculation using the three-dimensional approach. For this, we are using the predefined acceleration function ddx_lunar_gravity which calculates the acceleration due to the lunar gravity at a given position, plugging it into the trajectory function, together with our previously defined starting position and launch velocity vector. Since we are interested in the landing location, we are just extracting the last step of the trajectory object traj, where positions [4:6] are giving the x-, y-, and z-coordinates of the particle in cartesian coordinates. In order to compare the results with the two-dimensional approach, we are converting the cartesian coordinates into spherical coordinates using the GlobalSphericalPosition constructor:\n\ntraj = trajectory(x0, v0, ddx_lunar_gravity)\nx_landing_3d = GlobalSphericalPosition(GlobalCartesianPosition(traj[end][4:6]))\n\nGlobalSphericalPosition{Float64}(1.7374e6, 0.018440245307911485, 0.007375546356034736)\n\n\nAgain, we can check that the landing position is on the surface of the Moon by looking at the first component of the output: 1.7374e6, which is the radius of the Moon in meters. Without any complicated methods, we can already see that the two results are very similar, up to about the fifth decimal place for the angular arguments."
  },
  {
    "objectID": "additionals/essentials/package_installation/index.html#installation",
    "href": "additionals/essentials/package_installation/index.html#installation",
    "title": "ExESS Package Installation",
    "section": "Installation",
    "text": "Installation\nThis simulation tool was created as a custom package for the computer language Julia. Please refer to the official guide to installing Julia on your machine. To be able to use the ExESS package, the entire repository has to be downloaded from LRZ-GitLab. Afterward, the code can be used in several different ways. The entire module can be included directly by specifying the path of the downloaded package in the include call.\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#structure",
    "href": "additionals/code_examples/mc_simulation/index.html#structure",
    "title": "Monte Carlo Simulation",
    "section": "Structure",
    "text": "Structure\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Basic Monte Carlo model structure.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n    \n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n    decision/.style={draw, diamond, aspect=2, thick, rounded corners=2pt, inner sep=3pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (START) at (0,0) {Start of Monte Carlo Simulation};    \n    \\node[main, below = 1 of START] (INIT) {\\n{Initialization of Monte Carlo \\\\ Simulation (e.g. setting of \\\\ global parameters)}};\n    \\node[decision, below = 1 of INIT] (CHECKSTEP) {};\n    \\node[main, below = 1 of CHECKSTEP, very thick] (STEP) {\\n{\\vspace{5mm}\\\\\\textbf{Monte Carlo Step}\\\\\\vspace{5mm}}};\n    \\node[main, right = 1 of STEP] (END) {\\n{End of\\\\Monte Carlo Simulation}};\n\n\n    %::. connections\n    \\draw[-latex, thick] (START) -- (INIT);\n    \\draw[-latex, thick] (INIT) -- node[midway, right] {$i=1$} (CHECKSTEP);\n    \\draw[-latex, thick] (CHECKSTEP) -- node [midway, right] {$i\\leq N$} (STEP);\n    \\draw[-latex, thick] (STEP.250) |- ($(STEP.250) + (-2, -1)$) |- node[near start, left] {$i\\mapsto i+1$} (CHECKSTEP.180);\n    \\draw[-latex, thick] (STEP.290) -- ($(STEP.290) + (0, -1.3)$) node[at end, below] {\\n{\\emph{save step }\\\\\\emph{results in file}}};\n    \\draw[-latex, thick] (CHECKSTEP.0) -| node[near start, above] {$i&gt;N$} (END.90);\n\n\\end{tikzpicture}"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#code",
    "href": "additionals/code_examples/mc_simulation/index.html#code",
    "title": "Monte Carlo Simulation",
    "section": "Code",
    "text": "Code\n\nfunction solvemontecarlo(step::Function, N::Int)\n    results = []\n    for i in 1:N\n        push!(results, step())\n    end\n    return results\nend\n\nsolvemontecarlo (generic function with 1 method)\n\n\n\nExample – Estimating Pi\n\nfunction step()\n    x, y = rand(2)*2 .- 1\n    return x^2 + y^2 &lt;= 1 ? 1 : 0\nend\n\nstep (generic function with 1 method)\n\n\nWhat does this specific stepping function do? It draws two positional arguments, x and y, from a uniform distribution between -1 and 1. Then it checks whether the point is inside the unit circle. If so, it returns 1, otherwise 0. The result is a vector of 1s and 0s, which can be interpreted as a Bernoulli distribution. The results look something like this:\n\n Figure Julia\n\n\n\n\n\n\n\n\n\nN=100\n\n\n\n\n\n\n\nN=1000\n\n\n\n\n\n\n\n\n\nN=10000\n\n\n\n\n\n\n\nN=100000\n\n\n\n\nFigure 2: Green points are inside the unit circle, red points are outside.\n\n\n\n\nusing CairoMakie\nfunction plotMC(N::Integer)\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        aspect=DataAspect())\n    for _ in 1:N\n        x, y = rand(2)*2 .- 1\n        if x^2 + y^2 &lt;= 1\n            scatter!(ax, x, y, color=:green)\n        else\n            scatter!(ax, x, y, color=:red)\n        end\n    end\n    xlims!(ax, (-1,1))\n    ylims!(ax, (-1,1))\n    save(joinpath(@__DIR__, @sprintf(\"%07i.png\", N)), fig, px_per_unit=4)\n    return nothing\nend\nplotMC.([100,1000,10000,100000])\nNote that the code above uses a custom theme loaded in the preamble of the document.\n\n\n\nWe can now use the results to estimate the value of \\(\\pi\\). The area of the unit circle is \\(\\pi\\), the area of the square is 4. The ratio of the areas is thus \\(\\pi/4\\). The ratio of the number of points inside the circle to the total number of points is an estimate of the ratio of the areas. We can thus estimate \\(\\pi\\) as follows:\n\nusing Statistics\nres = solvemontecarlo(step, 1_000_000)\nµ = mean(res)\npi_estimation = µ * 4\n\n3.14366\n\n\n\n\nAdditional Packages\nTwo important packages that can improve the workflow with Monte Carlo simulations are ProgressMeter and Distributed. The former allows to display of a progress bar, the latter allows simulating in parallel on multiple cores/workers. Both packages offer a simple interface that can be used through a macro that can be placed in front of the for-loop inside of the Monte Carlo solving function:\n# progress meter and parallel computing\n@showprogress @distributed for i in 1:N \n\n# only progress meter\n@showprogress for i in 1:N\n\n# only parallel computing\n@distributed for i in 1:N"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#structure-1",
    "href": "additionals/code_examples/mc_simulation/index.html#structure-1",
    "title": "Monte Carlo Simulation",
    "section": "Structure",
    "text": "Structure"
  },
  {
    "objectID": "additionals/code_examples/mc_simulation/index.html#code-1",
    "href": "additionals/code_examples/mc_simulation/index.html#code-1",
    "title": "Monte Carlo Simulation",
    "section": "Code",
    "text": "Code"
  },
  {
    "objectID": "documentation/appendix/referenced_values.html",
    "href": "documentation/appendix/referenced_values.html",
    "title": "Appendix A. Referenced Values",
    "section": "",
    "text": "The following contains a comprehensive list of referenced\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  }
]