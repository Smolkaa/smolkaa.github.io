[
  {
    "objectID": "index.html#m.sc.-alexander-smolka",
    "href": "index.html#m.sc.-alexander-smolka",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "M.Sc. Alexander Smolka",
    "text": "M.Sc. Alexander Smolka\n\n\nProfessorship of Lunar and Planetary Exploration Technologies\nTUM School of Engineering and Design\nTechnical University of Munich\nPhone: +49 (89) 289 - 55681\nEmail: a.smolka@tum.de\nPublications\n\nA. Smolka, D. Nikolić, C. Gscheidle, and P. Reiss, “Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions,” Icarus, vol. 397, p. 115508, Jun. 2023, DOI: 10.1016/j.icarus.2023.115508."
  },
  {
    "objectID": "index.html#guides",
    "href": "index.html#guides",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Guides",
    "text": "Guides\n\n\n\n  \n  \n    Student Thesis: On-Boarding Checklist is recommended for all new students to get started with their university thesis and working with the ExESS package\n  \n \n\n\n\n\n  \n  \n    ExESS Package Installation describes how to install the ExESS package on your computer\n  \n \n\n\n\n  \n  \n    Julia Programming Language: Links & Resources contains links to the most important resources for learning the Julia programming language, including a subset of important packages for scientific computing, used in and together with the ExESS package\n  \n \n\n\n\n  \n  \n    Git Essentials lists some external links to resources for learning the Git version control system"
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "Code Examples",
    "text": "Code Examples\n\nMonte-Carlo Simulation\nComparison of Landing Position Calculations: 2D vs. 3D"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#type-structure",
    "href": "api/grids/global_structured_2d_grids.html#type-structure",
    "title": "Global, Structured, 2D Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#usage",
    "href": "api/grids/global_structured_2d_grids.html#usage",
    "title": "Global, Structured, 2D Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#api",
    "href": "api/grids/global_structured_2d_grids.html#api",
    "title": "Global, Structured, 2D Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalStructured2DGrid – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over a sphere of radius r.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_EqSim([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_Reduced – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_Reduced{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_Reduced([T::Type,] r::Real, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the sphere radius r. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nVector{Int64}\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_Reduced_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_Reduced_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_Reduced_EqSim([T::Type,] r::Real, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nVector{Int64}\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2]."
  },
  {
    "objectID": "api/base/cs.html",
    "href": "api/base/cs.html",
    "title": "Coordinate Systems",
    "section": "",
    "text": "Coordinates in ExESS are implemented as their custom, three-dimensional vectors, which are based on their scope, the coordinate system, and their physical type. The scope can either be Global[...] or Local[...], which is referring to a fixed planetary system or a local reference frame, respectively. The coordinate system is either [...]Cartesian[...] or [...]Spherical[...], which is referring to a Cartesian or spherical coordinate system, respectively. The physical type is either [...]Position or [...]Velocity, which is referring to a position or velocity vector, respectively."
  },
  {
    "objectID": "api/base/cs.html#type-structure",
    "href": "api/base/cs.html#type-structure",
    "title": "Coordinate Systems",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractCoordinates\n    │\n    ├─ AbstractPosition\n    │  ├─ GlobalCartesianPosition{T&lt;:Real}\n    │  └─ GlobalSphericalPosition{T&lt;:Real}\n    │\n    └─ AbstractVelocity\n       ├─ GlobalCartesianVelocity{T&lt;:Real}\n       ├─ LocalCartesianVelocity{T&lt;:Real}\n       └─ GlobalSphericalVelocity{T&lt;:Real}\nMore information on the mathematical description of the different coordinate vectors and the mathematical foundation for the conversion functions are presented in Cartesian and Spherical Coordinates."
  },
  {
    "objectID": "api/base/cs.html#usage",
    "href": "api/base/cs.html#usage",
    "title": "Coordinate Systems",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/cs.html#api",
    "href": "api/base/cs.html#api",
    "title": "Coordinate Systems",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalCartesianPosition – Struct\n\n\n\n\n\n[1] GlobalCartesianPosition(x::Real, y::Real, z::Real)\n[2] GlobalCartesianPosition(X::AbstractVector)\n[3] GlobalCartesianPosition(x::AbstractPosition)\nThree dimensional, global, cartesian position vector [1]. Converts vector or other position type into GlobalCartesianPosition [2,3].\n[1] GlobalCartesianPosition(sol::ODESolution, [idx::Integer])\n[2] GlobalCartesianPosition(sol::ODESolution, t::Real)\n[3] GlobalCartesianPosition(sol::ODESolution, t::AbstractVector)\nExtracts GlobalCartesianPosition from ODESolution at given index, all indexes, time or times. Note that this constructor assumes the solution object to be from a SecondOrderODEProblem, where the components of the solution vector are ordered as [vx, vy, vz, x, y, z].\n\n\n\n\n\n\n\n\n\n\nGlobalSphericalPosition – Struct\n\n\n\n\n\n[1] GlobalSphericalPosition(r::Real, theta::Real, phi::Real)\n[2] GlobalSphericalPosition(X::AbstractVector)\n[3] GlobalSphericalPosition(x::AbstractPosition)"
  },
  {
    "objectID": "api/base/constants.html#usage",
    "href": "api/base/constants.html#usage",
    "title": "Constants",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/constants.html#api",
    "href": "api/base/constants.html#api",
    "title": "Constants",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nBase - Constants\n\n\n\n\n\nAVOGADRO_CONSTANT:         6.022141e+23 [mol-1]\nBOLTZMANN_CONSTANT:        1.380650e-23 [m2 kg s-2 K-1]\nELEMENTARY_CHARGE:         1.602177e-19 [C]\nGRAVITATIONAL_CONSTANT:    6.674080e-11 [m3 kg-1 s-2]\nPLANCK_CONSTANT:           6.626070e-34 [m2 kg s-1]\nSTEFAN_BOLTZMANN_CONSTANT: 5.670000e-08 [W m-2 K-4]\nUNIVERSAL_GAS_CONSTANT:    8.314463e+00 [J K-1 mol-1]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - Particle Masses\n\n\n\n\n\nAMU_H:                     1.007975 [u]\nAMU_He:                    4.002602 [u]\nAMU_O:                    15.999400 [u]\nAMU_Ne:                   20.179700 [u]\nAMU_Ar:                   39.877500 [u]\n\nAMU_H2:                    2.015950 [u]\nAMU_OH:                   17.007375 [u]\nAMU_H2O:                  18.015350 [u]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - The Moon\n\n\n\n\n\nLUNAR_DAY:                 2.548800e+06 [s]\nLUNAR_MASS:                7.247673e+22 [kg]\nLUNAR_RADIUS:              1.737400e+06 [m]\nLUNAR_g0:                  1.602472e+00 [m s-2]\nLUNAR_vesc:                2.359718e+03 [m s-1]"
  },
  {
    "objectID": "api/exospheres/trajectory.html",
    "href": "api/exospheres/trajectory.html",
    "title": "Trajectory",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/exospheres/trajectory.html#usage",
    "href": "api/exospheres/trajectory.html#usage",
    "title": "Trajectory",
    "section": "Usage",
    "text": "Usage\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\nv0 = GlobalCartesianVelocity(100, 0, 0)\nddx = ddx_lunar_gravity\ntraj = trajectory(x0, v0, ddx)"
  },
  {
    "objectID": "api/exospheres/trajectory.html#examples",
    "href": "api/exospheres/trajectory.html#examples",
    "title": "Trajectory",
    "section": "Examples",
    "text": "Examples\n\n\n\n\n\n\n   3D Ballistic Trajectory Calculation\n\n\n\n\n\n\nPreparation\nFirstly, the following examples were executed using the following Julia version:\n\nversioninfo()\n\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 2 on 8 virtual cores\n\n\nNext, the locally available ExESS package has to be loaded to access the trajectory function:\n\ninclude(path_to_exess)\nusing .ExESS\n\n\n\nInputs\nLet us define all required inputs for the trajectory calculation. If you are unsure about how the function works, you can type julia&gt; ?trajectory in the REPL to get a description of the function and its arguments.\nApart from the key-word arguments, the function requires the following inputs:\n\nx0: Initial position vector in Cartesian coordinates (m)\nv0: Initial velocity vector in Cartesian coordinates (m/s)\nddx: Acceleration function (m/s2)\n\nThe docstring (see ?trajectory) shows that these inputs can be of different types, either vectors (AbstractVector) or positions (AbstractPosition). The latter are custom types defined in the ExESS package to distinguish one three-dimensional in a certain coordinate space from another. The following example shows how to use the GlobalCartesianPosition.\nWe create a GlobalCartesianPosition object with the initial position vector, located at [LUNAR_RADIUS, 0, 0], in other words: on the surface of a sphere with radius LUNAR_RADIUS.\n\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\n\nGlobalCartesianPosition{Float64}(1.7374e6, 0.0, 0.0)\n\n\nNext, the initial velocity vector is defined. We use the GlobalCartesianVelocity type to define a velocity vector in the same coordinate system as the position vector. Here, we only use a velocity in the x-direction, with a magnitude of 100 m/s.\n\nv0 = GlobalCartesianVelocity(100, 0, 0)\n\nGlobalCartesianVelocity{Int64}(100, 0, 0)\n\n\nWithout letting the trajectory calculation run, we can review the initial conditions set. Both the position and the velocity vector are set in the same coordinate system and have non-zero components only in the x-direction. For purely gravitational accelerations, the trajectory should therefore be a straight line in the x-direction.\nWe can test these assumptions by using the ddx_lunar_gravity function, which is a predefined acceleration function for the gravitational acceleration of the Moon. It already has the Moon’s mass and radius defined, so we can use it directly as is. Note that it assumes that every other acceleration is negligible, which might not be true for charged particles in electromagnetic fields.\n\nddx = ddx_lunar_gravity\n\nddx_lunar_gravity (generic function with 2 methods)\n\n\n\n\nSolve the Trajectory\nFinally, we have all the required inputs to calculate the trajectory. Let’s call the function and save the solution in a variable called traj.\n\ntraj = trajectory(x0, v0, ddx)\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation\nt: 7-element Vector{Float32}:\n   0.0\n   0.17253026\n   1.897833\n  19.15086\n  89.02362\n 125.11684\n 125.11684\nu: 7-element Vector{RecursiveArrayTools.ArrayPartition{Float64, Tuple{Vector{Float64}, Vector{Float64}}}}:\n ([100.0, 0.0, 0.0], [1.737401e6, 0.0, 0.0])\n ([99.72352819548777, 0.0, 0.0], [1.7374182291764107e6, 0.0, 0.0])\n ([96.95910868428572, 0.0, 0.0], [1.737587897640642e6, 0.0, 0.0])\n ([69.34166361242546, 0.0, 0.0], [1.7390224279588673e6, 0.0, 0.0])\n ([-42.27453422294352, 0.0, 0.0], [1.739967349345177e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])"
  },
  {
    "objectID": "api/exospheres/trajectory.html#preparation",
    "href": "api/exospheres/trajectory.html#preparation",
    "title": "Trajectory",
    "section": "Preparation",
    "text": "Preparation\nFirstly, the following examples were executed using the following Julia version:\n\nversioninfo()\n\nJulia Version 1.9.3\nCommit bed2cd540a1 (2023-08-24 14:43 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 8 × Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake)\n  Threads: 2 on 8 virtual cores\n\n\nNext, the locally available ExESS package has to be loaded to access the trajectory function:\n\ninclude(path_to_exess)\nusing .ExESS"
  },
  {
    "objectID": "api/exospheres/trajectory.html#inputs",
    "href": "api/exospheres/trajectory.html#inputs",
    "title": "Trajectory",
    "section": "Inputs",
    "text": "Inputs\nLet us define all required inputs for the trajectory calculation. If you are unsure about how the function works, you can type julia&gt; ?trajectory in the REPL to get a description of the function and its arguments.\nApart from the key-word arguments, the function requires the following inputs:\n\nx0: Initial position vector in Cartesian coordinates (m)\nv0: Initial velocity vector in Cartesian coordinates (m/s)\nddx: Acceleration function (m/s2)\n\nThe docstring (see ?trajectory) shows that these inputs can be of different types, either vectors (AbstractVector) or positions (AbstractPosition). The latter are custom types defined in the ExESS package to distinguish one three-dimensional in a certain coordinate space from another. The following example shows how to use the GlobalCartesianPosition.\nWe create a GlobalCartesianPosition object with the initial position vector, located at [LUNAR_RADIUS, 0, 0], in other words: on the surface of a sphere with radius LUNAR_RADIUS.\n\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\n\nGlobalCartesianPosition{Float64}(1.7374e6, 0.0, 0.0)\n\n\nNext, the initial velocity vector is defined. We use the GlobalCartesianVelocity type to define a velocity vector in the same coordinate system as the position vector. Here, we only use a velocity in the x-direction, with a magnitude of 100 m/s.\n\nv0 = GlobalCartesianVelocity(100, 0, 0)\n\nGlobalCartesianVelocity{Int64}(100, 0, 0)\n\n\nWithout letting the trajectory calculation run, we can review the initial conditions set. Both the position and the velocity vector are set in the same coordinate system and have non-zero components only in the x-direction. For purely gravitational accelerations, the trajectory should therefore be a straight line in the x-direction.\nWe can test these assumptions by using the ddx_lunar_gravity function, which is a predefined acceleration function for the gravitational acceleration of the Moon. It already has the Moon’s mass and radius defined, so we can use it directly as is. Note that it assumes that every other acceleration is negligible, which might not be true for charged particles in electromagnetic fields.\n\nddx = ddx_lunar_gravity\n\nddx_lunar_gravity (generic function with 2 methods)"
  },
  {
    "objectID": "api/exospheres/trajectory.html#solve-the-trajectory",
    "href": "api/exospheres/trajectory.html#solve-the-trajectory",
    "title": "Trajectory",
    "section": "Solve the Trajectory",
    "text": "Solve the Trajectory\nFinally, we have all the required inputs to calculate the trajectory. Let’s call the function and save the solution in a variable called traj.\n\ntraj = trajectory(x0, v0, ddx)\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation\nt: 7-element Vector{Float32}:\n   0.0\n   0.17253026\n   1.897833\n  19.15086\n  89.02362\n 125.11684\n 125.11684\nu: 7-element Vector{RecursiveArrayTools.ArrayPartition{Float64, Tuple{Vector{Float64}, Vector{Float64}}}}:\n ([100.0, 0.0, 0.0], [1.737401e6, 0.0, 0.0])\n ([99.72352819548777, 0.0, 0.0], [1.7374182291764107e6, 0.0, 0.0])\n ([96.95910868428572, 0.0, 0.0], [1.737587897640642e6, 0.0, 0.0])\n ([69.34166361242546, 0.0, 0.0], [1.7390224279588673e6, 0.0, 0.0])\n ([-42.27453422294352, 0.0, 0.0], [1.739967349345177e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])\n ([-100.0160468921404, 0.0, 0.0], [1.7374e6, 0.0, 0.0])"
  },
  {
    "objectID": "api/exospheres/trajectory.html#api",
    "href": "api/exospheres/trajectory.html#api",
    "title": "Trajectory",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlanding_position – Function\n\n\n\n\n\n[1] landing_position(x0::AbstractVector, v0::AbstractVector; kwargs...)\n[2] landing_position(x0::AbstractPosition, v0::AbstractVelocity; kwargs...)\nCalculates the landing position of a particle starting at position x0 (global spherical coordinates: radius, longitude, latitude), with initial velocity v0 (local cartesian coordinates: x (east), y (north), z (up)), flying on a ballistic trajectory, i.e., only influenced by graviational forces.\nReturns the landing position in global spherical coordinate as r, lon, lat ([1]) or as GlobalSphericalPosition(r, lon, lat) ([2]).\nKey-Word Arguments\n\n\n\nField\nValue\nUnit\nDescription\n\n\n\n\nm\nLUNAR_MASS\n[kg]\nmass of planetary object\n\n\n\nNotes\n\ncalling the function with &lt;:Integer arguments will promote them to Float64\n\nReferences\n\nN. Schörghofer: “USER GUIDE: Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces”, https://github.com/nschorgh/Planetary-Code-Collection\nB. J. Butler, “The migration of volatiles on the surfaces of Mercury and the Moon,” Journal of Geophysical Research, vol. 102, no. E8, pp. 19,283–19,291, Aug. 1997, doi: 10.1029/97JE01347.\n\n\n\n\n\n\n\n\n\n\n\ntrajectory – Function\n\n\n\n\n\n[1] trajectory(x0::AbstractVector, v0::AbstractVector, ddx::Function; kwargs...)\n[2] trajectory(x0::AbstractPosition, v0::AbstractVelocity, ddx::Function; kwargs...)\nCalculate the trajectory of a particle starting at position x0 (global cartesian coordinates), with initial velocity v0 (global cartesian coordinates), given the acceleration function ddx (global cartesian coordinates).\nReturns a ODESolution object as the trajectory.\nKey-Word Arguments\n\n\n\n\n\n\n\n\n\nField\nValue\nUnit\nDescription\n\n\n\n\nalg\nTsit5()\n\nnumerical solver algorithm\n\n\nrmin\nLUNAR_RADIUS\n[m]\nminimum radius of computational domain\n\n\nrmax\n1e9\n[m]\nmaximum radius of computational domain\n\n\ntspan\n(0f0,1f10)\n([s], [s])\ntime span of the integration\n\n\nkwargs\n\n\nadditional key-word arguments\n\n\n\nThe integration terminates if either the minimum or maximum radius is exceeded or if the end of the time span is reached.\nNotes\n\ncalling the function with &lt;:Integer arguments will promote them to Float64\n\n\n\n\n\n\n\n\n\n\n\nddx_lunar_gravity – Function\n\n\n\n\n\n[1] ddx_lunar_gravity(x::AbstractVector, [args...])\nAcceleration function for the lunar gravity."
  },
  {
    "objectID": "api/surfaces/temperature.html",
    "href": "api/surfaces/temperature.html",
    "title": "Temperature",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/surfaces/temperature.html#usage",
    "href": "api/surfaces/temperature.html#usage",
    "title": "Temperature",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/surfaces/temperature.html#api",
    "href": "api/surfaces/temperature.html#api",
    "title": "Temperature",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlunar_surface_temperatures_diviner – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner(lng0::Real)\n[2] lunar_surface_temperatures_diviner(lng0::Real, lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner(lng0::Real, lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner(lng0::Real, xs::GlobalSphericalPosition) \n[5] lunar_surface_temperatures_diviner(lng0::Real, XS::Vector{GlobalSphericalPosition}) \n[6] lunar_surface_temperatures_diviner(lng0::Real, grid::Abstract2DGrid)\nReturns the Diviner measurements based lunar surface temperatures, with the sub-solar point shifted by lng (in radians) from the center.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_diviner_avg – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner_avg()\n[2] lunar_surface_temperatures_diviner_avg(lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner_avg(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner_avg(xs::GlobalSphericalPosition)\n[5] lunar_surface_temperatures_diviner_avg(XS::Vector{GlobalSphericalPosition})\n[6] lunar_surface_temperatures_diviner_avg(grid::Abstract2DGrid)\nReturns the Diviner measurements based averaged lunar surface temperatures.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_BUTLER1997 – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_BUTLER1997(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_BUTLER1997(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_BUTLER1997(xs::GlobalSphericalPosition)\n[4] lunar_surface_temperatures_BUTLER1997(XS::Vector{GlobalSphericalPosition})\n[5] lunar_surface_temperatures_BUTLER1997(grid::Abstract2DGrid)\nCalculates the surface temperature based on the approximation given in Butler, 1997. Takes the SSE coordinates lngs and lats and returns the temperature vector of equal size at the given pair.\nT = 250*cos(Z)^1/4 + 100 on the Sun-side, and T = 100 on the night-side, in kelvin.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_HURLEY2015 – Function\n\n\n\n\n\n[1] lunar_surface_temperatures_HURLEY2015(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_HURLEY2015(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_HURLEY2015(xs::GlobalSphericalPosition)\n[4] lunar_surface_temperatures_HURLEY2015(XS::Vector{GlobalSphericalPosition})\n[5] lunar_surface_temperatures_HURLEY2015(grid::Abstract2DGrid)\nCalculates the lunar surface temperatures based on the analytic formula given in Hurley et al. 2015. All angular arguments are in radians."
  },
  {
    "objectID": "presentations/tsu_seminar/index.html#images-and-tables",
    "href": "presentations/tsu_seminar/index.html#images-and-tables",
    "title": "TSU Mini-Moon Seminar",
    "section": "Images and Tables",
    "text": "Images and Tables\nThe following contains some of the exclusively created images and tables, as well as code and downloads.\n\nLunar Surface Temperatures\n\n Figure Julia Download\n\n\n\n\n\n\n\n\n\n(a) Selenographic coordinate system.\n\n\n\n\n\n\n\n(b) Subsolar (local time) coordinate system.\n\n\n\n\n\n\n\n\n\n(c) Subsolar (local time) coordinate system, averaged.\n\n\n\n\n\n\n\n(d) Subsolar (local time) coordinate system, analytic temperature model by Hurley et al. (2015).\n\n\n\n\nFigure 1: Diviner lunar surface temperature measurements and analytic surface temperature model predictions in selenographic and subsolar (local time) coordinate systems. The static figures include a contour line at \\(100\\,\\mathrm{K}\\) for an improved comparison.\n\n\n\n\nusing Printf\nusing .ExESS\n\n#::. define colormap for figures\ncmap = lipari\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = MyLTGeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction anim_raw_diviner(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n    ga.xticklabelcolor = :white\n    ga.xlabelcolor = :white\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        T = lunar_surface_temperatures_diviner((step-1)*2*pi/steps, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T\n        \n        save(joinpath(@__DIR__, \"anim_raw_diviner\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\n\nfunction anim_raw_diviner_fixed(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        Nstep = floor(Int64, (step-1)*N/steps)\n        T = lunar_surface_temperatures_diviner(Nstep/N * 2pi, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T[vcat(Nstep+1:N, 1:Nstep), :]\n        \n    save(joinpath(@__DIR__, \"anim_raw_diviner_fixed\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\n\nfunction plot_diviner_avg()\n    fig, ga, theta, phi = _default_()\n    \n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner_avg(theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\")\n\n    save(joinpath(@__DIR__, \"diviner_avg.png\"), fig, px_per_unit=4)\n    return nothing\nend\n\nfunction plot_hurley()\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_HURLEY2015(theta, phi)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"hurley2015.png\"), fig, px_per_unit=4)\n    return nothing\nend\nNote that for the animations the generated images have to be converted into an animated .gif image.\n\n\n\n diviner.gif \n diviner_fixed.gif \n diviner_avg.png \n hurley2015.png \n\n\n\n\n\n\nModel Architecture\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 2: The innermost loop of the model architecture handles the individual ballistic transport of exospheric particles. “Escape” and “Cold Trapping” indicate pure loss mechanisms, which remove the respective particles from the simulation. The orange highlighted paths indicate conversion reactions, which act as loss mechanisms for one exospheric species as well as a source mechanism for one or more other species, e.g. the photodissociation of water into atomic hydrogen and hydroxyl.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (LAUNCH) at (0,0) {\\n{Launch particle at $\\sphericalCoordinateAzimuth_0, \\sphericalCoordinateElevation_0$ \\\\ with $\\vec\\velocity \\sim \\Velocity_\\text{MBF}$}};\n    \\node[main, below = 0.8 of LAUNCH] (TRAJECTORY) {\\n{Calculate landing \\\\ position $\\sphericalCoordinateAzimuth_1, \\sphericalCoordinateElevation_1$ \\\\ and time-of-flight $\\Time_f$}};\n    \\node[main, below = 2 of TRAJECTORY] (LAND) {\\n{Landing at $\\sphericalCoordinateAzimuth_1, \\sphericalCoordinateElevation_1$}};\n    \\node[main, below = 0.8 of LAND] (SURF) {\\n{Surface interactions \\\\ at $\\sphericalCoordinateAzimuth_1, \\sphericalCoordinateElevation_1$}};\n\n    %::. main connections\n    \\draw[latex-, thick] (LAUNCH.70) -- +(0,2.5) node[at end, above] {\\n{New particle with \\\\ weight $\\weight = \\weight_0$}};\n\n    \\draw[-latex, thick] (LAUNCH.270) -- (TRAJECTORY.90);\n    \\draw[-latex, thick] (TRAJECTORY.270) -- (LAND.90) node[midway, rotate=90, left, above] {update $w$};\n    \\draw[-latex, thick] (LAND.270) -- (SURF.90);\n    \\draw[-latex, thick] (SURF.270) |- +(-2.5,-0.5) -- node[rotate=90, left, above] {thermal desorption; photodesorption; sputtering} node[midway, rotate=90, left, below] {update $w$} ($(LAUNCH.90)+(-2.5,0.5)$) -| (LAUNCH.110);\n\n    %::. add nodes\n    \\node[right = 2.8 of LAUNCH] (ADD1) {add to $\\surfaceNumberDensity$};\n    \\node[right = 3.2 of LAND] (ADD2) {add to $\\surfaceNumberDensity$};\n\n    %::. add connections\n    \\draw[-latex, thick] (LAUNCH.0) -- (ADD1.180);\n    \\draw[-latex, thick] (LAND.0) -- (ADD2.180);\n\n    %::. loss nodes\n    \\node[right = 3 of TRAJECTORY] (ESCAPE) {\\n{escape}};\n    \\node[right = 3 of SURF] (TRAP) {\\n{cold \\\\ trapping}};\n\n    %::. loss connections\n    \\draw[-latex, thick] (TRAJECTORY) -- (ESCAPE) node[midway, above]{$\\velocity \\geq \\velocity_{esc}$};\n    \\draw[-latex, thick] (SURF) -- (TRAP);\n\n    %::. conversion nodes\n    \\node[below left = 0.5 and -1 of ESCAPE, text=TUMOrange] (PHOTO) {\\textit{\\n{photo- \\\\ dissociation}}};\n    \\node[below left = 0.6 and -1 of TRAP, text=TUMOrange] (CONV) {\\textit{\\n{(sub-) surface \\\\ reaction}}};\n    \\node[below = 0.6 of CONV, text=TUMOrange] (ADPHOTO) {\\textit{\\n{adsorbate \\\\ photodissociation}}};\n\n    \\node[right = 5.5 of LAUNCH, text=TUMOrange] (STORE) {\\textit{\\n{store converted \\\\ particles for \\\\ next iteration}}};\n\n    %::. conversion connections\n    \\draw[-latex, thick, dashed, TUMOrange] (TRAJECTORY.300) |- (PHOTO);\n    \\draw[-latex, thick, dashed, TUMOrange] (SURF.310) |- (CONV);\n    \\draw[-latex, thick, dashed, TUMOrange] (SURF.290) |- (ADPHOTO);\n\n    \\draw[-latex, thick, dashed, TUMOrange] (PHOTO) -| (STORE.250);\n    \\draw[-latex, thick, dashed, TUMOrange] (CONV) -| (STORE.270);\n    \\draw[-latex, thick, dashed, TUMOrange] (ADPHOTO) -| (STORE.290);\n\n    %::. background loop node\n    \\begin{pgfonlayer}{background}\n        \\draw[thick, fill=white!95!black, rounded corners=4pt] ($(LAUNCH.135) - (3,-1.75)$) -| ($(ADPHOTO) + (2.5,11)$) |- ($(ADD1.north west) + (-0.75, 0.3)$) |- ($(ESCAPE.south) + (0, -0.3)$) -| ($(ADPHOTO) + (2.5,6)$) |- ($(ADD2.north west) + (-0.5, 0.3)$) |- ($(TRAP.south) + (0, -0.3)$) -| ($(ADPHOTO) + (2.5,-0.7)$) -| ($(LAUNCH.135) - (3,5)$) -- cycle;\n        \\node[anchor=north east, text=TUMBlueDark] at ($(LAUNCH.90) + (7, 1.75)$) {\\n{\\textbf{Loop I} \\\\ Exospheric Particle Transport \\\\ and Surface Interactions}};\n    \\end{pgfonlayer}\n    \n\\end{tikzpicture}\nNote that the used mathematical symbols and colors are defined in the preamble of the document, e.g. \\newcommand{\\velocity}{v}.\n\n\n\n loop_I.pdf   loop_I.svg   loop_I.png \n\n\n\n\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 3: The second inner loop of the model architecture is iterating new particle launches over every grid element with an individual and grid element area-dependent weight. The orange highlighted path indicates the conversion of the exospheric species into other species, e.g. the photodissociation of water into atomic hydrogen and hydroxyl, which has been carried over from the inner loop, see Figure 2.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (LOOPI) at (0,0) {\\n{\\textbf{Loop I} \\\\ Exospheric Particle Transport \\\\ and Surface Interactions}};\n    \\node[main, above = of LOOPI] (W0) {\\n{Calculate inital \\\\ weight $\\weight_0 = \\dot{\\source}^{(j)}$}};\n    \\node[main, above = of W0] (PREP) {\\n{Prepare start of \\\\ new particle from $k$-th \\\\ grid element at $\\sphericalCoordinateAzimuth_0, \\sphericalCoordinateElevation_0$.}};\n    \\node[right = 1.5 of LOOPI] (SUM) {\\n{Sum the results \\\\ of all particles}};\n\n    %::. main connections\n    \\draw[-latex, thick] (W0.270) -- (LOOPI.90);\n    \\draw[-latex, thick] (PREP.270) -- (W0.90);\n    \\draw[-latex, thick] (LOOPI.240) -- +(0,-0.5) -| ($(PREP.120) + (-3,0.5)$) node[near end, rotate=90, left, above] {escape; cold trapping; $\\weight/\\weight_0$ below treshold} -| (PREP.120) node[near start, above] {$k\\mapsto k+1$};\n    \\draw[-latex, thick] (LOOPI.0) -- (SUM.180);\n\n    \\draw[-latex, thick] (PREP.0) -- +(5,0) node[midway, below]{$k &gt; N_\\text{grid}$};\n\n    %::. conversion node from Loop I\n    \\node[below = 1.5 of LOOPI, text=TUMOrange] (STORE) {\\textit{\\n{store converted \\\\ particles for \\\\ next iteration}}};\n    \\draw[-latex, thick, dashed, TUMOrange] (LOOPI.270) -- (STORE.90);\n\n    %::. input connection\n    \\draw[latex-, thick] (PREP.90) -- +(0,2) node[midway, right, yshift=-7px]{$k=1$} node[at end, above] {\\n{New, $j$-th iteration with \\\\ element $e \\in \\left\\{\\ce{H}, \\ce{H2}, \\ce{OH}, \\ce{H2O}\\right\\}$}};\n\n    %::. background loop node\n    \\begin{pgfonlayer}{background}\n        \\draw[thick, fill=white!95!black, rounded corners=4pt] ($(PREP.135) - (3.5,-1.1)$) -| ($(PREP.0) + (4,0)$) |- ($(SUM.north west) + (-0.5, 1)$) |- ($(LOOPI.south east) + (0,-0.75)$) -| ($(PREP.135) - (3.5,5)$) -- cycle;\n        \\node[anchor=north east, text=TUMBlueDark] at ($(PREP.90) + (6, 1)$) {\\n{\\textbf{Loop II} \\\\ Weighted Launches from \\\\ Numerical Grid}};\n    \\end{pgfonlayer}\n\\end{tikzpicture}\nNote that the used mathematical symbols and colors are defined in the preamble of the document, e.g. \\newcommand{\\velocity}{v}.\n\n\n\n loop_II.pdf   loop_II.svg   loop_II.png \n\n\n\n\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 4: The third loop of the model architecture is iterating over all elements and all iterations of the second loop. The orange highlighted path indicates the conversion of the exospheric species into other species, which has been carried over from the innermost loop, see Figure 2. These converted particles act as a new input of source rates \\(\\dot s\\) for subsequent iterations. Each result of the second loop is summed up to a single result for each element.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (LOOPII) at (0,0) {\\n{\\textbf{Loop II} \\\\ Weighted Launches from \\\\ Numerical Grid}};\n    \\node[main, above = of LOOPII] (ELEMS) {\\n{Prepare start of $j$-th \\\\ iteration of element \\\\ $e \\in \\left\\{\\ce{H}, \\ce{H2}, \\ce{OH}, \\ce{H2O}\\right\\}$}};\n    \\node[main, above = 1.5 of ELEMS] (ITERATION) {\\n{Prepare $j$-th \\\\ iteration: $\\dot\\source^{(j)}$}};\n\n    %::. main connections\n    \\draw[-latex, thick] (ELEMS.270) -- (LOOPII.90);\n    \\draw[-latex, thick] (ITERATION.270) -- (ELEMS.90);\n\n    \\draw[-latex, thick] (LOOPII.240) |- +(-1,-0.5) -| node[near end, left, above, rotate=90] {next element} ($(ELEMS.120) + (-2.1, 0.5)$) -| (ELEMS.120);\n\n    \\draw[-latex, thick, TUMOrange, dashed] (LOOPII.297) |- +(-1,-0.95) -| node[near end, left, below, rotate=90] {\\emph{use converted particles for next $\\dot\\source$}} ($(ITERATION.123) + (-3.425, 0.45)$) -| (ITERATION.123);\n    \\draw[-latex, thick] (LOOPII.300) |- +(-1,-1) -| node[near end, left, above, rotate=90] {sum the results of all particles} ($(ITERATION.120) + (-3.5, 0.5)$) -| (ITERATION.120) node[near start, above] {$j\\mapsto j+1$};\n\n    \\draw[-latex, thick] (ITERATION.0) -- +(5,0) node[midway, below]{$j &gt; N_\\text{iter}$} node[at end, right] {end loop};\n\n    %::. exit node\n    \\node[right = 2 of LOOPII] (SUM) {\\n{Sum the results \\\\ of all iterations}};\n\n    %:: exit node connection\n    \\draw[-latex, thick] (LOOPII.0) -- (SUM.180);\n\n    %::. input connection\n    \\draw[latex-, thick] (ITERATION.90) -- +(0,2) node[midway, right, yshift=-7px]{$j=1$} node[at end, above] {\\n{Next $i$-th \\\\ Monte-Carlo step}};\n\n\n    %::. background loop node\n    \\begin{pgfonlayer}{background}\n        \\draw[thick, fill=white!95!black, rounded corners=4pt] ($(ITERATION.135) - (4.5,-1.1)$) -| ($(ITERATION.0) + (4,0)$) |- ($(SUM.north west) + (-0.5, 1)$) |- ($(LOOPII.south east) + (0,-1.5)$) -| ($(ITERATION.135) - (4.5,5)$) -- cycle;\n        \\node[anchor=north east, text=TUMBlueDark] at ($(ITERATION.90) + (5.2, 1)$) {\\n{\\textbf{Loop III} \\\\ Iterations and Elements}};\n    \\end{pgfonlayer}\n\\end{tikzpicture}\nNote that the used mathematical symbols and colors are defined in the document’s preamble, e.g., \\newcommand{\\velocity}{v}.\n\n\n\n loop_III.pdf   loop_III.svg   loop_III.png \n\n\n\n\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 5: Fourth and outermost loop of the model architecture. This loop handles the actual Monte-Carlo simulation by iterating over all \\(N_{MC}\\) steps, each with an identical setup, and saving the outcome of each step separately to perform any statistical analyses and post-processing afterwards.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (LOOPIII) at (0,0) {\\n{\\textbf{Loop III} \\\\ Iterations and Elements}};\n    \\node[main, above = of LOOPIII] (STEP) {\\n{Start $i$-th \\\\ Monte-Carlo step}};\n    \\node[above = 1.5 of STEP] (START) {Start simulation};\n\n    %::. main connections\n    \\draw[-latex, thick] (STEP.270) -- (LOOPIII.90);\n    \\draw[-latex, thick] (START.270) -- (STEP.90) node[midway, right, yshift=0px]{$i=1$};\n    \\draw[-latex, thick] (LOOPIII.240) |- +(-1,-0.5) -| node[near end, left, above, rotate=90] {sum the results of all iterations} ($(STEP.120) + (-2.1, 0.5)$) -| (STEP.120)  node[near start, above] {$i\\mapsto i+1$};\n\n    %::. save node\n    \\node[below = 1.5 of LOOPIII] (SAVE) {\\n{Save $\\surfaceNumberDensity$ results \\\\ of $i$-th Monte-Carlo step}};\n\n    %:: save node connection\n    \\draw[-latex, thick] (LOOPIII.290) -- (SAVE.70);\n\n    %::. end node\n    \\node[right = 3.5 of STEP] (END) {End simulation};\n\n    %::. end connection\n    \\draw[-latex, thick] (STEP.0) -- (END) node[midway, below]{$i &gt; N_\\text{MC}$};\n\n    %::. postprocessing node\n    \\node[main, double, right = 1.5 of SAVE] (PP) {\\n{Post-processing: \\\\ calculate $\\mean$ and $\\standardDeviation$ of all $\\surfaceNumberDensity^{(i)}$}};\n\n    %::. postprocessing connection\n    \\draw[-latex, thick, double] (SAVE.0) -- (PP.180);\n    \\draw[-latex, thick, double] (END.212) -- (PP);\n\n    %::. background loop node\n    \\begin{pgfonlayer}{background}\n        \\draw[thick, fill=white!95!black, rounded corners=4pt] ($(STEP.90) + (0,1)$) -| ($(STEP.0) + (3.2,0.3)$) -| ($(LOOPIII.0) + (0.25,0)$) |- ($(LOOPIII.270) + (0,-1)$) -| ($(STEP.180) + (-1.5,0)$) |- ($(STEP.90) + (-1,1)$) -- cycle;\n        \\node[anchor=north east, text=TUMBlueDark] at ($(STEP.90) + (4.7, 1)$) {\\n{\\textbf{Loop IV} \\\\ Monte-Carlo Steps}};\n    \\end{pgfonlayer}\n\\end{tikzpicture}\nNote that the used mathematical symbols and colors are defined in the preamble of the document, e.g. \\newcommand{\\velocity}{v}.\n\n\n\n loop_IV.pdf   loop_IV.svg   loop_IV.png \n\n\n\n\n\n\nConversions\n\n\nTable 1: Photoreaction rates and excess energies of selected exospheric species for quiet and active Sun conditions at \\(1\\,\\mathrm{AU}\\) heliocentric distance, based on Huebner et al. (1992). Values in brakets indicate the use of experimental data for particle cross-sections.\n\n\n\n\n\n\n\n\n\n\n\nReaction\nQuiet Sun  Photoreaction Rate  in \\(10^{-7}\\) \\(\\,\\mathrm{s^{\\mathrm{-1}}}\\)\nQuiet Sun  Excess Energy  in \\(\\,\\mathrm{eV}\\)\nActive Sun  Photoreaction Rate  in \\(10^{-7}\\) \\(\\,\\mathrm{s^{\\mathrm{-1}}}\\)\nActive Sun  Excess Energy  in \\(\\,\\mathrm{eV}\\)\n\n\n\n\n1\n\\(\\ce{H +\\nu -&gt; H+ + e-}\\)\n\\(0.726\\)\n\\(3.54\\)\n\\(1.720\\)\n\\(3.97\\)\n\n\n2\n\\(\\ce{H2 +\\nu -&gt; H(1s) +H(1s)}\\)\n\\(\\ce{H2 +\\nu -&gt; H(1s) +H(2s \\text{or} 2p)}\\)\n\\(\\ce{H2 +\\nu -&gt; H2+ + e-}\\)\n\\(\\ce{H2 +\\nu -&gt; H + H+ +e-}\\)\n\n\\(\\Sigma\\)\n\\(0.480\\)\n\\(0.344\\)\n\\(0.541\\)\n\\(0.095\\)\n\n\\(1.460\\)\n\\(8.23\\)\n\\(0.44\\)\n\\(6.56\\)\n\\(24.80\\)\n\n\\(1.090\\)\n\\(0.821\\)\n\\(1.150\\)\n\\(0.279\\)\n\n\\(3.340\\)\n\\(8.22\\)\n\\(0.42\\)\n\\(7.17\\)\n\\(27.00\\)\n\n\n\n17\n\\(\\ce{OH +\\nu -&gt; O(3p) + H}\\)\n\\(\\ce{OH +\\nu -&gt; O(1d) + H}\\)\n\\(\\ce{OH +\\nu -&gt; O(1s) + H}\\)\n\\(\\ce{OH +\\nu -&gt; OH+ + e-}\\)\n\n\\(\\Sigma\\)\n\\((120.00)\\;65.400\\)\n\\((70.10)\\;6.350\\)\n\\((8.33)\\;0.671\\)\n\\((2.43)\\;2.470\\)\n\n\\((200.86)\\;74.891\\)\n\\((2.00)\\;1.27\\)\n\\((7.73)\\;7.90\\)\n\\((10.00)\\;9.80\\)\n\\((19.40)\\;19.10\\)\n\n\\((138.00)\\;71.700\\)\n\\((176.00)\\;15.100\\)\n\\((21.10)\\;1.640\\)\n\\((6.43)\\;6.520\\)\n\n\\((341.53)\\;94.960\\)\n\\((2.14)\\;1.43\\)\n\\((7.74)\\;7.88\\)\n\\((10.00)\\;9.94\\)\n\\((23.60)\\;23.50\\)\n\n\n\n18\n\\(\\ce{H2O +\\nu -&gt; OH + H}\\)\n\\(\\ce{H2O +\\nu -&gt; H2 + O(1d)}\\)\n\\(\\ce{H2O +\\nu -&gt; H + H + O}\\)\n\\(\\ce{H2O +\\nu -&gt; H2O+ + e-}\\)\n\\(\\ce{H2O +\\nu -&gt; H + OH+ + e-}\\)\n\\(\\ce{H2O +\\nu -&gt; H2 + O+ + e-}\\)\n\\(\\ce{H2O +\\nu -&gt; OH + H+ + e-}\\)\n\n\\(\\Sigma\\)\n\\(103.000\\)\n\\(5.970\\)\n\\(7.550\\)\n\\(3.310\\)\n\\(0.554\\)\n\\(0.059\\)\n\\(0.131\\)\n\n\\(120.574\\)\n\\(3.42\\)\n\\(3.84\\)\n\\(0.70\\)\n\\(12.40\\)\n\\(18.60\\)\n\\(36.50\\)\n\\(25.00\\)\n\n\\(176.000\\)\n\\(14.800\\)\n\\(19.100\\)\n\\(8.280\\)\n\\(1.510\\)\n\\(0.221\\)\n\\(0.407\\)\n\n\\(220.318\\)\n\\(4.04\\)\n\\(3.94\\)\n\\(0.70\\)\n\\(15.20\\)\n\\(23.20\\)\n\\(39.80\\)\n\\(30.50\\)"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "href": "documentation/drivers/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/drivers/solar_wind.html#protons-and-electrons",
    "href": "documentation/drivers/solar_wind.html#protons-and-electrons",
    "title": "3.1 Solar Wind",
    "section": "Protons and Electrons",
    "text": "Protons and Electrons\nAbout \\(96\\,\\mathrm{\\%}\\) of all ions are protons (Futaana et al., 2012).\nProton density of the solar wind measured by Mariner 2 varied between \\(\\left(1 - 50\\right)\\,\\mathrm{cm^{\\mathrm{-3}}}\\), with an average daily average of \\(5\\,\\mathrm{cm^{\\mathrm{-3}}}\\) protons (Neugebauer & Snyder, 1966)."
  },
  {
    "objectID": "documentation/drivers/solar_wind.html#ions-and-heavier-elements",
    "href": "documentation/drivers/solar_wind.html#ions-and-heavier-elements",
    "title": "3.1 Solar Wind",
    "section": "Ions and Heavier Elements",
    "text": "Ions and Heavier Elements\nThe majority of the remaining ions are alpha particles, i.e., helium nuclei \\(\\ce{He++}\\), making up about \\(4\\,\\mathrm{\\%}\\) of the solar wind ion particles (Futaana et al., 2012)."
  },
  {
    "objectID": "documentation/drivers/photoreactions.html",
    "href": "documentation/drivers/photoreactions.html",
    "title": "3.3 Photoreactions",
    "section": "",
    "text": "Some Intro"
  },
  {
    "objectID": "documentation/drivers/photoreactions.html#photoionization-rates",
    "href": "documentation/drivers/photoreactions.html#photoionization-rates",
    "title": "3.3 Photoreactions",
    "section": "Photoionization Rates",
    "text": "Photoionization Rates\n\n\n Figure Julia Download\n\n\n\n\n\nFigure 1: Photoionization rates for Hydrogen, Helium, Oxygen, and Neon during the period between 1978 and 2012, derived by a multilinear model of Bochsler et al. (2013). The data is displayed as daily and yearly averages, with the extreme values of the yearly averages highlighted by dashed horizontal lines.\n\n\n\n\nusing DelimitedFiles, Statistics\n\n#::. utility functions\nfunction read_table(path::String=joinpath(@__DIR__, \"photoionization_rates_BOCHSLER2013.csv\"))\n    table = readdlm(path, ',', Float64, '\\n', header=true)\n    return table[1], table[2]\nend\n\nfunction photoionization_rates_BOCHSLER2013(N::Integer)\n    tab, _ = read_table()\n    t, k = tab[:,3], tab[:,N]\n    return t, k\nend\n \nfunction photoionization_rates_BOCHSLER2013(elem::Symbol)\n    N = elem == :H ? 4 :\n        elem == :He ? 5 :\n        elem == :O ? 6 :\n        elem == :Ne ? 7 : error(\"Element not supported\")\n    return photoionization_rates_BOCHSLER2013(N)\nend\n\nH_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(4)\nHe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(5)\nO_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(6)\nNe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(7)\n\n\n#::. postprocessing functions\nfunction smoothing(k::AbstractVector; n=5)\n    return [mean(k[max(1,i-n):min(length(k),i+n)]) for i in 1+n:length(k)-n]\nend\n\n\n#::. plotting functions\nfunction plot_k_all(name::String=\"photoionization_rates_BOCHSLER2013\"; n=5)\n    t, kH  = photoionization_rates_BOCHSLER2013(:H)\n    _, kHe = photoionization_rates_BOCHSLER2013(:He)\n    _, kO  = photoionization_rates_BOCHSLER2013(:O)\n    _, kNe = photoionization_rates_BOCHSLER2013(:Ne)\n\n    t_smooth = t[1+n:end-n]\n    kH_smooth = smoothing(kH; n=n)\n    kHe_smooth = smoothing(kHe; n=n)\n    kO_smooth = smoothing(kO; n=n)\n    kNe_smooth = smoothing(kNe; n=n)\n\n    kH_smooth_max = findmax(kH_smooth)\n    kHe_smooth_max = findmax(kHe_smooth)\n    kO_smooth_max = findmax(kO_smooth)\n    kNe_smooth_max = findmax(kNe_smooth)\n\n    kH_smooth_min = findmin(kH_smooth)\n    kHe_smooth_min = findmin(kHe_smooth)\n    kO_smooth_min = findmin(kO_smooth)\n    kNe_smooth_min = findmin(kNe_smooth)\n\n    #\n    fig = Figure(resolution=(1200,600), fontsize=16)\n\n    ax1 = Axis(fig[1,1]; yticks=[1.0, 1.3, 1.6]); hidexdecorations!(ax1; grid=false);\n    scatter!(ax1, t, kH; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax1, t_smooth, kH_smooth; color=TUMBlack)\n    scatter!(ax1, t_smooth[kH_smooth_max[2]], kH_smooth_max[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax1, t_smooth[kH_smooth_min[2]], kH_smooth_min[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,1], \"Hydrogen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax2 = Axis(fig[2,1]; xlabel=\"Year\", yticks=[1.0, 1.5, 2.0])\n    scatter!(ax2, t, kHe; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax2, t_smooth, kHe_smooth; color=TUMBlack)\n    scatter!(ax2, t_smooth[kHe_smooth_max[2]], kHe_smooth_max[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax2, t_smooth[kHe_smooth_min[2]], kHe_smooth_min[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,1], \"Helium\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax3 = Axis(fig[1,2]; yticks=([3, 5, 7], [\"3.0\",\"5.0\",\"7.0\"])); hidexdecorations!(ax3; grid=false);\n    scatter!(ax3, t, kO; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax3, t_smooth, kO_smooth; color=TUMBlack)\n    scatter!(ax3, t_smooth[kO_smooth_max[2]], kO_smooth_max[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax3, t_smooth[kO_smooth_min[2]], kO_smooth_min[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,2], \"Oxygen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax4 = Axis(fig[2,2]; xlabel=\"Year\", yticks=([2.0, 4.0, 6.0],[\"2.0\",\"4.0\",\"6.0\"]))\n    ld = scatter!(ax4, t, kNe; color=TUMBlueLighter, markersize=2.5)\n    ly = lines!(ax4, t_smooth, kNe_smooth; color=TUMBlack)\n    scatter!(ax4, t_smooth[kNe_smooth_max[2]], kNe_smooth_max[1]; color=TUMBlack)\n    lmax = hlines!(ax4, kNe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax4, t_smooth[kNe_smooth_min[2]], kNe_smooth_min[1]; color=TUMBlack)\n    lmin = hlines!(ax4, kNe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,2], \"Neon\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    Label(fig[:,0], \"Photoionization Rate [10⁻⁷ s⁻¹]\", rotation=pi/2)\n\n\n    da = MarkerElement(color=TUMBlueLighter, marker=:circle, markersize=12)\n    ya = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    mm = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    Legend(fig[0,:], [da,ya,mm], [\"day average\", \"year average\", \"maximum/minimum year averages\"]; orientation=:horizontal)\n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n photoionization_rates_BOCHSLER.png   photoionization_rates_BOCHSLER.pdf \n data.csv"
  },
  {
    "objectID": "documentation/introduction/introduction.html",
    "href": "documentation/introduction/introduction.html",
    "title": "1. Introduction",
    "section": "",
    "text": "Space exploration has always captivated humanity’s imagination, driving scientific inquiry and technological advancement to unprecedented heights. While the Moon’s surface has been a focal point of human exploration, its tenuous exosphere, a fragile envelope of particles and gases, has long remained an understudied frontier. Recent decades have witnessed remarkable strides in our understanding of extraterrestrial exospheres, with a particular focus on the Moon’s exosphere and its intricate interactions with the lunar surface.\nAdvances in space exploration have unveiled the Moon’s exosphere as a realm of astonishing complexity. Notable missions such as the Lunar Reconnaissance Orbiter (LRO) have played a pivotal role in unraveling the mysteries of the lunar exosphere. The orbiter mission has not only provided the most highly resolved images of the Moon’s surface, see Fig. 1 showing high-resolution mosaic images of the lunar’s north and south pole, but the Lyman Alpha Mapping Project (LAMP) (Gladstone et al., 2009) aboard LRO has studied the exosphere by analyzing the scattering of ultraviolet sunlight. Additionally, the Lunar Atmosphere and Dust Environment Explorer (LADEE) mission’s Neutral Mass Spectrometer (NMS) (Benna et al., 2015) provided valuable insights into the composition of the exosphere and its temporal variations. These missions collectively painted a new picture of the Moon - a dynamic world with a delicate exosphere shaped by intricate surface interactions.\nHowever, the first endeavors to investigate the lunar exosphere were already made decades earlier, during the Apollo program, during which the Lunar Atmosphere Composition Experiment (LACE) instrument was deployed on the Moon’s surface by Apollo 17 as part of the Apollo Lunar Surface Experiment Package (ALSEP) (Chang, 1972). LACE marked the first direct detection of exospheric species, capturing trace amounts of noble gases and demonstrating the existence of a lunar atmosphere. This historic endeavor laid the foundation for our present understanding, highlighting the complexity of the lunar exosphere and the need for continued exploration.\nIn the broader scope of planetary science, beyond the lunar realm, lies a captivating tapestry of exospheric phenomena across our solar system. Among these, Mercury, the closest planet to the Sun, has beckoned explorers and researchers alike. Pioneering missions such as NASA’s MESSENGER (MErcury Surface, Space ENvironment, GEochemistry, and Ranging) have revealed the intricate details of Mercury’s exosphere. MESSENGER’s observations have unraveled the complex interplay between the planet’s surface and its tenuous envelope of gases, shedding light on the origins of exospheric constituents and their dynamic behavior in response to solar wind interactions. Through these missions, the study of exospheres extends its reach beyond Earth’s celestial companion, contributing valuable insights to the broader understanding of planetary atmospheres and their interactions with the space environment."
  },
  {
    "objectID": "documentation/introduction/introduction.html#sec-sota",
    "href": "documentation/introduction/introduction.html#sec-sota",
    "title": "1. Introduction",
    "section": "State of the Art",
    "text": "State of the Art\nOne of the first modelers of the lunar exosphere was Hodges et al. (1973), who analysed light noble gases as well as volatile molecular hydrogen and compared their results with data from the Apollo missions. Their Monte-Carlo approach of tracking individual particles through the tenuous atmosphere until eventually lost to one of the implemented loss mechanisms was pioneering work that still inspires new models today. With Chamberlain (1963), Armand (1977), and Huebner et al. (1992) setting the theoretical foundation of exospheric density projections, thermal velocity distributions, and lunar exospheric photoreaction rates, respectively, models became increasingly adapted to predicting number densities in surface-bounded exospheres.\nWhile previously, only single-species simulations with mostly noble gases were performed, Crider & Vondrak (2002) were among the first to investigate the highly reactive hydrogen exosphere, which includes reaction pathways to allow conversions from atomic hydrogen to more complex molecules like water. Their research led to a heightened interest in the role of the planetary surface in exosphere densities and compositions. Farrell et al. (2015), Farrell et al. (2017), B. M. Jones et al. (2018), B. Jones et al. (2021), Tucker et al. (2018), Tucker et al. (2021), Grumpe et al. (2019) are among the leading researchers to investigate the proton/hydrogen interaction with lunar regolith, trying to untangle the highly complex physical and chemical reaction environment of the lunar surface.\nA more complete list of relevant publications about the state-of-the-art modeling approaches regarding surface-bounded exosphere, their respective surface, various involved processes, and auxiliary research can be found in Table 1.\n\n\n\n\n\n\n\nState-of-the-Art - Table 1\n\n\n\n\n\n\n Table LaTeX\n\n\n\n\nTable 1: List of relevant publications about modeling of surface-bounded exospheres, their respective surfaces, or auxiliary research.\n\n\n\n\n\n\nReference\nDescription / Highlights\n\n\n\n\nChamberlain (1963)\nTHEORY EXOSPHERE\n“Planetary coronae and atmospheric evaporation”\n\nanalytical model of density distributions in planetary atmospheres/exospheres\nassumes an isothermal, spherically symmetric, and globally uniform atmosphere\ndeveloped a scaled barometric scaling for exospheric number densities at varying altitudes\n\n\n\nVogel (1966)\nTHEORY EXOSPHERE\n“Molecular fluxes in the lunar atmosphere”\n\ntheoretical model of molecular fluxes in the lunar exosphere\nproposed an analytical framework to calculate elliptical trajectories and the respective landing positions on the Moon\n\n\n\nHodges et al. (1973)\nEXOSPHERE\n“Composition and dynamics of lunar atmosphere”\n\nfirst \\(\\ce{H2}, \\ce{He}, \\ce{Ne}\\), and \\(\\ce{Ar}\\) model of the lunar exosphere\ncompared model results with preliminary Apollo 17 data\n\n\n\nArmand (1977)\nTHEORY\n“Classical theory of desorption rate velocity distribution of desorbed atoms; Possibility of a compensation effect”\n\nproposed the theory of desorption velocity distributions | (Maxwell-Boltzmann Flux Distribution, MBFD)\n\n\n\nSmith et al. (1978)\nEXOSPHERE\n“Monte Carlo modeling of exospheric bodies: Mercury”\n\nMonte-Carlo model of Mercury’s exosphere\nMBFD distributed particle velocities\n\n\n\nHuebner et al. (1992)\nTHEORY\n“Solar photo rates for planetary atmospheres and atmospheric pollutants”\n\nprovides a comprehensive overview of photoreaction rates widely used for modeling the lunar exosphere\n\n\n\nButler (1997)\nTHEORY EXOSPHERE\n“The migration of volatiles on the surfaces of Mercury and the Moon”\n\nMonte-Carlo exosphere model of Mercury and the Moon, specifically \\(\\ce{H2O}\\) and \\(\\ce{CO2}\\)\nproposed an analytic function to approximate the lunar surface temperature\nextension of Vogel (1966) trajectory calculation\n\n\n\nCrider & Vondrak (2002)\nEXOSPHERE\n“Hydrogen migration to the lunar poles by solar wind bombardment of the Moon”\n\nMonte-Carlo simulation of exospheric hydrogen migration on the Moon\nlists a variety of conversion paths for solar wind protons to \\(\\ce{H}\\), \\(\\ce{H2}\\), \\(\\ce{OH}\\), and \\(\\ce{H2O}\\)\ncomments on the high inaccuracies of the implementation of the chemical and physical reactions\n\n\n\nChaufray et al. (2009)\nEXOSPHERE\n“Lunar Argon cycle modeling”\n\nMonte-Carlo model of the lunar argon exosphere\ninvestigated the accumulation of \\(\\ce{Ar}\\) in PSRs\n\n\n\nPoppe et al. (2013)\nEXOSPHERE\n“The self-sputtered contribution to the lunar exosphere”\n\nfirst self-sputtering model of the lunar exosphere\nself-sputtering is a significant source of neutrals (locally comparable to solar wind and micrometeoroid bombardment)\n\n\n\nGrava et al. (2014)\nEXOSPHERE\n“Lunar exospheric argon modeling”\n\nMonte-Carlo model of the lunar argon exosphere, based on Chaufray et al. (2009)\ncompared model predictions with LACE, LAMP, and LADEE measurements\nfound that charge exchange is a relevant argon loss process and that cold-trapping losses are comparable to ionization fluxes\n\n\n\nSchorghofer (2014)\nEXOSPHERE\n“Migration calculations for water in the exosphere of the Moon: dusk-dawn asymmetry, heterogeneous trapping, and D/H fractionation”\n\nMonte-Carlo model of exospheric water migration of the Moon, based on Butler (1997)\npresents a dusk-dawn asymmetry of hydrogenous species\n\n\n\nFarrell et al. (2015)\nSURFACE\n“Solar wind implantation into lunar regolith: hydrogen retention in a surface with defects”\n\nMonte-Carlo model of solar wind implantation into the lunar surface regolith\nsystematically studied distributions of activation energies to simulate hydrogen retention and \\(\\ce{OH}\\) formation\n\n\n\nHurley et al. (2015)\nTHEORY\n“An analytic function of lunar surface temperature for exospheric modeling”\n\npresents an analytic approximation of the lunar surface temperatures based on Diviner measurements\nimproved the analytical approach of Butler (1997)\ntemperature model does not include topographical, temporal, or compositional features\n\n\n\nPrem et al. (2015)\nEXOSPHERE\n“Transport of water in a transient impact-generated lunar atmosphere”\n\nhybrid DSMC approach to investigate water transport in impact-generated lunar atmosphere, combining a continuum description of the dense plume with a Monte-Carlo model of the tenuous water vapor exosphere\nunsteady and three-dimensional simulations\n\n\n\nHurley et al. (2016)\nEXOSPHERE\n“Understanding temporal and spatial variability of the lunar helium atmosphere using simultaneous observations from LRO, LADEE, and ARTEMIS”\n\nMonte-Carlo model of the lunar surface-bounded helium exosphere\nsuggests that endogenic helium provides roughly a third of the Moon’s exospheric helium\nbuilt on previous works by Killen & Ip (1999), Hodges et al. (1973), Butler (1997), Grava et al. (2014), and more\n\n\n\nMoores (2016)\nEXOSPHERE\n“Lunar water migration in the interval between large impacts: heterogeneous delivery to permanently shadowed regions, fractionation, and diffusive barriers”\n\nMonte-Carlo simulation to examine water delivery to lunar PSRs\nimpactor water delivery (based on Prem et al. (2015)) and ballistic migration included as water sources\nexplicitly modeled the high-latitude regions, including several PSRs\nextended Crider & Vondrak (2002) and Schorghofer (2014) for higher latitudes\n\n\n\nFarrell et al. (2017)\nSURFACE\n“The statistical mechanics of solar wind hydroxylation at the Moon, within lunar magnetic anomalies, and at Phobos”\n\nextension of the previous model (Farrell et al., 2015), presents a formalism to statistically describe hydrogen implantation into the lunar surface and subsurface diffusion of \\(\\ce{H}\\) using a Monte-Carlo simulation\nused distributed activation energies in the physical model\n\n\n\nHurley et al. (2017)\nEXOSPHERE\n“Contributions of solar wind and micrometeoroids to molecular hydrogen in the lunar exosphere”\n\nMonte-Carlo model (extension of previous model (Hurley et al., 2016)) to investigate spatial distribution of \\(\\ce{H2}\\) in the lunar exosphere\nexamined the contributions of micrometeoroids and solar wind particles\nfound that micrometeoroids are an insufficient source to reproduce LAMP \\(\\ce{H2}\\) measurements\n\n\n\nJ. A. Kegerreis et al. (2017)\nEXOSPHERE\n“Evidence for a localized source of the argon in the lunar exosphere”\n\nMonte-Carlo model of the lunar \\(\\ce{Ar}\\) exosphere, based on the works of Smith et al. (1978), Hodges et al. (1973), and Butler (1997)\nincludes seasonal effects to study long-term variations\n\n\n\nB. M. Jones et al. (2018)\nSURFACE\n“Solar wind-induced water cycle on the Moon”\n\nchemical kinetics model of lunar surficial \\(\\ce{OH}\\) and \\(\\ce{H2O}\\), investigating the long-term evolution\nbased on solar wind proton delivery as the main source of the simulated water cycle\nfocuses on recombinative desorption as the primary water formation pathway\n\n\n\nPrem et al. (2018)\nTHEORY SURFACE\n“The influence of surface roughness on volatile transport on the Moon”\n\nnumerical thermal model for a rough lunar surface\nextension of Hurley et al. (2015) thermal model\n\n\n\nTucker et al. (2018)\nEXOSPHERE SURFACE\n“Solar wind implantation into the lunar regolith: Monte Carlo simulations of H retention in a surface with defects and the H2 exosphere”\n\nMonte-Carlo-based simulation of solar wind implantation into the lunar lunar regolith to study \\(\\ce{H}\\) retention and implications for the \\(\\ce{H2}\\) exosphere\nmodeled hydrogen diffusion and recombination to \\(\\ce{H2}\\)\nincludes Gaussian distributions of activation energies\nbased on models by Killen & Ip (1999), Farrell et al. (2015), Farrell et al. (2017), and Hurley et al. (2017)\n\n\n\nGrumpe et al. (2019)\nSURFACE\n“Time-of-day-dependent behavior of surficial lunar hydroxyl/water: Observations and modeling”\n\nreaction kinetics model as an extension of Farrell et al. (2015) and Farrell et al. (2017) Monte-Carlo simulation\ninvestigates \\(\\ce{H}\\), \\(\\ce{OH}\\), and \\(\\ce{H2O}\\) concentrations, based on both solar wind and micrometeoroid influx\nincludes a 1D lateral heat conduction model with surface roughness dependence\n\n\n\nKillen et al. (2019)\nEXOSPHERE\n“The lunar neon exosphere seen in LACE data”\n\nMonte-Carlo simulation of the lunar neon exosphere\ncomparison with Apollo 17’s LACE data\nsuggests that theoretical photodissociation losses are too low to reproduce \\(\\ce{Ne}\\) measurements\n\n\n\nPrem et al. (2019)\nEXOSPHERE\n“Coupled DSMC-Monte Carlo radiative transfer modeling of gas dynamics in a transient impact-generated lunar atmosphere”\n\nextension of the Monte-Carlo model of Prem et al. (2015) to include the influence of radiative heat transfer and shielding of an impact-generated atmosphere\napplies new model to simulate a \\(\\ce{H2O}\\) exosphere\nfinds that gas-gas radiative transfer is playing an important role, significantly influencing water vapor transport to the night-side\nincludes a chapter on numerical validations of the presented model\n\n\n\nGrava et al. (2020)\nEXOSPHERE\n“LRO/LAMP observations of the lunar helium exosphere: constraints on thermal accommodation and outgassing rate”\n\nMonte-Carlo simulation of lunar exospheric helium to investigate source rates and thermal accommodation\ncompares modelled \\(\\ce{He}\\) densities with LAMP measurements\nsuggests best description of lunar helium assuming full thermal accommodation and a MBFD distribution of kinetic energies\nfinds that endogenic \\(\\ce{He}\\) provides about 20% of the lunar helium exosphere as compared to solar wind source\n\n\n\nJ. Kegerreis (2020)\nTHEORY EXOSPHERE\n“Planetary giant impacts, simulating collisions and their consequences”\n\nMonte-Carlo simulation of the lunar argon exosphere and comparison with LADEE data\napplied altitude fitting based on Chamberlain (1963) projection model to compare predicted densities with satellite data\nuses the landing position calculation proposed by Butler (1997)\n\n\n\nSchörghofer (2020)\nTHEORY EXOSPHERE\n“Thermodynamics of surface-bounded exospheres”\n\nthermodynamical investigation of exospheric densities based on various velocity distributions\nprovides statistical averaged and exact solutions for short ballistic flights, assuming constant gravitational acceleration\n\n\n\nGrava et al. (2021)\nREVIEW EXOSPHERE\n“Volatiles and refractories in surface-bounded exospheres in the inner solar system”\n\nreview of exospheric models of surface-bounded exospheres in the inner solar system, focusing on the Moon and Mercury\nconsiders various volatiles, refractories, ions, and ENAs\n\n\n\nB. Jones et al. (2021)\nSURFACE\n“Thermal evolution of water and hydrogen from Apollo lunar regolith grains”\n\nsimulated TPD process and comparison with TPD experiment\nconsidered several hydrogen-based species and their concentrations on the surface, in the subsurface and void space subsurface, and in gaseous form\nspecifically discussed recombinative desorption as the main pathway of water formation\n\n\n\nSarantos & Tsavachidis (2021)\nSURFACE\n“Lags in desorption of lunar volatiles”\n\ncomputer-generated lunar regolith packing to model random walks of argon and water particles to simulate gas transport\nsuggests subsurface diffusion and desorption-readsorption of gas particles leads to a lag in the exospheric density signature\n\n\n\nSchörghofer et al. (2021)\nREVIEW SURFACE\nEXOSPHERE\n“Water group exospheres and surface interactions on the Moon, Mercury, and Ceres”\n\nreview of hydrogen-based exospheric particles and their interaction with their planetary surface\nreports on the status of observations, theory, and laboratory measurements\n\n\n\nTucker et al. (2021)\nSURFACE EXOSPHERE\n“On the effect of magnetospheric shielding on the lunar hydrogen cycle”\n\nMonte-Carlo model to investigate \\(\\ce{H}\\) implantation, conversion to \\(\\ce{OH}\\), and subsequent outgassing of \\(\\ce{H2}\\)\nsimulates the Moon’s passage through Earth’s magnetotail, eliminating the solar wind proton source, to which the hydrogen both on the surface as well as in the exosphere respond quickly\ngeneral model based on previous work of Tucker et al. (2018)\n\n\n\nMorrissey et al. (2022)\nSURFACE\n“Simulating the diffusion of hydrogen in amorphous silicates: a ‘jumping’ migration process and its implications for solar wind implanted lunar volatiles”\n\nmolecular dynamics simulation to describe the \\(\\ce{H}\\) movement in amorphous silica on an atomistic level\nuses insights to infer hydrogen diffusion in planetary regoliths\nexamines the degassing of water group particles and its influence on the lunar exosphere\nbaseline comparison with previous models of Farrell et al. (2015), Farrell et al. (2017), B. Jones et al. (2021), and Tucker et al. (2021)\n\n\n\nPoppe et al. (2022)\nEXOSPHERE\n“A comprehensive model for pickup ion formation at the Moon”\n\ntwo-part analytic model describing the lunar exospheric neutrals density distributions and the ionization and charged-particle dynamics of pickup ions based on the modeled neutral distributions\nincludes 18 different exospheric ion species\n\n\n\nSchörghofer (2022)\nTHEORY EXOSPHERE\n“Statistical thermodynamics of surface-bounded exospheres”\n\nbuilding on Schörghofer (2020)\nprovides an analytic description of velocity distributions and exact solutions for emerging density profiles\n\n\n\nWurz et al. (2022)\nREVIEW THEORY\nSURFACE\n“Particles and Photons as Drivers for Particle Release from the Surfaces of the Moon and Mercury”\n\nreview of surface interactions of exospheric particles\nincludes space weathering, thermal releases, MMIV, PSD and ESD, physical and chemical sputtering, and particle reflections\n\n\n\nMilillo (2023)\nREVIEW EXOSPHERE\nSURFACE\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSchörghofer & Rufu (2023)\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSchörghofer (2023)\n“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”\n\n\nSmolka et al. (2023)\nEXOSPHERE\n“Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions”\n\nMonte-Carlo simulation framework to simultaneously model multiple hydrogen-based exospheric species\nincludes several, uncertain conversion reactions, coupling the species with each other\nsuggests that surface reaction with hydrogen can significantly change exospheric dynamics around the terminator regions\n\n\n\nTeolis et al. (2023)\nREVIEW EXOSPHERE\nSURFACE\n“Surface exospheric interactions”\n\nreview of descriptions, current developments, and issues of exosphere-surface interactions\nincludes discussions of thermal accommodation, volatile diffusion, and cold-trapping\n\n\n\n\n\n\n\n\\setlength\\LTleft{0pt}\n\\setlength\\LTright{0pt}\n\\footnotesize\n\\begin{longtable}{@{}p{.25\\textwidth} p{.73\\textwidth}@{}}\n    \\toprule\n    Reference(s), \\emph{Tags} & \\textbf{Title}, Description/Highlights \\\\\n    \\midrule\n    \\endhead\n    \\bottomrule\n    \\endfoot\n\n    \\citet{Chamberlain1963}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Planetary coronae and atmospheric evaporation\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item analytical model of density distributions in planetary atmospheres/exospheres\n        \\item assumes an isothermal, spherically symmetric, and globally uniform atmosphere\n        \\item developed a scaled barometric scaling for exospheric number densities at varying altitudes\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Vogel1966}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Molecular fluxes in the lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item theoretical model of molecular fluxes in the lunar exosphere\n        \\item proposed an analytical framework to calculate elliptical trajectories and the respective landing positions on the Moon\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hodges1973}\\newline\\emph{Exosphere} & \\textbf{\"Composition and dynamics of lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item first $\\ce{H2}$, $\\ce{He}$, $\\ce{Ne}$, and $\\ce{Ar}$ model of the lunar exosphere\n        \\item compared model results with preliminary Apollo 17 data\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Armand1977}\\newline\\emph{Theory} & \\textbf{\"Classical theory of desorption rate velocity distribution of desorbed atoms; Possibility of a compensation effect\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item proposed the theory of desorption velocity distributions (Maxwell-Boltzmann Flux Distribution, MBF)\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Smith1978}\\newline\\emph{Exosphere} & \\textbf{\"Monte Carlo modeling of exospheric bodies: Mercury\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of Mercury's exosphere\n        \\item MBF distributed particle velocities\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Huebner1992}\\newline\\emph{Theory} & \\textbf{\"Solar photo rates for planetary atmospheres and atmospheric pollutants\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item provides a comprehensive overview of photoreaction rates widely used for modeling the lunar exosphere\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Butler1997}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"The migration of volatiles on the surfaces of Mercury and the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo exosphere model of Mercury and the Moon, specifically $\\ce{H2O}$ and $\\ce{CO2}$   \n        \\item proposed an analytic function to approximate the lunar surface temperature\n        \\item extension of \\citet{Vogel1966} trajectory calculation\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Crider2002}\\newline\\emph{Exosphere} & \\textbf{\"The migration of volatiles on the surfaces of Mercury and the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation of exospheric hydrogen migration on the Moon\n        \\item lists a variety of conversion paths for solar wind protons to $\\ce{H}$, $\\ce{H2}$, $\\ce{OH}$, and $\\ce{H2O}$    \n        \\item comments on the high inaccuracies of the implementation of the chemical and physical reactions\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Chaufray2009}\\newline\\emph{Exosphere} & \\textbf{\"Lunar Argon cycle modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of the lunar argon exosphere\n        \\item investigated the accumulation of $\\ce{Ar}$ in PSRs  \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Poppe2013}\\newline\\emph{Exosphere} & \\textbf{\"The self-sputtered contribution to the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item first self-sputtering model of the lunar exosphere\n        \\item self-sputtering is a significant source of neutrals (locally comparable to solar wind and micrometeoroid bombardment) \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2014}\\newline\\emph{Exosphere} & \\textbf{\"Lunar exospheric argon modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of the lunar argon exosphere, based on \\citet{Chaufray2009}\n        \\item compared model predictions with LACE, LAMP, and LADEE measurements\n        \\item found that charge exchange is a relevant argon loss process and that cold-trapping losses are comparable to ionization fluxes\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schorghofer2014}\\newline\\emph{Exosphere} & \\textbf{\"Migration calculations for water in the exosphere of the Moon: dusk-dawn asymmetry, heterogeneous trapping, and D/H fractionation\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of exospheric water migration of the Moon, based on \\citet{Butler1997}\n        \\item presents a dusk-dawn asymmetry of hydrogenous species \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Farrell2015}\\newline\\emph{Surface} & \\textbf{\"Solar wind implantation into lunar regolith: hydrogen retention in a surface with defects\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of solar wind implantation into the lunar surface regolith\n        \\item systematically studied distributions of activation energies to simulate hydrogen retention and $\\ce{OH}$ formation    \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2015}\\newline\\emph{Theory} & \\textbf{\"An analytic function of lunar surface temperature for exospheric modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item presents an analytic approximation of the lunar surface temperatures based on Diviner measurements\n        \\item improved the analytical approach of \\citet{Butler1997}\n        \\item temperature model does not include topographical, temporal, or compositional features\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2015}\\newline\\emph{Exosphere} & \\textbf{\"Transport of water in a transient impact-generated lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item hybrid DSMC approach to investigate water transport in impact-generated lunar atmosphere, combining a continuum description of the dense plume with a Monte-Carlo model of the tenuous water vapor exosphere\n        \\item unsteady and three-dimensional simulations\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2016}\\newline\\emph{Exosphere} & \\textbf{\"Understanding temporal and spatial variability of the lunar helium atmosphere using simultaneous observations from LRO, LADEE, and ARTEMIS\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of the lunar surface-bounded helium exosphere\n        \\item suggests that endogenic helium provides roughly a third of the Moon's exospheric helium\n        \\item built on previous works by \\citet{Killen1999}, \\citet{Hodges1973}, \\citet{Butler1997}, \\citet{Grava2014}, and more    \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Moores2016}\\newline\\emph{Exosphere} & \\textbf{\"Lunar water migration in the interval between large impacts: heterogeneous delivery to permanently shadowed regions, fractionation, and diffusive barriers\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation to examine water delivery to lunar PSRs\n        \\item impactor water delivery (based on \\citet{Prem2015}) and ballistic migration included as water sources \n        \\item explicitly modeled the high-latitude regions, including several PSRs\n        \\item extended \\citet{Crider2002} and \\citet{Schorghofer2014} for higher latitudes   \n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Farrell2017}\\newline\\emph{Surface} & \\textbf{\"The statistical mechanics of solar wind hydroxylation at the Moon, within lunar magnetic anomalies, and at Phobos\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item extension of the previous model \\citep{Farrell2015}, presents a formalism to statistically describe hydrogen implantation into the lunar surface and subsurface diffusion of $\\ce{H}$ using a Monte-Carlo simulation\n        \\item used distributed activation energies in the physical model\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Hurley2017}\\newline\\emph{Exosphere} & \\textbf{\"Contributions of solar wind and micrometeoroids to molecular hydrogen in the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model (extension of previous model \\citep{Hurley2016}) to investigate spatial distribution of $\\ce{H2}$ in the lunar exosphere  \n        \\item examined the contributions of micrometeoroids and solar wind particles\n        \\item found that micrometeoroids are an insufficient source to reproduce LAMP $\\ce{H2}$ measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Kegerreis2017}\\newline\\emph{Exosphere} & \\textbf{\"Evidence for a localized source of the argon in the lunar exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model of the lunar $\\ce{Ar}$ exosphere, based on the works of \\citet{Smith1978}, \\citet{Hodges1973}, and \\citet{Butler1997}\n        \\item includes seasonal effects to study long-term variations\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Jones2018}\\newline\\emph{Surface} & \\textbf{\"Solar wind-induced water cycle on the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item chemical kinetics model of lunar surficial $\\ce{OH}$ and $\\ce{H2O}$, investigating the long-term evolution\n        \\item based on solar wind proton delivery as the main source of the simulated water cycle\n        \\item focuses on recombinative desorption as the primary water formation pathway\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2018}\\newline\\emph{Surface}\\newline\\emph{Theory} & \\textbf{\"The influence of surface roughness on volatile transport on the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item numerical thermal model for a rough lunar surface\n        \\item extension of \\citet{Hurley2015} thermal model\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Tucker2018}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{\"Solar wind implantation into the lunar regolith: Monte Carlo simulations of H retention in a surface with defects and the H2 exosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo-based simulation of solar wind implantation into the lunar lunar regolith to study $\\ce{H}$ retention and implications for the $\\ce{H2}$ exosphere \n        \\item modeled hydrogen diffusion and recombination to $\\ce{H2}$\n        \\item includes Gaussian distributions of activation energies\n        \\item based on models by \\citet{Killen1999}, \\citet{Farrell2015}, \\citet{Farrell2017}, and \\citet{Hurley2017}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grumpe2019}\\newline\\emph{Surface} & \\textbf{\"Time-of-day-dependent behavior of surficial lunar hydroxyl/water: Observations and modeling\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item reaction kinetics model as an extension of \\citet{Farrell2015} and \\citet{Farrell2017} Monte-Carlo simulation\n        \\item investigates $\\ce{H}$, $\\ce{OH}$, and $\\ce{H2O}$ concentrations, based on both solar wind and micrometeoroid influx\n        \\item includes a 1D lateral heat conduction model with surface roughness dependence\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Killen2019}\\newline\\emph{Exosphere} & \\textbf{\"The lunar neon exosphere seen in LACE data\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation of the lunar neon exosphere\n        \\item comparison with Apollo 17's LACE data\n        \\item suggests that theoretical photodissociation losses are too low to reproduce $\\ce{Ne}$ measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Prem2019}\\newline\\emph{Exosphere} & \\textbf{\"Coupled DSMC-Monte Carlo radiative transfer modeling of gas dynamics in a transient impact-generated lunar atmosphere\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item extension of the Monte-Carlo model of \\citet{Prem2015} to include the influence of radiative heat transfer and shielding of an impact-generated atmosphere\n        \\item applies new model to simulate a $\\ce{H2O}$ exosphere\n        \\item finds that gas-gas radiative transfer is playing an important role, significantly influencing water vapor transport to the night-side\n        \\item \\emph{includes a chapter on numerical validations of the presented model}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2020}\\newline\\emph{Exosphere} & \\textbf{\"LRO/LAMP observations of the lunar helium exosphere: constraints on thermal accommodation and outgassing rate\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation of lunar exospheric helium to investigate source rates and thermal accommodation\n        \\item compares modelled $\\ce{He}$ densities with LAMP measurements\n        \\item suggests best description of lunar helium assuming full thermal accommodation and a MBF distribution of kinetic energies\n        \\item finds that endogenic $\\ce{He}$ provides about $\\SI{20}{\\percent}$ of the lunar helium exosphere as compared to solar wind source\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Kegerreis2020}\\newline\\emph{Exosphere} & \\textbf{\"Planetary giant impacts, simulating collisions and their consequences\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation of the lunar argon exosphere and comparison with LADEE data\n        \\item applied altitude fitting based on \\citet{Chamberlain1963} projection model to compare predicted densities with satellite data\n        \\item uses the landing position calculation proposed by \\citet{Butler1997}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2020}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Thermodynamics of surface-bounded exospheres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item thermodynamical investigation of exospheric densities based on various velocity distributions\n        \\item provides statistical averaged and exact solutions for short ballistic flights, assuming constant gravitational acceleration\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Grava2021}\\newline\\emph{Review}\\newline\\emph{Exosphere} & \\textbf{\"Volatiles and refractories in surface-bounded exospheres in the inner solar system\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of exospheric models of surface-bounded exospheres in the inner solar system, focusing on the Moon and Mercury\n        \\item considers various volatiles, refractories, ions, and ENAs\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Jones2021}\\newline\\emph{Surface} & \\textbf{\"Thermal evolution of water and hydrogen from Apollo lunar regolith grains\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item simulated TPD process and comparison with TPD experiment\n        \\item considered several hydrogen-based species and their concentrations on the surface, in the subsurface and void space subsurface, and in gaseous form\n        \\item specifically discussed recombinative desorption as the main pathway of water formation\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Sarantos2021}\\newline\\emph{Surface} & \\textbf{\"Lags in desorption of lunar volatiles\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item computer-generated lunar regolith packing to model random walks of argon and water particles to simulate gas transport\n        \\item suggests subsurface diffusion and desorption-readsorption of gas particles leads to a lag in the exospheric density signature\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2021}\\newline\\emph{Review}\\newline\\emph{Surface}\\newline\\emph{Exosphere} & \\textbf{\"Water group exospheres and surface interactions on the Moon, Mercury, and Ceres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of hydrogen-based exospheric particles and their interaction with their planetary surface\n        \\item reports on the status of observations, theory, and laboratory measurements\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Tucker2021}\\newline\\emph{Surface}\\newline\\emph{Exosphere} & \\textbf{\"On the effect of magnetospheric shielding on the lunar hydrogen cycle\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo model to investigate $\\ce{H}$ implantation, conversion to $\\ce{OH}$, and subsequent outgassing of $\\ce{H2}$\n        \\item simulates the Moon's passage through Earth's magnetotail, eliminating the solar wind proton source, to which the hydrogen both on the surface as well as in the exosphere respond quickly\n        \\item general model based on previous work of \\citet{Tucker2018}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Morrissey2022}\\newline\\emph{Surface} & \\textbf{\"Simulating the diffusion of hydrogen in amorphous silicates: a ‘jumping’ migration process and its implications for solar wind implanted lunar volatiles\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item molecular dynamics simulation to describe the $\\ce{H}$ movement in amorphous silica on an atomistic level\n        \\item uses insights to infer hydrogen diffusion in planetary regoliths\n        \\item examines the degassing of water group particles and its influence on the lunar exosphere\n        \\item baseline comparison with previous models of \\citet{Farrell2015}, \\citet{Farrell2017}, \\citet{Jones2021}, and \\citet{Tucker2021}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Poppe2022}\\newline\\emph{Exosphere} & \\textbf{\"A comprehensive model for pickup ion formation at the Moon\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item two-part analytic model describing the lunar exospheric neutrals density distributions and the ionization and charged-particle dynamics of pickup ions based on the modeled neutral distributions\n        \\item includes 18 different exospheric ion species\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2022}\\newline\\emph{Theory}\\newline\\emph{Exosphere} & \\textbf{\"Statistical thermodynamics of surface-bounded exospheres\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item building on \\citet{Schoerghofer2020}\n        \\item provides an analytic description of velocity distributions and exact solutions for emerging density profiles\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Wurz2022}\\newline\\emph{Review}\\newline\\emph{Theory}\\newline\\emph{Surface} & \\textbf{\"Particles and Photons as Drivers for Particle Release from the Surfaces of the Moon and Mercury\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of surface interactions of exospheric particles\n        \\item includes space weathering, thermal releases, MMIV, PSD and ESD, physical and chemical sputtering, and particle reflections\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Milillo2023}\\newline\\emph{Review}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{“Future Directions for the Investigation of Surface-Bounded Exospheres in the Inner Solar System”}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2023} & \n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Schoerghofer2023a} & \n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Smolka2023}\\newline\\emph{Exosphere} & \\textbf{\"Coupled H, H2, OH, and H2O lunar exosphere simulation framework and impacts of conversion reactions\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item Monte-Carlo simulation framework to simultaneously model multiple hydrogen-based exospheric species\n        \\item includes several, uncertain conversion reactions, coupling the species with each other\n        \\item suggests that surface reaction with hydrogen can significantly change exospheric dynamics around the terminator regions\n    \\end{itemize} \\\\ \\midrule\n\n    \\citet{Teolis2023}\\newline\\emph{Review}\\newline\\emph{Exosphere}\\newline\\emph{Surface} & \\textbf{\"Surface exospheric interactions\"}\n    \\begin{itemize}\\setlength\\itemsep{-0.7em}\n        \\item review of descriptions, current developments, and issues of exosphere-surface interactions\n        \\item includes discussions of thermal accommodation, volatile diffusion, and cold-trapping\n    \\end{itemize} \\\\ \\midrule\n\\end{longtable}\nPlease note that the code above requires the longtable package and all necessary references in the bibliography."
  },
  {
    "objectID": "documentation/introduction/introduction.html#the-problem-of-scales",
    "href": "documentation/introduction/introduction.html#the-problem-of-scales",
    "title": "1. Introduction",
    "section": "The Problem of Scales",
    "text": "The Problem of Scales\nOne of the most prominent problems for exosphere models is based on the enormous difference in physical scales between relevant processes. While the dimensions of the respective planetary object and its topographic features are around hundreds of kilometers, surface and subsurface processes like particle releases or diffusion are described on micro and sometimes down to atomic scales (Milillo, 2023)."
  },
  {
    "objectID": "documentation/fundamentals/properties_data.html#atomic-weights",
    "href": "documentation/fundamentals/properties_data.html#atomic-weights",
    "title": "2.7 General Properties and Data",
    "section": "Atomic Weights",
    "text": "Atomic Weights\n\n Table LaTeX\n\n\n\n\nTable 1: Subset of standard atomic weights by Prohaska et al. (2022) relevant to this work. The values are provided either as an interval (indicated with to) or as a single value with some measurement uncertainty and natural variation (indicated with +/-).\n\n\n\n\n\n\n\n\n\n\n#\nElement\nSymbol\nValue\n\n\n\n\n\n\n1\nHydrogen\nH\n1.007 840\nto\n1.008 110\n\n\n2\nHelium\nHe\n4.002 602\n+/-\n0.000 002\n\n\n6\nCarbon\nC\n12.009 600\nto\n12.011 600\n\n\n8\nOxygen\nO\n15.999 030\nto\n15.999 770\n\n\n10\nNeon\nNe\n20.179 700\n+/-\n0.000 600\n\n\n18\nArgon\nAr\n39.792 000\nto\n39.963 000\n\n\n\n\n\n\n\\begin{table}[tb]\n    \\centering\n    \\caption{Subset of standard atomic weights by \\citet{Prohaska2022} relevant to this work. The values are provided either as an interval (indicated with \\emph{to}) or as a single value with some measurement uncertainty and natural variation (indicated with $\\pm$.)}\n    \\begin{tabularx}{.99\\textwidth}{r X l X c X}\n        \\toprule\n        \\textbf{\\#} & \\textbf{Element} & \\textbf{Symbol} & \\multicolumn{3}{c}{Standard Atomic Weight} \\\\\n        \\midrule\n         1 & Hydrogen & \\ce{H}    & \\num{1.007840}   & to    & \\num{1.008110} \\\\\n         2 & Helium   & \\ce{He}   & \\num{4.002602}   & $\\pm$ & \\num{0.000002} \\\\\n         6 & Carbon   & \\ce{C}    & \\num{12.009600}  & to    & \\num{12.011600} \\\\\n         8 & Oxygen   & \\ce{O}    & \\num{15.999030}  & to    & \\num{15.999770} \\\\\n        10 & Neon     & \\ce{Ne}   & \\num{20.179700}  & $\\pm$ & \\num{0.000600} \\\\\n        18 & Argon    & \\ce{Ar}   & \\num{39.792000}  & to    & \\num{39.963000} \\\\\n        \\bottomrule\n    \\end{tabularx}\n    \\label{tab:atomic_weights}\n\\end{table}\nThe code above requires the following LaTeX packages: booktabs, mhchem, multirow, siunitx, and tabularx. Additionally, the reference to Prohaska2022 must be available in the respective .bib file."
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html",
    "href": "documentation/fundamentals/numerical_grids.html",
    "title": "2.2 Numerical Grids",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#sec-structured_2d_grids",
    "href": "documentation/fundamentals/numerical_grids.html#sec-structured_2d_grids",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured\nThe global, structured, two-dimensional grid is discretizing the surface of a perfectly spherical body of fixed radius \\(r\\) using a regular, structured grid with a fixed angular resolution \\(\\Delta\\vartheta\\times \\Delta\\varphi\\), in azimuth and elevation direction, respectively. Since the definition includes spherical elements, the grid is created in global spherical coordinates \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\); see the section Cartesian and Spherical Coordinates.\n\n\n GlobalStructuredGrid: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\) - \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\nCoordinate Calculation\nThe spherical coordinates, the azimuth \\(\\vartheta\\) and elevation \\(\\varphi\\), are created as follows: \\[\\begin{alignat}{4}\n    \\vartheta_i &= - \\pi + \\frac{\\pi}{N_\\vartheta} + (i-1)\\Delta\\vartheta& \\quad\\text{for } i \\in \\{1, \\dots, N_\\vartheta\\} & \\quad\\text{with } \\Delta\\vartheta= \\frac{2\\pi}{N_\\vartheta} \\label{eq:gs2dgrid_azimuth} \\\\\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi& \\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\} & \\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi} \\label{eq:gs2dgrid_elevation}\n\\end{alignat}\\] where \\(N_\\vartheta\\) and \\(N_\\varphi\\) define the number of elements in the azimuth and elevation direction, respectively. The created points of the grid are located in the center of each rectangular grid cell, i.e., at \\(\\Delta\\vartheta/ 2 = \\pi /N_\\vartheta\\) and \\(\\Delta\\varphi/ 2 = \\pi / \\left(2N_\\varphi\\right)\\) of each elements sides. Let \\(k\\) be a common index with \\(k = (i-1)N_\\varphi+ j\\), then every grid element’s coordinate can be written as \\(\\boldsymbol{\\mathbf{r}}_k = \\left(r, \\vartheta_i, \\varphi_j\\right)\\).\n\n\n coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\)   surfacecoords: identical to coords\n\n\n\n\n\n\nAzimuth Periodicity\n\n\n\nDue to the \\(2\\pi\\)-periodicity of the azimuth angle \\(\\vartheta\\), the structure, which is the constant \\(\\Delta\\vartheta\\) angular distance between elements, has to be shown across its periodic boundaries: \\[\\begin{align*}\n    \\vartheta_1 + 2\\pi - \\vartheta_{N_\\vartheta} &= \\left(- \\pi + \\frac{\\pi}{N_\\vartheta}\\right) + 2\\pi - \\left(- \\pi + \\frac{\\pi}{N_\\vartheta} + (N_\\vartheta-1)\\frac{2\\pi}{N_\\vartheta} \\right) = \\frac{2\\pi}{N_\\vartheta} = \\Delta\\vartheta\n\\end{align*}\\]\n\n\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 1: Global, structured, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e., radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_2d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_proj(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_3d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if abs(theta) &gt;= 90; continue; end\n        theta -= 180/N_theta\n        x = [cosd(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [sind(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        z = [sin(x) for x in range(-pi/2,pi/2,100)]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all()\n    gs2dgrid_2d(20,10)\n    gs2dgrid_proj(20,10)\n    gs2dgrid_3d(20,10)\nend\n\n\nFor standalone figures to produce .svg files, use the following code:\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nFor the use in a document, use the following code:\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0pt,0pt) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_2d.pdf}};\n    \\node[below right = 0 and -5 of 2d] (proj) {\\includegraphics[width=0.5\\textwidth]{./gs2dgrid_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -1.4 and -3 of proj] (3d) {\\includegraphics[width=0.4\\textwidth, trim={0 30pt 0 0}, clip]{./gs2dgrid_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] (3d.70) to [in=0, out=90] node[near end, xshift=-20, yshift=25]{\\footnotesize{spherical projection}} (2d.15);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, xshift=30, yshift=-25]{\\footnotesize{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nFor both versions, please ensure that the used .pdf files are at the correct location.\n\n\n\n figure.svg \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\nFigure 1 shows an example of a spherical surface discretization based on the global, structured, two-dimensional grid. Elements were created based on Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\) with \\(N_\\vartheta= 20\\) elements in azimuth and \\(N_\\varphi= 10\\) elements in elevation, leading to a total of \\(200\\) grid elements and, thus, coordinates \\(\\boldsymbol{\\mathbf{r}}_k\\) for \\(k\\in\\{1,\\dots,200\\}\\). The grid resolution is \\(\\Delta\\vartheta\\times\\Delta\\varphi= 18\\,\\mathrm{\\degree}\\times18\\,\\mathrm{\\degree}\\). The figure shows three different views of the same numerical discretization. The top left in a conventional axis making use of the two-dimensionality of the grid, with the azimuth angle \\(\\vartheta\\) on the horizontal axis and the elevation angle \\(\\varphi\\) on the vertical axis. This view highlights the structured nature of the discretization scheme with equally resolved angular elements across the entire domain. The centered graph is a projected view of the spherical coordinates, visualized on a flattened spherical surface based on a projection method (Jenny et al., 2008). While this flattened surface is neither a conformal nor an equal-area projection of an actual sphere, it provides a good and easily understandable visual representation of the spherical nature of the grid. The structure of the discretization scheme is still visible, while the accumulation of grid elements in the polar region becomes apparent. This accumulation is a direct result of the spherical nature of the grid, where the same angular resolution \\(\\Delta\\vartheta\\times\\Delta\\varphi\\) leads to a smaller area of the grid elements in the polar region. The bottom right graph depicts the same discretization scheme in a conventional, cartesian coordinate system, which shows the grid in its physical, three-dimensional form, where the polar grid elements are undistorted. Note that this last representation of the grid only shows half of the sphere (\\(x&gt; 0\\)) since the other half is identical due to the symmetry of the spherical coordinate system.\nThe transformation from one of the visualizations to another is termed either a or a in Figure 1, depending on the type of coordinate system of the destination. The compilation of the three shown views helps to understand both the structural nature of the grid and the general downside of using such a simple discretization scheme, i.e., the clumping of elements around the poles. As already apparent from the area calculation seen in Eq. \\(\\eqref{eq:area_gs2dgrid}\\), the surface coverage of each element on the same elevation is equal, while it decreases with \\(\\sin\\varphi\\rightarrow 0\\) towards the poles.\n\n\nArea Calculation\nWith the same index notation, the area of each spherical grid element can be calculated as the integral over its angles at each angular position: \\[\\begin{align}\n    A_k &= \\int_{\\vartheta_i-\\frac{\\Delta\\vartheta}{2}}^{\\vartheta_i+\\frac{\\Delta\\vartheta}{2}} \\int_{\\varphi_j-\\frac{\\Delta\\varphi}{2}}^{\\varphi_j+\\frac{\\Delta\\varphi}{2}} r^2 \\cos \\left( \\varphi\\right) d\\varphi d\\vartheta\\\\\n    \\Rightarrow\\qquad A_k &= r^2 \\cdot \\Delta\\vartheta\\cdot \\left(\\sin\\left(\\varphi_j + \\frac{\\Delta\\varphi}{2}\\right) - \\sin\\left(\\varphi_j - \\frac{\\Delta\\varphi}{2}\\right)\\right).\n    \\label{eq:area_gs2dgrid}\n\\end{align}\\] Note that the definition for the area is independent of the azimuth angle \\(\\vartheta\\), thus equal across all \\(N_\\vartheta\\) elements in the azimuth direction.\n\n\n areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)\n\n\nContinuous to Discrete Mapping\nIn many applications of numerical grids, it is necessary to map coordinates in the continuous domain to the discrete grid points, i.e., to find the grid element the continuous coordinate is located in. For the structural grid, the problem can be defined in terms of the shared index \\(k\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\boldsymbol{\\mathbf{r}}_k = \\left[r, \\vartheta_k, \\varphi_k\\right]^T\\), or in terms of the individual indices \\(i\\) and \\(j\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\left[r, \\vartheta_i, \\varphi_j\\right]\\) with \\(k = (i-1)N_\\varphi+ j\\). The latter approach can be analytically solved for the azimuth and elevation indices using the function, \\(\\lceil\\bullet\\rceil\\), to round the floating-point calculations to the next higher integer index: \\[\\begin{align}\n    i &= \\left\\lceil \\frac{\\left(\\vartheta+\\pi\\right)N_\\vartheta}{2\\pi} \\right\\rceil = \\left\\lceil \\frac{\\vartheta+\\pi}{\\Delta\\vartheta} \\right\\rceil, \\label{eq:gs2dgrid_coord2idx_azimuth}\\\\\n    j &= \\left\\lceil \\frac{\\left(\\varphi+\\pi/2\\right)N_\\varphi}{\\pi} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil. \\label{eq:gs2dgrid_coord2idx_elevation}\n\\end{align}\\] Numerical problems can arise around the boundaries of the numerical grid due to \\(\\lceil 0 \\rceil = 0\\). As no zeroth grid element exists, the inputs must be pretreated to avoid this problem. For the azimuth angle, the angle is mapped to the half-open interval \\(\\left(-\\pi, \\pi\\right]\\), thus if \\(\\vartheta=-\\pi\\) then \\(\\vartheta\\mapsto \\vartheta+ 2\\pi\\). The elevation is mapped to the open interval \\(\\left(-\\pi/2, \\pi/2\\right)\\) and should \\(|\\varphi| = \\pi/2\\) then \\(\\varphi\\mapsto \\varphi- \\mathop{\\mathrm{sgn}}\\left(\\varphi\\right)\\epsilon\\), with the machine accuracy \\(\\epsilon\\) being the smallest floating point number available to the machine.\n\n\ncoord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\n\nEquatorial Symmetry\nFor some applications, equatorial symmetry of the underlying problem can be assumed, which can be exploited to reduce the number of grid elements. In this case, the grid is only defined for \\(\\varphi\\in \\left[0, \\pi/2\\right)\\), and the elevation is subsequently calculated similar to Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\): \\[\\begin{equation}\n    \\varphi_j = \\frac{\\pi}{4N_\\varphi} + (j-1)\\Delta\\varphi\\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\}  \\quad\\text{with}\\quad \\Delta\\varphi= \\frac{\\pi}{2N_\\varphi}\n    \\label{eq:gs2dgrid_eqsim_elevation}\n\\end{equation}\\] This also changes the function mapping continuous coordinates to specific and discrete grid elements; see Eq. \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\): \\[\\begin{equation}\n    j = \\left\\lceil \\frac{\\left|\\varphi\\right| \\cdot N_\\varphi}{\\pi/2} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil.\n    \\label{eq:gs2dgrid_eqsim_coord2idx_elevation}\n\\end{equation}\\] Taking the absolute value of the elevation angle in the equation above ensures that the function is defined for the entire sphere. Still, the mapping always projects the coordinate onto the upper hemisphere.\n\n\n GlobalStructuredGrid_EqSim Eqs. \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\) - \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)   areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)   coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\)   coord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced\nIn order to counter the disadvantages of the full grid, the reduced, structured grid was introduced. The main goal of this discretization scheme is to keep the advantages of the structured grid as much as possible while reducing the number of elements, especially those at high elevation angles. Mathematically speaking, during the creation of the grid, the individual elements are as close as possible to equal area squares with a constant, physical resolution of \\(\\left(r\\cdot\\cos\\varphi\\cdot\\Delta\\vartheta\\right)\\times\\left(r\\cdot\\Delta\\varphi\\right)\\).\n\nCoordinate Calculation\nThe coordinates for the grid are calculated by iterating over the fixed number \\(N_\\varphi\\) of elevation angles (which calculation is equal to the standard, structured grid, see Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\)), which lead to a variable number \\(\\left(N_\\vartheta\\right)_j\\) of azimuth angles for each elevation angle \\(\\varphi_j\\): \\[\\begin{alignat}{3}\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi&&\\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi}  \\label{eq:gs2dgrid_reduced_elevation} \\\\\n    &\\Rightarrow\\quad \\left(N_\\vartheta\\right)_j = \\left\\lceil \\frac{2\\pi\\varphi_j}{\\pi N_\\varphi} \\right\\rceil \\label{eq:gs2dgrid_reduced_azimuth_elements} \\\\\n    \\vartheta_{i,j} &= - \\pi + \\frac{\\pi}{\\left(N_\\vartheta\\right)_j} + (i-1)\\Delta\\vartheta_j &&\\quad\\text{with } \\Delta\\vartheta_j = \\frac{2\\pi}{\\left(N_\\vartheta\\right)_j} \\label{eq:gs2dgrid_reduced_azimuth}\n\\end{alignat}\\] for \\(j \\in \\{1, \\dots, N_\\varphi\\}\\) and \\(i \\in \\{1, \\dots, \\left(N_\\vartheta\\right)_j\\}\\), respectively.\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\nFigure 2: Global, structured, reduced, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e., radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_reduced_2d(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n    ylims!(ax, -90, 90)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_proj(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_3d(N_phi=10;)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            if abs(theta) &gt;= 90; continue; end\n            phi0, phi1 = -90 + (i-1)*180/length(grid.N_theta), -90 + i*180/length(grid.N_theta)\n            \n            x = [cosd(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            y = [sind(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            z = [sind(x) for x in range(phi0,phi1,100)]\n\n            lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all(N=10)\n    gs2dgrid_reduced_2d(N)\n    gs2dgrid_reduced_proj(N)\n    gs2dgrid_reduced_3d(N)\nend\n\n\nFor standalone figures to produce .svg files, use the following code:\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_reduced_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nFor the use in a document, use the following code:\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0pt,0pt) {\\includegraphics[width=0.5\\textwidth]{imgs/gs2dgrid_reduced_2d.pdf}};\n    \\node[below right = 0 and -5 of 2d] (proj) {\\includegraphics[width=0.5\\textwidth]{imgs/gs2dgrid_reduced_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -1.4 and -3 of proj] (3d) {\\includegraphics[width=0.4\\textwidth, trim={0 30pt 0 0}, clip]{imgs/gs2dgrid_reduced_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] (3d.70) to [in=0, out=90] node[near end, xshift=-20, yshift=25]{\\footnotesize{spherical projection}} (2d.15);\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, xshift=30, yshift=-25]{\\footnotesize{cartesian projection}} (3d.190);\n\n\\end{tikzpicture}\nFor both versions, please ensure that the used .pdf files are at the correct location.\n\n\n\n figure.svg \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nEquatorial Symmetry"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#spiral",
    "href": "documentation/fundamentals/numerical_grids.html#spiral",
    "title": "2.2 Numerical Grids",
    "section": "Spiral",
    "text": "Spiral\n\nCoordinate Calculation\nPoints on a spherical surface \\(\\mathbb{S}^2\\) which form a path in the form of a spiral can be expressed in spherical coordinates of the form \\[\\begin{equation}\n    \\vartheta=L\\varphi, \\qquad 0 \\leq \\varphi\\leq \\pi\n\\end{equation}\\] with the polar angle \\(\\varphi\\) and the azimuth \\(\\vartheta\\), or the latitude and longitude, respectively (Hardin et al., 2016). The factor \\(L\\) gives the slope of the spiral. One generation method of \\(N\\) points defines the two spherical coordinates as \\[\\begin{align}\n    L =& \\; \\sqrt{N\\pi}, \\\\\n    h_k =& \\; 1 -\\frac{2k-1}{N}, \\\\\n    \\varphi_k =& \\; \\cos^{-1}(h_k), \\\\\n    \\vartheta_k =& \\; L\\varphi_k\n\\end{align}\\] for \\(k = 1,\\dots, N\\), where the slope \\(L\\) is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by \\(2\\pi\\) in \\(\\vartheta\\) (Hardin et al., 2016).\nA specialized method of creating a set of spiral points implements the Fibonacci sequence \\[\\begin{equation}\n    \\left\\{ F_k \\right\\} = \\left\\{1, 1, 2, 3, 5, 8, 13, \\dots \\right\\}\n\\end{equation}\\] and the golden ratio \\(\\varphi = \\frac{1 + \\sqrt{5}}{2}.\\) The general algorithm defines a lattice of points on the square \\(\\left[ 0,1 \\right)^2\\), which is subsequently mapped to a unit sphere using the Lambert cylindrical equal-area projection \\(\\Lambda\\): \\[\\begin{equation}\n    \\Lambda(x,y) = \\begin{bmatrix} \\sqrt{1-(2y-1)^2}\\cdot\\cos\\left(2\\pi x\\right) \\\\ \\sqrt{1-(2y-1)^2}\\cdot\\sin\\left(2\\pi x\\right), 2y-1 \\end{bmatrix}\n\\end{equation}\\] in Cartesian coordinates, and \\[\\begin{equation}\n    \\Lambda(x,y) = \\begin{bmatrix}\\cos^{-1}(2y-1) \\\\ 2\\pi x\\end{bmatrix} = \\begin{bmatrix}\\varphi\\\\ \\vartheta\\end{bmatrix}\n\\end{equation}\\] in spherical coordinates. The points \\((x, y)\\) on the square \\(\\left[ 0,1 \\right)^2\\) are created through \\[\\begin{equation}\n    (\\tilde x, y)_{F_k} = \\left( \\frac{iF_{k-1}}{F_k} , \\frac{i}{F_k} \\right), \\qquad 0 \\leq i \\leq F_k\n\\end{equation}\\] where \\(x= \\tilde x- \\lfloor \\tilde x\\rfloor\\) as just the fractional part of \\(\\tilde x\\) (Hardin et al., 2016). While this implementation can only be applied for \\(N+1\\) elements, where \\(N \\in \\{ F_k \\}\\), a more general approach involves the golden ratio \\(\\varphi\\). Based on Binet’s formula the calculation of \\((x, y)\\) can be changed to \\[\\begin{equation}\n    (\\tilde x, y)_{N} = \\left( \\frac{i}{\\varphi}, \\frac{i}{N} \\right), \\qquad 0 \\leq i \\leq N.\n\\end{equation}\\]\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nAnalysis of Point Distribution\nAlmost all points have equal distances from one another. Numerical analyses of the Fibonacci-based spiral sequence \\(\\omega_N\\) in Hardin et al. (2016) found minimal separations to appear at the poles with value \\(|x_1 - x_4|, \\, x_i\\in\\omega_N\\) and maximum hole in the lattice to occurs in the triangle \\((x_2, x_3, x_5)\\)."
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#healpix",
    "href": "documentation/fundamentals/numerical_grids.html#healpix",
    "title": "2.2 Numerical Grids",
    "section": "HEALPix",
    "text": "HEALPix\nHEALPix, Hierarchical Equal Area iso-Latitude Pixelization (Hardin et al., 2016), was developed by NASA to have three distinct properties, which are that\n\nthe sphere is hierarchically tessellated into curvilinear quadrilaterals,\nthe pixelization is an equal area partition of \\(\\mathbb{S}^2\\), and\nthe point sets are distributed along fixed lines of latitude.\n\n\nCoordinate Calculation\nThe generation of such points firstly requires a division of the sphere into twelve equal-area, four-sided pixels. These areas are defined through the following boundaries: \\[\\begin{align}\n    |\\cos\\varphi| &gt; \\frac{2}{3}, & \\qquad \\vartheta= m\\frac{\\pi}{2},\\\\\n    \\cos\\varphi= \\frac{-2-4m}{3} + \\frac{8\\vartheta}{3\\pi}, & \\qquad \\frac{m\\pi}{2} \\leq \\vartheta\\leq \\frac{(m+1)\\pi}{2}, \\\\\n    \\cos\\varphi= \\frac{2-4m}{3}-\\frac{8\\vartheta}{3\\pi}, & \\qquad \\frac{-(m+1)\\pi}{2} \\leq \\vartheta\\leq \\frac{-m\\pi}{2}.\n\\end{align}\\] with \\(m \\in \\left\\{0,1,2,3\\right\\}\\). These pixels can be further partitioned into a \\(k \\times k\\) grid of sub-pixels of the same shape and area. The points of the set are located in the centers of each pixel. The subdivision leads to \\(k\\) iso-latitudinal rings at the polar region \\(|\\cos\\varphi|&gt;2/3\\): \\[\\begin{equation}\n    |\\cos\\varphi_i|=1-\\frac{i^2}{3k^2}, \\qquad \\vartheta_j=\\frac{\\pi}{2i} \\left( j - \\frac{1}{2} \\right),\n\\end{equation}\\] with every \\(i\\)-th ring having \\(4i\\) equally spaced points. Closer to the equatorial region, \\(2k-1\\) iso-latitudinal rings with \\(4k\\) points each emerge. These points are indexed by \\(k \\leq |i| \\leq 2k\\) and \\(1 \\leq j \\leq 4k\\): \\[\\begin{equation}\n    |\\cos\\varphi_i| = \\frac{4}{3} - \\frac{2i}{3k}, \\qquad \\vartheta_j = \\frac{\\pi}{2k} \\left( j - \\frac{s}{2} \\right)\n\\end{equation}\\] with \\(s = (i-k+1) \\mod 2\\), which describes the phase shift between the rings. This configuration produces a set of \\(N=12k^2\\) points (Hardin et al., 2016).\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured",
    "href": "documentation/fundamentals/numerical_grids.html#structured",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#basics-simulation-setup",
    "href": "documentation/fundamentals/stats_mc.html#basics-simulation-setup",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Basics Simulation Setup",
    "text": "Basics Simulation Setup\nGenerally speaking, a Monte Carlo simulation is not restricted to any fixed physical system or model but rather describes the method used to simulate the individual problem. Its general structure is presented in Figure 1, showing that a Monte Carlo simulation only consists of an initialization and a loop. The initialization step involves setting up the system and its components, including the specification of the system’s state, the random number generator seed, and setting global parameters, most importantly the number of Monte Carlo steps \\(N\\). The loop then iterates over the \\(N\\) Monte Carlo steps.\n\n Figure LaTeX Downloads\n\n\n\n\n\nFigure 1: Basic Monte Carlo simulation structure. The central piece, the “Monte Carlo Step”, contains the physical model based on both deterministic and probabilistic parts. The probabilistic nature of the individual steps leads to resulting samples which are also probabilistic, but based on an unknown probability distribution. The statistical analysis of the resulting samples leads to the desired statistical properties of the system.\n\n\n\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n    connector/.style={draw, circle, thick, minimum size=12pt, fill=white},\n    decision/.style={draw, diamond, aspect=2, thick, rounded corners=2pt, inner sep=3pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main, circle] (START) at (0,0) {\\n{Start}};    \n    \\node[main, below = 1 of START, drop shadow] (INIT) {\\n{Initialization (e.g. setting \\\\ of global parameters)}};\n    \\node[connector, below = 1 of INIT] (CON1) {};\n    \\node[main, below = 1 of CON1, drop shadow] (STEP) {\\n{\\vspace{-2mm}\\\\\\textbf{Monte Carlo Step}\\\\\\vspace{23mm}}};\n        \\node[main, drop shadow] at ($(CON1.90) - (0.4,2.9)$) {\\footnotesize \\n{Deterministic\\\\System}};\n        \\node[main, drop shadow] at ($(CON1.90) - (-0.4,4.25)$) {\\footnotesize \\n{Probabilistic\\\\System}};\n    \\node[decision, below = 1 of STEP] (DEC1) {};\n    \\node[main, below = 1 of DEC1, circle] (END) {\\n{End}};\n\n\n    \\node[right = 0.2 of INIT]  {\\Large$\\Rightarrow$}; \n    \\node[right = 0.8 of INIT]  {{\\n{e.g. number of\\\\ Monte Carlo steps: $N$}}}; \n\n\n    \\node[right = 0.2 of STEP]  {\\Large$\\Rightarrow$}; \n    \\node[right = 0.8 of STEP] (SAMPLES) {{\\n{Samples: \\\\ $\\{\\sample_1, \\sample_2, \\dots, \\sample_N\\}$ }}}; \n\n    \n    %::. connections\n    \\draw[-latex, thick] (START) -- (INIT);\n    \\draw[-latex, thick] (INIT) -- node[midway, right] {$i=1$} (CON1);\n    \\draw[-latex, thick] (CON1) -- (STEP);\n    \\draw[-latex, thick] (STEP) --  (DEC1);\n    \\draw[-latex, thick] (DEC1.180) -| node [near start, below] {$i\\leq N$}  ($(DEC1.180) + (-2,2)$) |- node[near end, above] {$i\\mapsto i+1$} (CON1.180);\n    \\draw[-latex, thick] (DEC1.270) -- node[near start, right] {$i&gt;N$} (END);\n\\end{tikzpicture}\n\n\n\n mc_basic.pdf \n mc_basic.svg \n\n\n\n\nIn the context of Monte Carlo simulations, the system under examination is exclusively represented within the iterative process, specifically encapsulated within the Monte Carlo step. This step encompasses various deterministic and probabilistic subsystems, emphasizing the probabilistic aspect inherent to Monte Carlo simulations. While it is unquestionably preferable to solve both the deterministic and probabilistic components of the system analytically, their combination becomes exceedingly complex quite rapidly, necessitating numerical methods. Each Monte Carlo step effectively addresses the system employing probabilistic sampling, engendering not a definitive solution but rather a singular realization of the probabilistic system. As the number of Monte Carlo steps increases, a correspondingly growing quantity of samples is generated. Therefore, collecting these samples enables a comprehensive analysis of the system’s statistical properties.\nIn the context of this work, examples of probabilistic subsystems can be found in many of the underlying physical processes like the energy, velocity, and angle distributions of the various mechanisms in the exosphere and during surface interactions, for example, the section about Thermal Sorption, as well as the handling of probabilistic events like photoionization and -dissociation, sputtering, and Photon and Electron Stimulated Desorption, to just name a few. Additionally, some parameters of the system are either inherently stochastic (like binding energies) or are implemented as such to either account for their uncertainty or to allow for a more realistic simulation. Examples of the latter are the surface geometry and the surface temperatures, which are both modeled as random variables. Examples of deterministic systems are all those calculations that can be performed analytically, like the landing position calculations of purely ballistic trajectories."
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#sec-central_limit_theorem",
    "href": "documentation/fundamentals/stats_mc.html#sec-central_limit_theorem",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "The Central Limit Theorem",
    "text": "The Central Limit Theorem\nThe expected value of the entire system can be calculated as the empirical average of all independent and identically distributed (IID) samples \\(\\{X_1, X_2, \\dots, X_N\\}\\): \\[\\begin{equation}\n    \\overline{X_N} = \\frac{\\sum_{i=1}^N X_i}{N}.\n\\end{equation}\\]"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "href": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Ensemble Averages",
    "text": "Ensemble Averages\nThe analyses of this work will regularly include statements about a statistical ensemble of samples, i.e. of thermodynamic particles in equilibrium. Following Schörghofer (2022) derivation and notation, given any , \\(f(x)\\), the ensemble average of a quantity \\(Y\\) is \\[\\begin{equation}\n    \\langle Y \\rangle = \\int Yf(x)dx. \\label{eq:ensemble_average}\n\\end{equation}\\]"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#randomness",
    "href": "documentation/fundamentals/stats_mc.html#randomness",
    "title": "2.4 Statistics and the Monte Carlo Method",
    "section": "Randomness",
    "text": "Randomness\nThe randomness of numerical simulations is usually achieved through one (or more) of the implemented random number generators, which are based on deterministic algorithms. These algorithms are designed to produce a sequence of numbers that appear to be random, but are in fact completely determined by the initial value, called the seed. In this work, the standard generator method xoshiro256++ implemented in the Julia Programming Language has been used (Blackman & Vigna, 2021)."
  },
  {
    "objectID": "documentation/lunar_water_exosphere/conversion_model.html",
    "href": "documentation/lunar_water_exosphere/conversion_model.html",
    "title": "8.1 Conversion Model",
    "section": "",
    "text": "Poster Figure LaTeX Downloads\n\n\n\nCite as: Smolka, A. and Reiss, P. (2023). Modelling the Lunar Water Cycle Through Coupled Monte-Carlo Simulations of the Moon’s Surface and Exosphere, Lunar and Planetary Science Conference, 54, 2023.\n\n\n\n\n\n\\documentclass[tikz,landscape]{standalone}\n\n\\usepackage{geometry}\n    \\geometry{paperheight=78cm, paperwidth=110cm, lmargin=20mm, rmargin=20mm, tmargin=20mm, bmargin=20mm}\n\n\\usepackage{pgfplots}\n    \\pgfplotsset{compat=newest}\n    \\usetikzlibrary{arrows.meta}\n    \\usetikzlibrary{backgrounds}\n    \\usetikzlibrary{calc}\n    \\usetikzlibrary{positioning}\n    \\usetikzlibrary{patterns}\n    \\usetikzlibrary{fit}\n\n\\usepackage[T1]{fontenc}\n\\usepackage[largesc]{newtxtext}\n\n\\usepackage[scaled]{helvet}\n\\usepackage[T1]{fontenc}\n    \\renewcommand\\familydefault{\\sfdefault}\n\n\\usepackage{newtxmath}\n\\usepackage{siunitx}\n\\usepackage{tabularx}\n\\usepackage{booktabs}\n\\usepackage[version=4]{mhchem}\n    \\mhchemoptions{layout=stacked}\n\\usepackage{xcolor}\n    \\definecolor{TUMBlue}        {RGB/cmyk}{  0,101,189 / 1.  ,0.43,0.  ,0.  }\n    \\definecolor{TUMBlack}       {RGB/cmyk}{  0,  0,  0 / 0.  ,0.  ,0.  ,1.  }\n    \\definecolor{TUMBlueDarker}  {RGB/cmyk}{  0, 51, 89 / 1.  ,0.57,0.12,0.7 }\n    \\definecolor{TUMBlueLighter} {RGB/cmyk}{152,198,234 / 0.42,0.09,0.  ,0.  }\n    \\definecolor{TUMOrange}      {RGB}{227, 114, 34}\n    \\definecolor{TUMGreen}       {RGB}{162, 173, 0}\n    \\definecolor{tab10blue}{HTML}{1f77b4}\n    \\definecolor{tab10orange}{HTML}{ff7f0e}\n    \\definecolor{tab10green}{HTML}{2ca02c}  \n    \\definecolor{tab10red}{HTML}{d62728}\n    \\colorlet{pcolor}{tab10red}\n    \\colorlet{hcolor}{black}\n    \\colorlet{h2color}{TUMOrange}\n    \\colorlet{ohcolor}{TUMGreen}\n    \\colorlet{h2ocolor}{TUMBlue}\n\n\n\\newcommand{\\rate}[2]{\n    \\Large\n    \\begin{tabular}{l}\n        \\bfseries #1 \\\\\n        #2\n    \\end{tabular}\n}\n\\newcommand{\\sirange}[3]{\\SI{#1}{}\\,\\text{--}\\,\\SI{#2}{#3}}\n\\newcommand{\\h}[1]{\\textcolor{TUMBlueLighter}{\\textbf{#1}}}\n\n\n% layers\n\\pgfdeclarelayer{H}     % declare background layer\n\\pgfdeclarelayer{H2}    % declare background layer\n\\pgfdeclarelayer{OH}    % declare background layer\n\\pgfdeclarelayer{H2O}   % declare background layer\n\\pgfdeclarelayer{loss}  % declare background layer\n\\pgfsetlayers{background,H2O,OH,H2,H,main,loss}  % set the order of the layers (main is the standard layer)\n\n\\begin{document}\n\\pagestyle{empty}\n\n\n%\n\\begin{tikzpicture}[background rectangle/.style={fill=white},show background rectangle,inner frame sep=30px,\n  sub/.style={circle,draw,line width=4pt,minimum size=140pt,anchor=mid,font={\\bfseries\\Huge},fill=white,align=center},\n  path/.style={line width=2.5pt,-latex,font={\\normalsize},},\n  traj/.style={line width=2.5pt,-latex,font={\\normalsize},},\n  rate/.style={rounded corners,draw,solid,line width=2pt,fill=white,inner sep=5pt,font={\\normalsize},text=black},\n  every label/.style={draw=none,fill=none,font={\\footnotesize\\itshape},text=black},\n  loss/.style={at end,above,xshift=5pt,text=black},\n  source/.style={at end,above,xshift=-5pt,text=red,font={\\bfseries\\Huge},},\n]\n  % variables\n  \\def\\innernodesep{.095\\paperwidth}\n  \\def\\outernodesep{.15\\paperwidth}\n  \\def\\whitelinewidth{8pt}\n\n  % H nodes\n  \\node[hcolor,sub] (HGEXO) at (0,0) {\\ce{H(g)_{exo}}};\n  \\node[hcolor,sub,right=\\innernodesep of HGEXO] (HpGEXO) {\\ce{H+(g)_{exo}}};\n  \\node[hcolor,sub,below=\\innernodesep of HGEXO] (HGREG) {\\ce{H(g)_{reg}}};\n\n\n  % H2 nodes\n  \\node[h2color,sub,right=\\outernodesep of HpGEXO] (H2GEXO) {\\ce{H2(g)_{exo}}};\n  \\node[h2color,sub,right=\\innernodesep of H2GEXO] (H2pGEXO) {\\ce{H2+(g)_{exo}}};\n  \\node[h2color,sub,below=\\innernodesep of H2GEXO] (H2GREG) {\\ce{H2(g)_{reg}}};\n\n\n  % OH nodes\n  \\node[ohcolor,sub,below=0.7*\\outernodesep of HGREG] (OHGEXO) {\\ce{OH(g)_{exo}}};\n  \\node[ohcolor,sub,right=\\innernodesep of OHGEXO] (OHpGEXO) {\\ce{OH+(g)_{exo}}};\n  \\node[ohcolor,sub,below=\\innernodesep of OHGEXO] (OHGREG) {\\ce{OH(g)_{reg}}};\n  \\node[ohcolor,sub,right=\\innernodesep of OHGREG] (OHADREG) {\\ce{OH(ad)_{reg}}};\n\n\n  % H2O nodes  \n  \\node[h2ocolor,sub,right=\\outernodesep of OHpGEXO] (H2OGEXO) {\\ce{H2O(g)_{exo}}};\n  \\node[h2ocolor,sub,right=\\innernodesep of H2OGEXO] (H2OpGEXO) {\\ce{H2O+(g)_{exo}}};\n  \\node[h2ocolor,sub,below=\\innernodesep of H2OGEXO] (H2OGREG) {\\ce{H2O(g)_{reg}}};\n  \\node[h2ocolor,sub,right=\\innernodesep of H2OGREG] (H2OADREG) {\\ce{H2O(ad)_{reg}}};\n\n  % switch to background layer\n  \\begin{pgfonlayer}{H}\n\n  %%% rates\n  %% H\n  \\draw[path,hcolor] (HGEXO.0) -- (HpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate{Photoionization}{\\ce{H(g)_{exo} -&gt; H(g)^+_{exo} }}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (HGREG.180) -- +(-3,0) |- ($(OHADREG.255)+(0,-1)$) -- (OHADREG.255);\n  \\draw[path,hcolor] (HGREG.180) -- +(-3,0) |- ($(OHADREG.255)+(0,-1)$) \n    node[rate,pos=0.125,right,xshift=-10pt,label={below:Griscom (1985); Jones et al. (2021)}]{\n      \\rate\n        {\\ce{OH} Adsorption; Regolith \\ce{H} Annealing}\n        {\\ce{M-O + H(g)_{reg} -&gt; M-OH(ad)_{reg}}}\n  } -- (OHADREG.255);\n\n  \\draw[path,hcolor] (HGREG.75) -- (HGEXO.285)\n    node[rate,midway,right,xshift=-10pt,label={below:Wurz et al. (2022)}]{\n      \\rate\n        {Thermal Desorption \\&\\\\\\textbf{Surface Release}}\n        {\\ce{H(g)_{reg} -&gt; H(g)_{exo}}}\n  };\n\n  \\draw[traj,hcolor] (HGEXO.255) -- (HGREG.105) \n    node[rate,near start,left,xshift=20pt,]{\n      \\rate{Surface Impact}{\\ce{H(g)_{exo} -&gt; H(g)_{reg}}}\n  };\n\n  \\draw[traj,hcolor] (HpGEXO.225) -- (HGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H^+(g)_{exo} -&gt; H(g)_{reg}}}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (HGREG.0) -- (H2GREG.180);\n  \\draw[path,hcolor] (HGREG.0) -- (H2GREG.180)\n    node[rate,pos=0.765,below,yshift=10pt,label={below:~~~~~~~~~~~~~~~~~~~~~~~~~~~~Jones et al. (2018); Jones et al. (2021); Tucker et al. (2018)}] (Htmp1) {\n      \\rate\n        {2$^\\text{nd}$ Order Recombinative Desorption}\n        {\\ce{M-O-H(g)_{reg} + M-OH(ad)_{reg} -&gt; M-O-O-M + H2(g)_{reg}}}\n  };\n\n  \\end{pgfonlayer}\n\n\n  %% H2\n  \\begin{pgfonlayer}{H2}\n  \\draw[path,h2color] (H2GEXO.90) -- +(0,2) -| (HGEXO.90)\n    node[rate,pos=0.15,below,yshift=10pt,label={below:Huebner et al. (1992)}] (H2tmp1) {\n      \\rate\n        {Exospheric Photodissociation}\n        {\\ce{H2(g)_{exo} -&gt; H(g)_{exo} + H(g)_{exo}}\\\\\\ce{H2(g)_{exo} -&gt; H(g)_{exo} + H^+(g)_{exo}}}\n    };\n  \\draw[path,h2color] (H2tmp1.175) -| (HpGEXO.90); \n\n  \\draw[path,h2color] (H2GEXO.0) -- (H2pGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Photoionization}\n        {\\ce{H2(g)_{exo} -&gt; H2(g)^+_{exo} }}\n  };\n\n  \\draw[traj,h2color] (H2pGEXO.225) -- (H2GREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H2^+(g)_{exo} -&gt; H2(g)_{reg}}}\n  };\n\n  \\draw[path,h2color] (H2GREG.75) -- (H2GEXO.285) \n    node[rate,midway,right,xshift=-10pt,label={below:Wurz et al. (2022)}]{\n      \\rate\n        {Thermal Desorption \\&\\\\\\textbf{Surface Release}}\n        {\\ce{H2(g)_{reg} -&gt; H2(g)_{exo}}}\n  };\n\n  \\draw[traj,h2color] (H2GEXO.255) -- (H2GREG.105) \n    node[rate,near start,left,xshift=10pt,]{\n      \\rate{Surface Impact}{\\ce{H2(g)_{exo} -&gt; H2(g)_{reg}}}\n  };\n\n  \\draw[white,line width=\\whitelinewidth] (H2GREG.270) -- +(0,-5) -| (HGREG.255);\n  \\draw[path,h2color] (H2GREG.270) -- +(0,-5) -| (HGREG.255)\n    node[rate,pos=0.10,below,yshift=10pt,label={below:Jones et al. (2018); Jones et al. (2021); Tucker et al. (2018)}] (H2tmp2) {\n      \\rate\n        {2$^\\text{nd}$ Order Dissociative Adsorption}\n        {\\ce{M-O + H2(g)_{reg} -&gt; M-OH(ad)_{reg} + M-O + H(g)_{reg}}}\n  };\n  \\draw[white,line width=\\whitelinewidth] (H2tmp2.180) -- +(-1.7,0) |- ($(OHADREG.60)+(0,2.5)$) -- (OHADREG.60);\n  \\draw[path,h2color] (H2tmp2.180) -- +(-1.7,0) |- ($(OHADREG.60)+(0,2.5)$) -- (OHADREG.60);\n  \\end{pgfonlayer}\n\n\n  %% OH\n  \\begin{pgfonlayer}{OH}\n  \\node (H2tmp3) [rate,white,inner sep=3pt,fit=(H2tmp2)] {};\n  \\node (Htmp3) [rate,white,inner sep=4pt,fit=(Htmp1)] {};\n\n  \\draw[path,ohcolor] (OHGREG.75) -- (OHGEXO.285) \n    node[rate,midway,right,xshift=-10pt,]{\n      \\rate{Surface Release}{\\ce{OH(g)_{reg} -&gt; OH(g)_{exo}}}\n  };\n\n  \\draw[traj,ohcolor] (OHGEXO.255) -- (OHGREG.105) \n    node[rate,near start,left,xshift=35pt,]{\n      \\rate{Surface Impact}{\\ce{OH(g)_{exo} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHGEXO.180) -| +(-4.5, 1) |- (HGEXO.165)\n    node[rate,pos=0.12,left,xshift=10pt,label={below:Huebner et al. (1992)}] (OHtmpphoto) {\n      \\rate\n        {Exospheric \\& Adsorbate\\\\\\textbf{Photodissociation}}\n        {\\ce{OH(g)_{exo} $\\Big/$ OH(ad)_{reg}^{sur} -&gt; H(g)_{exo}}}\n  };\n  \\draw[path,ohcolor,arrows=-] (OHADREG.270) -- +(0,-1.5) -| (OHtmpphoto.335);\n\n  \\draw[path,ohcolor] (OHGEXO.0) -- (OHpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Exospheric Photoionization}\n        {\\ce{OH(g)_{exo} -&gt; OH(g)^+_{exo} }}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.90) -- (OHpGEXO.270) \n    node[rate,pos=0.45,above,yshift=-10pt,label={below:}]{\n      \\rate\n        {Adsorbate Photoionization}\n        {\\ce{OH(ad)_{reg}^{sur} -&gt; OH(g)^+_{exo} }}\n  };\n\n  \\draw[path,ohcolor] (OHGREG.15) -- (OHADREG.165) \n    node[rate,midway,above,yshift=-10pt,xshift=-10pt]{\n      \\rate\n        {1$^\\text{st}$ Order Adsorption}\n        {\\ce{OH(g)_{reg} -&gt; OH(ad)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.195) --(OHGREG.345) \n    node[rate,pos=0.6,below,yshift=10pt,xshift=30pt,label={below:Grumpe et al. (2019); Sarantos et al. (2021); Reiss (2018)}]{\n      \\rate\n        {1$^\\text{st}$ Order Desorption}\n        {\\ce{OH(ad)_{reg} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[traj,ohcolor] (OHpGEXO.225) -- (OHGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{OH^+(g)_{exo} -&gt; OH(g)_{reg}}}\n  };\n\n  \\draw[path,ohcolor] (OHADREG.330) -- (H2OGREG.210)\n    node[rate,pos=0.5,below,yshift=10pt,label={below:Du et al. (2011); Jones et al. (2021)}] (OHtmp1) {\n      \\rate\n        {2$^\\text{nd}$ Order Recombinative Desorption}\n        {\n          \\ce{M-OH(ad)_{reg} + M-OH(ad)_{reg} -&gt; M-O-M + H2O(g)_{reg}}\\\\\n          \\ce{M-OH(ad)_{reg} + M-OH(ad)_{reg} -&gt; M-O-O-M + H2(g)_{reg}}\n        }\n  };  \n  \\draw[path,ohcolor] (OHtmp1.345) |- +(2, -1) -| ($(H2OADREG.0)+(2.5,0)$) |-  (H2GREG.0);\n\n  \\draw[white,line width=\\whitelinewidth] (OHADREG.135) -- (OHGEXO.315);\n  \\draw[path,ohcolor] (OHADREG.135) -- (OHGEXO.315)\n    node[rate,pos=0.25,label={below:DeSimone et al. (2015)~~~~~~~~~~~~~~~~~~~~~~}]{\n      \\rate\n        {Photon Stimulated Desorption}\n        {\\ce{M-OH(ad)_{reg}^{sur} -&gt; OH(g)_{exo}}}\n  };\n\n  % extra path\n  \\draw[white,line width=\\whitelinewidth] (OHADREG.75) |- +(0,2.8) -| ($(Htmp1.180)+(0.9,0)$) |- (H2GREG.195);\n  \\draw[path,ohcolor] (OHADREG.75) |- +(0,2.8)  -| ($(Htmp1.180)+(0.9,0)$) |- (H2GREG.195);\n  \\node (Htmp2) [rate,ohcolor,inner sep=1pt,fit=(Htmp1)] {};\n\n  \\end{pgfonlayer}\n\n\n  %% H2O\n  \\begin{pgfonlayer}{H2O}\n  \\draw[path,h2ocolor] (H2OGREG.75) -- (H2OGEXO.285) \n    node[rate,midway,right,xshift=-10pt,]{\n      \\rate{Surface Release}{\\ce{H2O(g)_{reg} -&gt; H2O(g)_{exo}}}\n  };\n\n  \\draw[traj,h2ocolor] (H2OGEXO.255) -- (H2OGREG.105) \n    node[rate,near start,left,xshift=10pt,]{\n      \\rate{Surface Impact}{\\ce{H2O(g)_{exo} -&gt; H2O(g)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OGEXO.0) -- (H2OpGEXO.180) \n    node[rate,midway,above,yshift=-10pt,label={below:Huebner et al. (1992)}]{\n      \\rate\n        {Exospheric Photoionization}\n        {\\ce{H2O(g)_{exo} -&gt; H2O(g)^+_{exo} }}\n  };\n\n  \\draw[path,h2ocolor] (H2OADREG.90) -- (H2OpGEXO.270) \n  node[rate,pos=0.45,above,yshift=-10pt,label={below:}]{\n    \\rate\n      {Adsorbate Photoionization}\n      {\\ce{H2O(ad)_{reg}^{sur} -&gt; H2O(g)^+_{exo} }}\n};\n\n  \\draw[path,h2ocolor] (H2OGEXO.180) -- (OHpGEXO.0)\n    node[rate,pos=0.4,above,yshift=-10pt,label={below:Huebner et al. (1992)}] (H2Otmp1) {\n      \\rate\n        {Exospheric \\& Adsorbate Photodissociation}\n        {\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + H(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + OH(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H(g)_{exo} + OH^+(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H^+(g)_{exo} + OH(g)_{exo}}\\\\\n          \\ce{H2O(g)_{exo} $\\Big/$ H2O(ad)_{reg}^{sur} -&gt; H2(g)_{exo}}\n        }\n  };\n  \\draw[path,h2ocolor] (H2Otmp1.167) -| (OHGEXO.90);\n  \\draw[path,h2ocolor] (H2Otmp1.160) -| ($(HGEXO.195)+(-3.8,0)$) -- (HGEXO.195);\n  \\draw[path,h2ocolor] (H2Otmp1.150) |- (HpGEXO.0);\n  \\draw[path,h2ocolor] (H2Otmp1.146) |- (H2GEXO.180);\n  \\draw[path,h2ocolor,arrows=-] (H2OADREG.0) -| +(2, 2) |- (H2Otmp1.20);\n\n  \\draw[traj,h2ocolor] (H2OpGEXO.225) -- (H2OGREG.45) \n    node[rate,near start]{\n      \\rate{Surface Neutralization}{\\ce{H2O^+(g)_{exo} -&gt; H2O(g)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OGREG.15) -- (H2OADREG.165) \n    node[rate,midway,above,yshift=-10pt,xshift=-10pt]{\n      \\rate\n        {1$^\\text{st}$ Order Adsorption}\n        {\\ce{H2O(g)_{reg} -&gt; H2O(ad)_{reg}}}\n  };\n\n  \\draw[path,h2ocolor] (H2OADREG.195) --(H2OGREG.345) \n    node[rate,pos=0.6,below,yshift=10pt,xshift=30pt,label={below:Grumpe et al. (2019); Sarantos et al. (2021); Reiss (2018)}]{\n      \\rate\n        {1$^\\text{st}$ Order Desorption}\n        {\\ce{H2O(ad)_{reg} -&gt; H2O(g)_{reg}}}\n  };\n  \n  \\draw[path,h2ocolor] (H2OGREG.180) -- (OHADREG.0)\n    node[rate,pos=0.45,above,yshift=-10pt,label={above: Jones et al. (2018)}]{\n      \\rate\n        {2$^\\text{nd}$ Order Dissociative Adsorption}\n        {\\ce{M-O-M + H2O(g)_{reg} -&gt; M-OH(ad)_{reg} + M-OH(ad)_{reg}}}\n  };  \n\n  \\draw[white,line width=\\whitelinewidth] (H2OADREG.135) -- (H2OGEXO.315);\n  \\draw[path,h2ocolor] (H2OADREG.135) -- (H2OGEXO.315)\n    node[rate,pos=0.25,label={below:DeSimone et al. (2015)~~~~~~~~~~~~~~~~~~~~~~}]{\n      \\rate\n        {Photon Stimulated Desorption}\n        {\\ce{M-H2O(ad)_{reg}^{sur} -&gt; H2O(g)_{exo}}}\n  };\n\n  \\end{pgfonlayer}\n\n  \\begin{pgfonlayer}{loss}\n     \n    %% H\n    \\draw[white,line width=\\whitelinewidth] ($(HGEXO.135)+(0.5,-0.5)$) -- +(-1.2,1.2); \n    \\draw[path,red,dashed,arrows=latex-] ($(HGEXO.135)+(0.5,-0.5)$) -- +(-1.2,1.2)\n      node[source] {\\LARGE\\ce{p^+_{SW}}}; \n\n    \\draw[white,line width=\\whitelinewidth] ($(HGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,hcolor,dashed] ($(HGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textbf{Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(HpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,hcolor,dashed] ($(HpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n\n      \n    %% H2\n    \\draw[white,line width=\\whitelinewidth] ($(H2GEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2color,dashed] ($(H2GEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textbf{Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2pGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2color,dashed] ($(H2pGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n\n      \n    %% OH\n    \\draw[white,line width=\\whitelinewidth] ($(OHGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textit{\\color{gray}Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(OHpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textit{\\color{gray}Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}};  \n      \n    \\draw[white,line width=\\whitelinewidth] ($(OHADREG.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,ohcolor,dashed] ($(OHADREG.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Sputtering}\\\\\\textbf{Cold-Trapping}\\end{tabular}};  \n\n    \n    %% H2O\n    \\draw[white,line width=\\whitelinewidth] ($(H2OGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\textit{\\color{gray}Jean's Escape}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2OpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OpGEXO.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textit{\\color{gray}Jean's Escape}\\\\\\textbf{EMF Escape}\\end{tabular}}; \n        \n    \\draw[white,line width=\\whitelinewidth] ($(H2OADREG.45)-(0.5,0.5)$) -- +(1.2,1.2); \n    \\draw[path,h2ocolor,dashed] ($(H2OADREG.45)-(0.5,0.5)$) -- +(1.2,1.2)\n      node[loss] {\\begin{tabular}{c}\\textbf{Sputtering}\\\\\\textbf{Cold-Trapping}\\end{tabular}}; \n    \n  \\end{pgfonlayer}\n\n\\end{tikzpicture}\n\n\\end{document}\n\n\n\n Smolka2023_LPSC_Poster.pdf \n lwcm.pdf   lwcm.svg \n\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html",
    "href": "documentation/trajectories/ballistic_trajectories.html",
    "title": "5.1 Ballistic Trajectories",
    "section": "",
    "text": "Intro"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-azimuth-angle",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-azimuth-angle",
    "title": "5.1 Ballistic Trajectories",
    "section": "Azimuth Angle – \\(\\alpha\\)",
    "text": "Azimuth Angle – \\(\\alpha\\)\nThe azimuth angle \\(\\alpha\\), measured mathematically positive from \\(x\\), i.e., north from true east, can be calculated using the following multi-case definition: \\[\\begin{equation}\n    \\alpha\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\begin{cases}\n        \\cos^{-1}\\left(v_1/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2\\geq0\\\\\n        -\\cos^{-1}\\left(v_1/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2&lt;0\n    \\end{cases} \\label{eq:azimuth_angle_v}\n\\end{equation}\\] with a local cartesian velocity vector \\(\\boldsymbol{\\mathbf{v}}= \\left[v_1, v_2, v_3\\right]^T\\). The equation can be rewritten as a single-case equation, avoiding the inverse cosine expression: \\[\\begin{equation}\n    \\cos\\alpha= \\frac{v_1}{\\sqrt{v_1^2+v_2^2}}.\n\\end{equation}\\]  azimuth_angle_v: \\(\\alpha\\left(\\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:azimuth_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-eccentric-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-eccentric-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "Eccentric Anomaly – \\(E\\)",
    "text": "Eccentric Anomaly – \\(E\\)\nThe eccentric anomaly \\(E\\) has two distinctly different definitions, depending on the input parameters. The first, shown in Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\), is based on a given eccentricity \\(e\\) and true anomaly \\(\\theta\\), while the second one, shown in Eq. \\(\\eqref{eq:eccentric_anomaly_e_M}\\), is a iterative approach on solving for the eccentric anomaly based on the mean anomaly \\(M\\) and eccentricity \\(e\\). \\[\\begin{align}\n    E\\left(e, \\theta\\right) &= \\begin{cases}\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) & \\text{for } 0\\leq\\theta&lt;\\pi\\\\\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) + 2\\pi & \\text{for } \\pi\\leq\\theta&lt;2\\pi\n    \\end{cases}  \\label{eq:eccentric_anomaly_e_theta} \\\\[3mm]\n     E_{i+1}\\left(e, M, E_i\\right) &= M+ e\\sin E_i \\quad\\text{ with }\\quad E_0 = M\\label{eq:eccentric_anomaly_e_M}\n\\end{align}\\] Similar to the azimuth angle before, Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\) can be rewritten as a single-case equation, avoiding the inverse tangent expression: \\[\\begin{equation}\n    \\tan\\left(E/2\\right) = \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\theta/2\\right).\n\\end{equation}\\]  eccentric_anomaly_e_theta: \\(E\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)   eccentric_anomaly_e_M: \\(E\\left(e, M\\right)\\): Eq. \\(\\eqref{eq:eccentric_anomaly_e_M}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-eccentricity",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-eccentricity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Eccentricity – \\(e\\)",
    "text": "Eccentricity – \\(e\\)\nThe eccentricity \\(e\\) \\[\\begin{align}\n    e\\left(\\epsilon_{kin}, \\psi\\right) &= \\sqrt{1 - 4 \\epsilon_{kin}\\cdot (1 - \\epsilon_{kin}) \\cdot \\sin^2 \\psi}  \\label{eq:eccentricity_epskin_psi} \\\\\n    e\\left(a, p\\right) &= \\sqrt{1 - \\frac{p}{a}}  \\label{eq:eccentricity_a_p} \\\\\n    e\\left(r, p, \\theta\\right) &= \\frac{1}{\\cos\\theta}\\cdot\\left(\\frac{p}{r} - 1\\right)  \\label{eq:eccentricity_r_p_theta} \\\\\n    e\\left(E, M\\right) &= \\frac{E- M}{\\sin E}  \\label{eq:eccentricity_E_M}\n\\end{align}\\]\n\n\n eccentricity_epskin_psi: \\(e\\left(\\epsilon_{kin}, \\psi\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\)\n eccentricity_epskin_v: \\(e\\left(\\epsilon_{kin}, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\) with \\(v=v(\\psi)\\) from Eq. \\(\\eqref{eq:zenith_angle_v}\\)\n eccentricity_r_m_v: \\(e\\left(r, m, v\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\) with \\(\\epsilon_{kin}=\\epsilon_{kin}\\left(v_{esc}(r,m),v\\right)\\) from Eqs. \\(\\eqref{eq:escape_velocity_r_m}\\) and \\(\\eqref{eq:relative_Ekin_v_vesc}\\), and with \\(v=v(\\psi)\\) from Eq. \\(\\eqref{eq:zenith_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-escape-velocity",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-escape-velocity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Escape Velocity – \\(v_{esc}\\)",
    "text": "Escape Velocity – \\(v_{esc}\\)\n\\[\\begin{equation}\n    v_{esc}\\left(r, m\\right) = \\sqrt{\\frac{2 Gm}{r}} \\label{eq:escape_velocity_r_m}\n\\end{equation}\\]\n\n\n escape_velocity_r_m: \\(v_{esc}\\left(r, m\\right)\\): Eq. \\(\\eqref{eq:escape_velocity_r_m}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-ground-track-distance",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-ground-track-distance",
    "title": "5.1 Ballistic Trajectories",
    "section": "Ground Track Distance – \\(d\\)",
    "text": "Ground Track Distance – \\(d\\)\n\\[\\begin{equation}\n    d\\left(r, \\Delta\\theta\\right) = r\\cdot \\Delta\\theta\\label{eq:ground_track_distance_r_dtheta}\n\\end{equation}\\]\n\n\n ground_distance_R_dtheta: \\(d\\left(r, \\theta\\right)\\): Eq. \\(\\eqref{eq:ground_track_distance_r_dtheta}\\)\n ground_distance_R_a_e: \\(d\\left(r, a, e\\right)\\): Eq. \\(\\eqref{eq:ground_track_distance_r_dtheta}\\) with \\(\\Delta\\theta= 2\\pi - 2\\theta\\) and \\(\\theta= \\theta\\left(r, a, e\\right)\\) of Eq. \\(\\eqref{eq:true_anomaly_r_a_e}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-mean-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-mean-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "Mean Anomaly – \\(M\\)",
    "text": "Mean Anomaly – \\(M\\)\n\\[\\begin{equation}\n    M\\left(e, E\\right) = E- e\\sin E\\label{eq:mean_anomaly_e_E}\n\\end{equation}\\]\n\n\n mean_anomaly_e_E: \\(M\\left(e, E\\right)\\): Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\)\n mean_anomaly_e_theta: \\(M\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\) with \\(E=E(e, \\theta)\\) from Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-period",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-period",
    "title": "5.1 Ballistic Trajectories",
    "section": "Orbit Period – \\(P\\)",
    "text": "Orbit Period – \\(P\\)\n\\[\\begin{equation}\n    P\\left(a, m\\right) = 2\\pi\\sqrt{\\frac{a^3}{Gm}}  \\label{eq:orbit_period_a_m}\n\\end{equation}\\]\n\n\n orbit_period_a_m: \\(P\\left(a, m\\right)\\): Eq. \\(\\eqref{eq:orbit_period_a_m}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-time",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-time",
    "title": "5.1 Ballistic Trajectories",
    "section": "Orbit Time – \\(t\\)",
    "text": "Orbit Time – \\(t\\)\n\\[\\begin{equation}\n    t\\left(M, P\\right) = \\frac{M}{2\\pi} \\cdot P\\label{eq:orbit_time_M_P}\n\\end{equation}\\]\n\n\n orbit_time_M_P: \\(t\\left(M, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\)\n orbit_time_e_E_P: \\(t\\left(e, E, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\) with \\(M= M(e, E)\\) of Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\)\n orbit_time_e_theta_P: \\(t\\left(e, \\theta, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\) with \\(M= M(e, E)\\) of Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\) and \\(E= E\\left(e, \\theta\\right)\\) of Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-relative-kinetic-energy",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-relative-kinetic-energy",
    "title": "5.1 Ballistic Trajectories",
    "section": "Relative Kinetic Energy – \\(\\epsilon_{kin}\\)",
    "text": "Relative Kinetic Energy – \\(\\epsilon_{kin}\\)\n\\[\\begin{align}\n    \\epsilon_{kin}\\left(\\boldsymbol{\\mathbf{v}}, v_{esc}\\right) &= \\left(\\frac{|\\boldsymbol{\\mathbf{v}}|}{v_{esc}}\\right)^2  \\label{eq:relative_Ekin_v_vesc} \\\\\n    \\epsilon_{kin}\\left(r, a\\right) &= 1 - \\frac{r}{2a}  \\label{eq:relative_Ekin_r_a} \\\\\n    \\epsilon_{kin}\\left(e, \\theta\\right) &= 1 - \\frac{1 - e^2}{2 + 2e\\cos\\left(\\theta\\right)}  \\label{eq:relative_Ekin_e_theta}\n\\end{align}\\]\n\n\n epskin_vesc_v: \\(\\epsilon_{kin}\\left(\\boldsymbol{\\mathbf{v}}, v_{esc}\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_v_vesc}\\)\n epskin_r_m_v: \\(\\epsilon_{kin}\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_v_vesc}\\) with \\(v_{esc} = v_{esc}\\left(r, m\\right)\\) of Eq. \\(\\eqref{eq:escape_velocity_r_m}\\)\n epskin_r_a: \\(\\epsilon_{kin}\\left(r, a\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_r_a}\\)\n epskin_e_theta: \\(\\epsilon_{kin}\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-semi-latus-rectum",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-semi-latus-rectum",
    "title": "5.1 Ballistic Trajectories",
    "section": "Semi-Latus Rectum – \\(p\\)",
    "text": "Semi-Latus Rectum – \\(p\\)\n\\[\\begin{align}\n    p\\left(a, e\\right) &= a\\cdot (1 - e^2)  \\label{eq:semi_latus_rectum_a_e} \\\\\n    p\\left(r, e, \\theta\\right) &= r\\cdot \\left(1 + e\\cdot \\cos \\theta\\right)  \\label{eq:semi_latus_rectum_r_e_theta}\n\\end{align}\\]\n\n\n semi_latus_rectum_a_e: \\(p\\left(a, e\\right)\\): Eq. \\(\\eqref{eq:semi_latus_rectum_a_e}\\)\n semi_latus_rectum_r_e_theta: \\(p\\left(r, e, \\theta\\right)\\): Eq. \\(\\eqref{eq:semi_latus_rectum_r_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-semi-major-axis",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-semi-major-axis",
    "title": "5.1 Ballistic Trajectories",
    "section": "Semi-Major Axis – \\(a\\)",
    "text": "Semi-Major Axis – \\(a\\)\n\\[\\begin{align}\n    a\\left(r, \\epsilon_{kin}\\right) &= \\frac{r}{2 \\cdot \\left(1 - \\epsilon_{kin}\\right)}  \\label{eq:semi_major_axis_r_epskin} \\\\\n    a\\left(p, e\\right) &= \\frac{p}{1 - e^2}  \\label{eq:semi_major_axis_p_e}\n\\end{align}\\]\n\n\n semi_major_axis_r_epskin: \\(a\\left(r, \\epsilon_{kin}\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_r_epskin}\\)\n semi_major_axis_r_m_v: \\(a\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_r_epskin}\\) with \\(\\epsilon_{kin}=\\epsilon_{kin}\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\) and \\(v_{esc}=v_{esc}\\left(r, m\\right)\\) of Eqs. \\(\\eqref{eq:relative_Ekin_v_vesc}\\) and \\(\\eqref{eq:escape_velocity_r_m}\\)\n semi_major_axis_p_e: \\(a\\left(p, e\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_p_e}\\)\n semi_major_axis_r_e_theta: \\(a\\left(r, e, \\theta\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_p_e}\\) with \\(p=p\\left(r, e, \\theta\\right)\\) of Eq. \\(\\eqref{eq:semi_latus_rectum_r_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-true-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-true-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "True Anomaly – \\(\\theta\\)",
    "text": "True Anomaly – \\(\\theta\\)\n\\[\\begin{align}\n    \\theta\\left(r, a, e\\right) &= \\cos^{-1}\\left(\\frac{1}{e} \\cdot \\left(\\frac{a}{r} \\left( 1 - e^2 \\right) -1 \\right)\\right)  \\label{eq:true_anomaly_r_a_e} \\\\\n    \\theta\\left(e, \\epsilon_{kin}\\right) &= \\cos^{-1}\\left(\\frac{1}{e} \\cdot \\left(\\frac{1 - e^2}{2-2 \\epsilon_{kin}} -1 \\right)\\right)  \\label{eq:true_anomaly_e_epskin}\n\\end{align}\\]\n\n\n true_anomaly_r_a_e: \\(\\theta\\left(r, a, e\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_r_a_e}\\)\n true_anomaly_e_epskin: \\(\\theta\\left(e, \\epsilon_{kin}\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_e_epskin}\\)\n true_anomaly_epskin_v: \\(\\theta\\left(\\epsilon_{kin}, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_epskin_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-zenith-angle",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-zenith-angle",
    "title": "5.1 Ballistic Trajectories",
    "section": "Zenith Angle – \\(\\psi\\)",
    "text": "Zenith Angle – \\(\\psi\\)\n\\[\\begin{equation}\n    \\psi\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\tan^{-1}\\left(\\frac{\\sqrt{v_1^2 + v_2^2}}{v_3}\\right)  \\label{eq:zenith_angle_v}\n\\end{equation}\\]\n\n\n zenith_angle_v: \\(\\psi\\left(\\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:zenith_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "href": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "title": "5.1 Ballistic Trajectories",
    "section": "General Solution",
    "text": "General Solution\nThe following calculations are based on the orbital mechanics functions introduced above to calculate the landing position \\(\\left(\\Theta_1, \\Phi_1\\right)\\). Note that this approach is quasi-two-dimensional as the radial dimension of the spherical three-dimensional coordinate system is neglected, assuming a perfectly spherical central body with radius \\(r\\). The trajectory starts, and the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\) and, as mentioned above, requires knowledge about the mass and radius of the planetary body, \\(m\\) and \\(r\\), as well as the launch, or initial, velocity vector \\(\\boldsymbol{\\mathbf{v}}\\).\nBased on the escape velocity \\(v_{esc}(r, m)\\), the relative kinetic energy fraction \\(\\epsilon_{kin}(\\boldsymbol{\\mathbf{v}}, v_{esc})\\), can be determined, which in turn is used to calculate the semi-major axis of the trajectory, \\(a(r, \\epsilon_{kin})\\). Since the launch velocity vector is given in local cartesian coordinates, both its zenith angle \\(\\psi(\\boldsymbol{\\mathbf{v}})\\) and its azimuth angle \\(\\alpha\\left(\\boldsymbol{\\mathbf{v}}\\right)\\) can be directly extracted. The former is subsequently used for the determination of the eccentricity \\(e\\left(\\epsilon_{kin}, \\psi\\right)\\). With both \\(a\\) and \\(e\\) known, the true anomaly at launch \\(\\theta_0(r, a, e)\\), and due to symmetry conditions, also the landing position \\(\\theta_1 = 2\\pi - \\theta_0\\), can be calculated, leading to the angular difference between the landing and launch true anomaly \\(\\theta_1 - \\theta_0 = 2\\pi - 2\\theta= \\Delta\\theta\\).\n\n Figure LaTeX Download\n\n\n\n\n\nFigure 1: Sketch the spherical trigonometry problem of the landing position calculation. The ground track distance is given as an angular distance of \\(\\Delta\\theta\\), complemented by all additional angular arguments used for the derivation of the landing position.\n\n\n\n\n\\tdplotsetmaincoords{70}{135}\n\\begin{tikzpicture}[tdplot_main_coords, scale=1.25]\n\n    %::. \"coordinate system\" and sphere lines\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (0,0,3);\n    \\tdplotdrawarc[TUMGrayLight, dashed]{(0,0,0)}{3}{-1}{110}{}{}\n    \\tdplotdrawarc[TUMGrayLight, dashed]{(0,0,1.460)}{2.573}{-3}{110}{}{}\n\n    %::. start point\n    \\pgfmathsetmacro{\\psx}{2.433}\n    \\pgfmathsetmacro{\\psy}{0.973}\n    \\pgfmathsetmacro{\\psz}{1.460}\n\n    \\node[anchor=east, yshift=-3] at (\\psx, \\psy, \\psz) {\\footnotesize launch};\n\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (2.7854, 1.1142, 0);\n    \\draw[TUMGrayLight, dashed] (\\psx, \\psy, 0) -- (\\psx, \\psy, \\psz);\n\n    \\tdplotgetpolarcoords{\\psx}{\\psy}{\\psz}\n    \\tdplotsetthetaplanecoords{\\tdplotresphi}\n\n    \\tdplotdrawarc[latex-, tdplot_rotated_coords]{(0,0,0)}{3}{\\tdplotrestheta}{90}{anchor=east}{$\\latitude_0$}\n    \\tdplotdrawarc[tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=east}{$\\overline{\\latitude_0}$}\n\n    %::. endpoint\n    \\pgfmathsetmacro{\\pex}{0.045}\n    \\pgfmathsetmacro{\\pey}{1.785}\n    \\pgfmathsetmacro{\\pez}{2.410}\n\n    \\node[anchor=west, xshift=1] at (\\pex, \\pey, \\pez) {\\footnotesize landing};\n\n    \\draw[TUMGrayLight, dashed] (0,0,0) -- (0.0756, 2.999, 0);\n    \\draw[TUMGrayLight, dashed] (\\pex, \\pey, 0) -- (\\pex, \\pey, \\pez);\n\n    \\tdplotgetpolarcoords{\\pex}{\\pey}{\\pez}\n    \\tdplotsetthetaplanecoords{\\tdplotresphi}\n\n    \\tdplotdrawarc[latex-, tdplot_rotated_coords]{(0,0,0)}{3}{\\tdplotrestheta}{90}{anchor=west}{$\\latitude_1$}\n    \\tdplotdrawarc[tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=west, xshift=4}{$\\overline{\\latitude_1}$}\n\n    %::. connection (cross-product for 3D orientation)\n    \\tdplotcrossprod(\\psx,\\psy,\\psz)(\\pex,\\pey,\\pez)\n\n    \\tdplotgetpolarcoords{\\tdplotresx}{\\tdplotresy}{\\tdplotresz}\n    \\tdplotsetrotatedcoords{\\tdplotresphi}{\\tdplotrestheta}{180-\\tdplotrestheta+1}\n\n    \\tdplotdrawarc[very thick, -latex, tdplot_rotated_coords]{(0,0,0)}{3}{0}{\\tdplotrestheta}{anchor=north, xshift=5}{$\\Delta\\trueAnomaly$}\n\n    %::. longitude\n    \\tdplotdrawarc[latex-latex, thin,]{(0,0,0)}{1.5}{22}{88}{anchor=north}{$\\Delta\\longitude$}\n\n    %::. launch azimuth angle\n    \\tdplotgetpolarcoords{\\psx}{\\psy}{\\psz}\n    \\tdplotsetrotatedcoords{\\tdplotresphi}{\\tdplotrestheta}{0}\n    \\tdplotdrawarc[-latex, thin, tdplot_rotated_coords]{(0,0,3)}{0.6}{93}{135}{anchor=west}{$\\azimuthAngle$}\n\\end{tikzpicture}\nNote that the code above requires the TikZ package tikz-3dplot. Additionally, the code relies on further definitions, for example of the gray-color: \\definecolor{TUMGrayLight}  {RGB}{204, 204, 204} based on the xcolor package.\n\n\n\n landing_position_calc.svg \n landing_position_calc.pdf \n landing_position_calc.png \n\n\n\n\nBased on Butler (1997), Kegerreis (2020), and Schoerghofer (2022), the landing position \\(\\left(\\Theta_1, \\Phi_1\\right)\\) can now be calculated using the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\), the traveled true anomaly \\(\\Delta\\theta\\), and the azimuth angle \\(\\alpha\\) of the launch velocity. The problem is sketched in Figure 1, where \\(\\overline{\\Phi_0}\\) and \\(\\overline{\\Phi_1}\\) are the complementary angles of the latitudes, i.e., \\(\\Phi= \\frac{\\pi}{2} \\cdot \\overline{\\Phi}\\). Based on the cosine-law of spherical trigonometry, the angular triangle \\(\\left(\\Delta\\theta, \\overline{\\Phi_0}, \\overline{\\Phi_1}\\right)\\) can be used to find \\[\\begin{equation}\n    \\sin\\Phi_1 = \\sin\\Phi_0 \\cdot \\cos\\Delta\\theta+ \\cos\\Phi_0 \\cdot \\sin\\Delta\\theta\\cdot \\sin\\alpha\n\\end{equation}\\] with \\(\\cos\\overline\\Phi= \\sin\\Phi\\) and \\(\\sin\\overline\\Phi= \\cos\\Phi\\), and the same triangle can be used for the calculation of the longitude difference \\(\\Delta\\Theta\\) using the cosine-law \\[\\begin{align}\n    \\cos\\Delta\\theta&= \\sin\\Phi_0 \\cdot \\sin\\Phi_1 + \\cos\\Phi_0 \\cdot \\cos\\Phi_1 \\cdot \\cos\\Delta\\Theta\\\\[3mm]\n    \\Rightarrow\\quad \\cos\\Delta\\Theta&= \\frac{\\cos\\Delta\\theta- \\sin\\Phi_0 \\cdot \\sin\\Phi_1}{\\cos\\Phi_0 \\cdot \\cos\\Phi_1}.\n\\end{align}\\] Note that numerical round-off issues could lead to sine and cosine expressions larger than one. What previous authors did not account for is that due to the periodicity of the cosine, two different cases have to be considered when extracting the \\(\\Delta\\Theta\\): \\[\\begin{equation}\n    \\Delta\\Theta= \\begin{cases} \\Delta\\Theta& \\text{if } \\Delta\\theta\\leq \\pi, \\\\ 2\\pi - \\Delta\\Theta& \\text{else.} \\end{cases}\n\\end{equation}\\] Finally, the landing longitude \\(\\Theta_1\\) can be calculated based on the direction of the launch velocity as \\[\\begin{equation}\n    \\Rightarrow \\Theta_1 = \\Theta_0 + \\mathop{\\mathrm{sgn}}\\left(v_1\\right)\\cdot\\Delta\\Theta,\n\\end{equation}\\] with the signum function \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = 1\\) for \\(v_1\\geq0\\) and \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = -1\\) for \\(v_1&lt;0\\).\nCalculating the time of flight \\(t_{flight}= t_1 - t_0 = P- 2t_0\\) requires the orbital period \\(P\\left(a, m\\right)\\) as well as the orbit time \\(t(M, P)\\), where \\(t_0\\) and \\(t_1\\) are the orbit times at the launch and landing, respectively, with \\(t_1 = P-t_0\\) for symmetry reasons. The mean anomaly \\(M_0\\) at launch can be calculated using the eccentric anomaly \\(E_0\\) and the eccentricity \\(e\\)."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "href": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Simplification for Uniform Gravity",
    "text": "Simplification for Uniform Gravity\nParticles launched with small velocities do not reach altitudes at which the gravitational acceleration changes significantly."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#ordinary-differential-equation-of-motion",
    "href": "documentation/trajectories/ballistic_trajectories.html#ordinary-differential-equation-of-motion",
    "title": "5.1 Ballistic Trajectories",
    "section": "Ordinary Differential Equation of Motion",
    "text": "Ordinary Differential Equation of Motion"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#numerical-ode-solver-analysis",
    "href": "documentation/trajectories/ballistic_trajectories.html#numerical-ode-solver-analysis",
    "title": "5.1 Ballistic Trajectories",
    "section": "Numerical ODE Solver Analysis",
    "text": "Numerical ODE Solver Analysis"
  },
  {
    "objectID": "guide/essentials/julia_links/index.html",
    "href": "guide/essentials/julia_links/index.html",
    "title": "Julia Programming Language: Links & Resources",
    "section": "",
    "text": "Julia is a cutting-edge, high-level programming language designed to address the unique challenges of scientific computing and data analytics. Born in 2012, Julia has quickly gained popularity among researchers, data scientists, and developers due to its remarkable performance and ease of use. The language’s key strength lies in its ability to handle complex mathematical computations and large datasets seamlessly. Julia boasts an intuitive syntax and rich mathematical library, making it particularly well-suited for numerical simulations, machine learning, and advanced statistical analysis. With its open-source nature and active community, Julia continues to evolve, receiving regular updates and enhancements that cater to its users’ diverse needs."
  },
  {
    "objectID": "guide/essentials/julia_links/index.html#learning-julia",
    "href": "guide/essentials/julia_links/index.html#learning-julia",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Learning Julia",
    "text": "Learning Julia\n\nMIT’s Introduction to Computational Thinking\n\nThis free online course held by the creators of the Julia Programming Language offers you a good overview of numerical methods and scientific computing in Julia. The course is held in Julia and is a great way to get started with the language.\n\nTUM-Dynamics-Lecture, 1 and TUM-Dynamics-Lecture, 2\n\nCreated by some colleagues of mine, these two lectures offer a great introduction to Julia and its applications in the field of dynamical systems. The lectures are held in Julia and are a great way to get started with the language."
  },
  {
    "objectID": "guide/essentials/julia_links/index.html#resources",
    "href": "guide/essentials/julia_links/index.html#resources",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Resources",
    "text": "Resources\n\nJulia Homepage (last visited: 31/07/2023)\nJulia Documentation (last visited: 31/07/2023)\n\nOnce you are familiar with the basics of Julia, the documentation is the best place to look up specific functions and syntax. Especially helpful are the following manuals: Performance Tips, Workflow Tips, and the Style Guide.\n\nSciML Style Guide for Julia, by Chris Rackauckas (last visited: 31/07/2023)\n\nA style guide for scientific machine learning in Julia. This guide is a work in progress and is updated regularly."
  },
  {
    "objectID": "guide/essentials/julia_links/index.html#packages",
    "href": "guide/essentials/julia_links/index.html#packages",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Packages",
    "text": "Packages\n\nDataFrames.jl\n\nA package for working with tabular data in Julia. The package is part of the Julia Data Ecosystem and offers a wide range of tools for data manipulation and analysis.\n\nDifferentialEquations.jl\n\nOne of the most popular packages for solving differential equations in Julia. The package is part of the SciML ecosystem and offers a wide range of solvers for ordinary and partial differential equations.\n\nJLD2.jl\n\nA package for saving and loading Julia data structures. Can also used for compressions (see CodecZlib.jl for more information).\n\nMakie.jl and its Documentation\n\nA high-performance plotting library for Julia. It features multiple backends and is highly customizable.\nAlso check out\n\nGeoMakie.jl for plotting geospatial data.\nColors.jl and ColorSchemes.jl for improved color handling.\n\n\nMeasurements.jl\n\nA physics package that handles uncertainty propagations coming from any kind of physical measuements.\n\nProgressMeter.jl\n\nProgress meter for long-running operations in Julia\n\nRevise.jl\n\nA package that allows you to modify your code without having to restart the Julia session. This is especially useful when working with large projects.\n\nUnitful.jl\n\nA package that allows you to work with physical units in Julia."
  },
  {
    "objectID": "guide/essentials/git_essentials/index.html",
    "href": "guide/essentials/git_essentials/index.html",
    "title": "Git Essentials",
    "section": "",
    "text": "Collaboration with Git and the Git workflow are essential aspects of modern software development. Git, a powerful version control system, enables seamless collaboration among developers by facilitating code sharing, tracking changes, and resolving conflicts. The Git workflow refers to a structured approach to managing team-based coding projects, encompassing branching, merging, pull requests, and code reviews.\nThis page provides a collection of online materials that delve into essential concepts, ranging from fundamental Git commands to advanced collaboration techniques."
  },
  {
    "objectID": "guide/essentials/git_essentials/index.html#git",
    "href": "guide/essentials/git_essentials/index.html#git",
    "title": "Git Essentials",
    "section": "Git",
    "text": "Git\n\nA Beginner’s Guide to Git and Version Control (last visited: 28/07/2023)\nGetting Started with Git (last visited: 28/07/2023)\nCollaborating with Git (last visited: 28/07/2023)\nGit Documentation (last visited: 28/07/2023)"
  },
  {
    "objectID": "guide/essentials/git_essentials/index.html#github",
    "href": "guide/essentials/git_essentials/index.html#github",
    "title": "Git Essentials",
    "section": "GitHub",
    "text": "GitHub\nWhile Git is a version control system that allows developers to track changes in their codebase and collaborate with other developers, GitHub is an online service that provides hosting for Git repositories.\n\nGit vs. GitHub: What’s the Difference? (last visited: 28/07/2023)"
  },
  {
    "objectID": "guide/essentials/git_essentials/index.html#gitlab-lrz",
    "href": "guide/essentials/git_essentials/index.html#gitlab-lrz",
    "title": "Git Essentials",
    "section": "GitLab (LRZ)",
    "text": "GitLab (LRZ)\nBoth GitHub and GitLab are based around the overarching Git distributed control system. The LRZ GitLab is locally hosted and accessible with your (TUM/etc.) university account. Projects, groups, and repositories are only accessible to other authorized users of the LRZ GitLab.\n\nLRZ GitLab\nGitLab Documentation (last visited: 28/07/2023)"
  },
  {
    "objectID": "guide/essentials/git_essentials/index.html#vscode-extensions",
    "href": "guide/essentials/git_essentials/index.html#vscode-extensions",
    "title": "Git Essentials",
    "section": "VSCode Extensions",
    "text": "VSCode Extensions\nSome useful extensions to use Git version control within VSCode.\n\nGitLense – Git supercharged (last visited: 28/07/2023)"
  },
  {
    "objectID": "guide/code_examples/2d_3d_landing_position_comparison/index.html",
    "href": "guide/code_examples/2d_3d_landing_position_comparison/index.html",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "",
    "text": "In this example, the landing position of a particle is calculated in two different ways: a two-dimensional approach based on spherical trigonometry proposed by Butler (1997) and refined by Schoerghofer (2022), and a three-dimensional approach which solves the ODE of the trajectory numerically. The two approaches are compared in terms of accuracy and computational efficiency."
  },
  {
    "objectID": "guide/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position",
    "href": "guide/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "2D Landing Position",
    "text": "2D Landing Position\nWe can now calculate the landing position of the particle using the two-dimensional approach (for a detailed description of the algorithm, see the documentation):\n\nx_landing_2d = landing_position(x0, v0)\n\nGlobalSphericalPosition{Float64}(1.7374e6, 0.018438792639089627, 0.007374965418890142)\n\n\nSince we gave the function landing_position inputs in the format of the ExESS-defined coordinates, the output is also in the same format, i.e., a GlobalSphericalPosition. We can immediately check that the landing position is indeed on the surface of the Moon by looking at the first component of the output: 1.7374e6, which is the radius of the Moon in meters."
  },
  {
    "objectID": "guide/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position-1",
    "href": "guide/code_examples/2d_3d_landing_position_comparison/index.html#d-landing-position-1",
    "title": "Comparison of Landing Position Calculations: 2D vs. 3D",
    "section": "3D Landing Position",
    "text": "3D Landing Position\nWe can do the same calculation using the three-dimensional approach. For this, we are using the predefined acceleration function ddx_lunar_gravity which calculates the acceleration due to the lunar gravity at a given position, plugging it into the trajectory function, together with our previously defined starting position and launch velocity vector. Since we are interested in the landing location, we are just extracting the last step of the trajectory object traj, where positions [4:6] are giving the x-, y-, and z-coordinates of the particle in cartesian coordinates. In order to compare the results with the two-dimensional approach, we are converting the cartesian coordinates into spherical coordinates using the GlobalSphericalPosition constructor:\n\ntraj = trajectory(x0, v0, ddx_lunar_gravity)\nx_landing_3d = GlobalSphericalPosition(GlobalCartesianPosition(traj[end][4:6]))\n\nGlobalSphericalPosition{Float64}(1.7374e6, 0.018440245307911485, 0.007375546356034736)\n\n\nAgain, we can check that the landing position is on the surface of the Moon by looking at the first component of the output: 1.7374e6, which is the radius of the Moon in meters. Without any complicated methods, we can already see that the two results are very similar, up to about the fifth decimal place for the angular arguments."
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "ExESS",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 Alexander Smolka\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "guide/code_examples/mc_simulation/index.html",
    "href": "guide/code_examples/mc_simulation/index.html",
    "title": "Monte-Carlo Simulation",
    "section": "",
    "text": "For additional information about the use of the Monte-Carlo method in the ExESS research project, please refer to respective parts in the documentation."
  },
  {
    "objectID": "guide/code_examples/mc_simulation/index.html#structure",
    "href": "guide/code_examples/mc_simulation/index.html#structure",
    "title": "Monte-Carlo Simulation",
    "section": "Structure",
    "text": "Structure\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Basic Monte-Carlo model structure.\n\n\n\n\n\\newcommand{\\n}[1]{\\begin{tabular}{c}#1\\end{tabular}}\n\\renewcommand{\\vec}[1]{\\boldsymbol{\\mathbf{#1}}}\n    \n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\begin{tikzpicture}[\n    main/.style={draw, thick, rounded corners=4pt, inner sep=2pt, minimum size=20pt, minimum width=25pt, fill=white},\n    decision/.style={draw, diamond, aspect=2, thick, rounded corners=2pt, inner sep=3pt, minimum size=20pt, minimum width=25pt, fill=white},\n]\n\n    %::. main nodes\n    \\node[main] (START) at (0,0) {Start of Monte-Carlo Simulation};    \n    \\node[main, below = 1 of START] (INIT) {\\n{Initialization of Monte-Carlo \\\\ Simulation (e.g. setting of \\\\ global parameters)}};\n    \\node[decision, below = 1 of INIT] (CHECKSTEP) {};\n    \\node[main, below = 1 of CHECKSTEP, very thick] (STEP) {\\n{\\vspace{5mm}\\\\\\textbf{Monte-Carlo Step}\\\\\\vspace{5mm}}};\n    \\node[main, right = 1 of STEP] (END) {\\n{End of\\\\Monte-Carlo Simulation}};\n\n\n    %::. connections\n    \\draw[-latex, thick] (START) -- (INIT);\n    \\draw[-latex, thick] (INIT) -- node[midway, right] {$i=1$} (CHECKSTEP);\n    \\draw[-latex, thick] (CHECKSTEP) -- node [midway, right] {$i\\leq N$} (STEP);\n    \\draw[-latex, thick] (STEP.250) |- ($(STEP.250) + (-2, -1)$) |- node[near start, left] {$i\\mapsto i+1$} (CHECKSTEP.180);\n    \\draw[-latex, thick] (STEP.290) -- ($(STEP.290) + (0, -1.3)$) node[at end, below] {\\n{\\emph{save step }\\\\\\emph{results in file}}};\n    \\draw[-latex, thick] (CHECKSTEP.0) -| node[near start, above] {$i&gt;N$} (END.90);\n\n\\end{tikzpicture}"
  },
  {
    "objectID": "guide/code_examples/mc_simulation/index.html#code",
    "href": "guide/code_examples/mc_simulation/index.html#code",
    "title": "Monte-Carlo Simulation",
    "section": "Code",
    "text": "Code\n\nfunction solvemontecarlo(step::Function, N::Int)\n    results = []\n    for i in 1:N\n        push!(results, step())\n    end\n    return results\nend\n\nsolvemontecarlo (generic function with 1 method)\n\n\n\nExample – Estimating Pi\n\nfunction step()\n    x, y = rand(2)*2 .- 1\n    return x^2 + y^2 &lt;= 1 ? 1 : 0\nend\n\nstep (generic function with 1 method)\n\n\nWhat does this specific stepping function do? It draws two positional arguments, x and y, from a uniform distribution between -1 and 1. Then it checks whether the point is inside the unit circle. If so, it returns 1, otherwise 0. The result is a vector of 1s and 0s, which can be interpreted as a Bernoulli distribution. The results look something like this:\n\n Figure Julia\n\n\n\n\n\n\n\n\n\nN=100\n\n\n\n\n\n\n\nN=1000\n\n\n\n\n\n\n\n\n\nN=10000\n\n\n\n\n\n\n\nN=100000\n\n\n\n\nFigure 2: Green points are inside the unit circle, red points are outside.\n\n\n\n\nusing CairoMakie\nfunction plotMC(N::Integer)\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        aspect=DataAspect())\n    for _ in 1:N\n        x, y = rand(2)*2 .- 1\n        if x^2 + y^2 &lt;= 1\n            scatter!(ax, x, y, color=:green)\n        else\n            scatter!(ax, x, y, color=:red)\n        end\n    end\n    xlims!(ax, (-1,1))\n    ylims!(ax, (-1,1))\n    save(joinpath(@__DIR__, @sprintf(\"%07i.png\", N)), fig, px_per_unit=4)\n    return nothing\nend\nplotMC.([100,1000,10000,100000])\nNote that the code above uses a custom theme loaded in the preamble of the document.\n\n\n\nWe can now use the results to estimate the value of \\(\\pi\\). The area of the unit circle is \\(\\pi\\), the area of the square is 4. The ratio of the areas is thus \\(\\pi/4\\). The ratio of the number of points inside the circle to the total number of points is an estimate of the ratio of the areas. We can thus estimate \\(\\pi\\) as follows:\n\nusing Statistics\nres = solvemontecarlo(step, 1_000_000)\nµ = mean(res)\npi_estimation = µ * 4\n\n3.14146\n\n\n\n\nAdditional Packages\nTwo important packages that can improve the workflow with Monte-Carlo simulations are ProgressMeter and Distributed. The former allows to display of a progress bar, the latter allows simulating in parallel on multiple cores/workers. Both packages offer a simple interface that can be used through a macro that can be placed in front of the for-loop inside of the Monte-Carlo solving function:\n# progress meter and parallel computing\n@showprogress @distributed for i in 1:N \n\n# only progress meter\n@showprogress for i in 1:N\n\n# only parallel computing\n@distributed for i in 1:N"
  },
  {
    "objectID": "guide/code_examples/mc_simulation/index.html#structure-1",
    "href": "guide/code_examples/mc_simulation/index.html#structure-1",
    "title": "Monte-Carlo Simulation",
    "section": "Structure",
    "text": "Structure"
  },
  {
    "objectID": "guide/code_examples/mc_simulation/index.html#code-1",
    "href": "guide/code_examples/mc_simulation/index.html#code-1",
    "title": "Monte-Carlo Simulation",
    "section": "Code",
    "text": "Code"
  },
  {
    "objectID": "guide/essentials/package_installation/index.html#installation",
    "href": "guide/essentials/package_installation/index.html#installation",
    "title": "ExESS Package Installation",
    "section": "Installation",
    "text": "Installation\nThis simulation tool was created as a custom package for the computer language Julia. Please refer to the official guide to installing Julia on your machine. To be able to use the ExESS package, the entire repository has to be downloaded from LRZ-GitLab. Afterward, the code can be used in several different ways. The entire module can be included directly by specifying the path of the downloaded package in the include call.\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS"
  },
  {
    "objectID": "guide/essentials/package_installation/index.html#required-packages",
    "href": "guide/essentials/package_installation/index.html#required-packages",
    "title": "ExESS Package Installation",
    "section": "Required Packages",
    "text": "Required Packages\nThe ExESS package relies on multiple other packages that have to be added and installed by the user. They can be added using Julia’s package-manager Pkg:\nusing Pkg\nPkg.add(\"Interpolations\")\nPkg.add(\"NearestNeighbors\")\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"SpecialFunctions\")"
  },
  {
    "objectID": "guide/essentials/onboarding_checklist/index.html",
    "href": "guide/essentials/onboarding_checklist/index.html",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "",
    "text": "This page contains a checklist for students to get started working on their thesis based on the ExESS research project. While the General Checklist is applicable to students of all levels (Bachelor/Semester/Master) and all topics (theoretical/numerical/…); the other lists are only relevant for certain levels and topics. For questions, please get in touch with me: a.smolka@tum.de."
  },
  {
    "objectID": "guide/essentials/onboarding_checklist/index.html#sec-general",
    "href": "guide/essentials/onboarding_checklist/index.html#sec-general",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "General Checklist",
    "text": "General Checklist\nThis general checklist shall be completed in the first week(s) of your student thesis work.\n\nreceive “LPE Thesis Starter Set”\n\nread and understand the “Student Thesis Information” presentation slides\n\nopen (and/or install) Matrix and log in using your TUM-ID\n\nuse Matrix to send me a message containing one of the logical fallacies listed in the “Student Thesis Information”\n\nset up LRZ Sync&Share online folder\nregister your thesis\n\ncheck the information on the registration document (LRZ Sync&Share folder), sign the document, and upload the signed registration to the same folder\n\nset up a weekly meeting (including a fixed, weekly repeating outlook meeting)\n\nplease prepare a short presentation for each regular meeting, which should at a minimum, contain two slides: one with a list of the tasks you have completed since the last meeting and one with a list of the tasks you plan to complete until the next meeting\n\nset up a time plan for your thesis and include the plan in your first presentation (see the example below)\n\n\n\n\n\n\n\nExample Time-Plan\n\n\n\nThe first time plan does not need to be (can not and should not be) very detailed. It should, however, give a rough overview of the tasks you plan to complete and the time you plan to spend on each task. The following is an example of a first draft of a time plan for a 6-month thesis. The time plan is written in Mermaid, which is a markdown-like language for generating diagrams. The Mermaid code is included in the source of this page, so you can copy it and modify it for your own time-plan. You can also use the Mermaid Live Editor to generate your own time plan.\nFor your thesis, revisit the time plan regularly and update it accordingly. This will help you to keep track of your progress and to identify potential problems early on. Adding more details to the time plan over time will give you a good starting point for your thesis report.\n\n\n\n\ngantt\n  %% title Student Thesis Time-Plan\n  dateFormat DD-MM\n  axisFormat %m\n\n  section On-Boarding\n    On-Boarding Checklist: 01-01, 16-01\n    Learning Julia: 01-01, 01-03\n  section Reading\n    Reading Papers: 01-01, 01-04\n  section Writing\n    Continuous Documentation: 01-01, 15-05\n    Thesis Writing: 15-04, 15-06\n    Thesis Review: 15-06, 01-07\n    Thesis Submission: milestone, 01-07"
  },
  {
    "objectID": "guide/essentials/onboarding_checklist/index.html#sec-numerical",
    "href": "guide/essentials/onboarding_checklist/index.html#sec-numerical",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "Numerical Based Thesis Checklist",
    "text": "Numerical Based Thesis Checklist\nIn case you are working on a numerical-based thesis, the following checklist can help you get started with your work.\n\nset up Julia\n\ncheck out the list with recommended Julia Resources\n\nset up the ExESS package (if applicable)"
  },
  {
    "objectID": "documentation/trajectories/non-ballistic_trajectories.html",
    "href": "documentation/trajectories/non-ballistic_trajectories.html",
    "title": "5.2 Non-Ballistic Trajectories",
    "section": "",
    "text": "CitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/documentation.html",
    "href": "documentation/documentation.html",
    "title": "Preface",
    "section": "",
    "text": "Authors\nAlexander Smolka\n\n\nLicense\nLicense\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/fundamentals/moon.html",
    "href": "documentation/fundamentals/moon.html",
    "title": "2.6 The Moon",
    "section": "",
    "text": "Some intro text"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#measurements-and-modeling",
    "href": "documentation/fundamentals/moon.html#measurements-and-modeling",
    "title": "2.6 The Moon",
    "section": "Measurements and Modeling",
    "text": "Measurements and Modeling\nAboard the LRO the DLRE gathered infrared data of the lunar surface to create temperature maps of the Moon.\n\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Based on a Diviner measurement snapshot.\n\n\n\n\n\n\n\n(b) Based on the average Diviner measurements.\n\n\n\n\n\n\n\n\n\n(c) Based on the analytic function of Butler (1997).\n\n\n\n\n\n\n\n(d) Based on the analytic function of Hurley et al. (2015)\n\n\n\n\nFigure 2: Global, stationary lunar surface temperature maps. Coordinates given with respect to the subsolar point at \\((\\Theta_{ss}, \\Phi_{ss}) = (0,0)\\), presented in local time and subsolar latitude.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = GeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction lunarSurfaceTemperaturesDivinerAverage(name=\"lunarSurfaceTemperatureDivinerAverage\")\n    fig, ga, theta, phi = _default_()\n    \n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner_avg(theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\")\n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesDiviner(name=\"lunarSurfaceTemperatureDiviner\")\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesBUTLER(name=\"lunarSurfaceTemperatureBUTLER\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_BUTLER1997(theta, phi)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesHURLEY(name=\"lunarSurfaceTemperatureHURLEY\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_HURLEY2015(theta, phi)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=ColorSchemes.lipari, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\nFor the exact design, a custom theme was loaded in the preamble of the document.\n\n\n\n diviner.png \n diviner_average.png \n butler.png \n hurley.png \n\n\n\n\n\n\n\n\n\n\n\n\nAnimation of Diviner Temperature Snapshots\n\n\n\n\n\n\n Animations Julia Downloads\n\n\n\n\n\n\n\n\n\n(a) Selenographic coordinate system.\n\n\n\n\n\n\n\n(b) Subsolar coordinate system.\n\n\n\n\nFigure 3: Animations of Diviner lunar surface temperature measurements in a Moon-centered (selenographic) and a “fixed”, solar-based (subsolar) coordinate system. Both animations contain the identical 18 individual snapshots. Note that (a) does not have a local time x-axis, but a selenographic one, which has been omitted for clarity.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes, Printf\n\ncmap = ColorSchemes.lipari\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = MyLTGeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction anim_raw_diviner(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n    ga.xticklabelcolor = :white\n    ga.xlabelcolor = :white\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        T = lunar_surface_temperatures_diviner((step-1)*2*pi/steps, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T\n        \n        save(joinpath(@__DIR__, \"anim_raw_diviner\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\n\nfunction anim_raw_diviner_fixed(steps=18)\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    for step in 1:steps\n        Nstep = floor(Int64, (step-1)*N/steps)\n        T = lunar_surface_temperatures_diviner(Nstep/N * 2pi, theta, phi)\n        T = reshape(T,N,M)\n        s[3] = T[vcat(Nstep+1:N, 1:Nstep), :]\n        \n        save(joinpath(@__DIR__, \"anim_raw_diviner_fixed\", @sprintf \"%02i.png\" step), fig, px_per_unit=4)\n    end\n    return nothing\nend\nThe code above creates individual .png files which are subsequently converted into animated .gifs.\n\n\n\n anim_raw_diviner.gif \n anim_raw_diviner_fixed.gif \n\n\n\n\n\n\n\n\nButler (1997) proposed an analytical surface temperature distribution based on the solar zenith angle \\(\\psi_s\\) with regard to the local surface normal, assuming a perfectly spherical Moon, see Figure 2. Given the subsolar position \\(\\left(\\Theta_{ss}, \\Phi_{ss}\\right)\\), longitude and latitude respectively, the cosine of the zenith angle can be calculated as \\(\\cos\\psi_s = \\cos\\Theta_{ss} \\cdot \\cos\\Phi_{ss}\\). All measurements of the lunar surface temperatures on the dayside suggest a \\(\\cos^{1/4}\\) shape with regard to the solar zenith angle (Hurley et al., 2015; Vasavada et al., 2012), though such models break down on the nightside. By introducing a cutoff at the terminators alongside a defined nightside temperature and shifting the distribution up, Butler (1997) arrived at \\[\\begin{equation}\n    T(\\psi_s) = \\begin{cases}\n        250\\,\\mathrm{K} \\cdot \\cos^{1/4} (\\psi_s) + 100\\,\\mathrm{K}, \\qquad & \\text{ if } \\psi_s \\leq 90\\,\\mathrm{\\degree}, \\\\\n        100\\,\\mathrm{K}, & \\text{ if } \\psi_s &gt; 90\\,\\mathrm{\\degree}.\n    \\end{cases} \\label{eq:lunar_surface_temperatures_BUTLER}\n\\end{equation}\\]\n\n\n lunar_surface_temperatures_BUTLER1997\nHurley et al. (2015) proposed another model to further improve the analytical description of the lunar surface temperatures, which included a combination of a cosine-law dependence on the dayside and a 6-term polynomial fitted cooling function for the nightside: \\[\\begin{equation}\n    T(\\Theta_{ss}, \\Phi_{ss}) = \\begin{cases}\n        262\\,\\mathrm{K} \\cdot \\cos^{1/2} \\left( \\psi_s \\right) + 130\\,\\mathrm{K}, \\qquad & \\text{ if } \\left|\\Theta_{ss}\\right| &lt; 90\\,\\mathrm{\\degree}, \\\\\n        \\left( \\sum_{i=0}^5 a_i \\Theta_{ss}^i \\right) + 35\\,\\mathrm{K} \\left( \\sin \\overline{\\Phi_{ss}} - 1\\right), \\qquad & \\text{ else.}\n    \\end{cases} \\label{eq:lunar_surface_temperatures_HURLEY}\n\\end{equation}\\] with the longitude \\(\\Theta_{ss}\\) and the subsolar co-latitude \\(\\overline{\\Phi_{ss}} = \\pi/2 - \\Phi_{ss}\\). The coefficients of the polynomial fit are \\(a = \\left[444.738,\\; -448.937,\\; 239.668,\\; -63.8844,\\; 8.34064,\\; -0.423502 \\right]\\) in kelvin. Note that the longitude has to be used in radians and must be positively defined on the range of \\(\\Theta_{ss} \\in \\left(\\pi/2, 3\\pi/2\\right)\\) for the nightside.\n\n\n lunar_surface_temperatures_HURLEY2015\n\n\n Figure Julia - Mean Julia - RMS Downloads\n\n\n\n\n\n\n\n\n\n(a) Statistical temperature difference mean.\n\n\n\n\n\n\n\n(b) Root mean squared error of temperature differences.\n\n\n\n\nFigure 4: Statistical comparison of the lunar surface temperatures models with Diviner measurements. Temperature difference based on analytical functions by Butler (1997), Eq. \\(\\eqref{eq:lunar_surface_temperatures_BUTLER}\\), and Hurley et al. (2015), Eq. \\(\\eqref{eq:lunar_surface_temperatures_HURLEY}\\), compared to the averaged Diviner measurements and evaluated on grid points, equally distributed and weighted with their respective surface area. Comparisons are represented by their statistical mean (a) and their root mean squared error (b), applied globally (circles), on the dayside (squares), and on the nightside (diamonds).\n\n\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_rms(N=18, name=\"temperature_comparison_rms\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, sqrt(mean(dTBlat.^2)))  \n        push!(eBd, sqrt(mean(dTBlatd.^2)))\n        push!(eBn, sqrt(mean(dTBlatn.^2)))\n        push!(eH, sqrt(mean(dTHlat.^2)))  \n        push!(eHd, sqrt(mean(dTHlatd.^2)))\n        push!(eHn, sqrt(mean(dTHlatn.^2)))\n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"RMS Temperature Differences [K]\",\n        yticks=0:20:70,)\n    ylims!(0, 70)\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n        [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false,\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_mean(N=18, name=\"temperature_comparison_mean\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, mean(dTBlat))   \n        push!(eBd, mean(dTBlatd)) \n        push!(eBn, mean(dTBlatn)) \n        push!(eH, mean(dTHlat))   \n        push!(eHd, mean(dTHlatd)) \n        push!(eHn, mean(dTHlatn)) \n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"Mean Temperature Differences [K]\")\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n    [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\n\n mean.pdf   mean.svg   mean.png \n rms.pdf   rms.svg   rms.png \n\n\n\n\n\nThe two presented analytical models of the lunar surface temperatures have been compared with the averaged DLRE measurements. Figure 4 shows this statistical analysis of the temperatures difference of the Butler (1997) and Hurley et al. (2015) calculated as \\(\\Delta T_i = T_i - T_\\text{Diviner}\\) for each analytical model \\(i\\), evaluated on \\(270e3\\) surface points, globally distributed using the HEALPix method.\nThe left side shows the statistical mean of said temperature differences as a function of subsolar latitude for both models, both globally as well as exclusively on the dayside and nightside of the Moon. Up to \\(\\Phi_{ss}=60\\,\\mathrm{\\degree}\\), the Hurley et al. (2015) model has global means very close to zero, with slight deviations for the exclusive day- and night side. Closer to the poles, the model tends towards positive temperature differences, peaking at around \\(35\\,\\mathrm{K}\\) above the Diviner model on the sunlit side. Using the model by Butler (1997) this effect is even more pronounced with the means starting below zero at the equator and continuously increasing with higher latitudes. Final values close to the poles reach temperature differences of more than \\(60\\,\\mathrm{K}\\) on the dayside.\nTo further investigate the two models, the rms value of the temperature differences \\[\\begin{equation}\n    \\Delta T_{\\text{rms}, i} = \\sqrt{\\frac{1}{N_j} \\cdot \\sum_j^{N_j} \\left(\\Delta T_{i,j}\\right)^2},\n\\end{equation}\\] for \\(N_j\\) applicable positions \\(j\\) is shown on the right side of Figure 4. In comparison with the previously shown statistical mean, the rms shows the spread of the temperatures around the mean. For all cases, globally, dayside, and nightside, the Hurley et al. (2015) model has lower rms values, which are less than \\(10\\,\\mathrm{K}\\) for latitude uo to \\(60\\,\\mathrm{\\degree}\\). Closer to the poles and similar to the mean value, the dayside temperatures tend to deviate the most, peaking at \\(43\\,\\mathrm{K}\\) at \\(80\\,\\mathrm{\\degree}\\). Generally, a steadily increasing behaviour with higher latitudes can be observed. For the Butler (1997) model, the rms values start considerably higher with the worst deviations on the dayside of the Moon. For roughly \\(50\\,\\mathrm{\\degree}\\) from the equator, the values decrease to the lowest value of \\(17\\,\\mathrm{K}\\) before sharply increasing polewards of it."
  },
  {
    "objectID": "documentation/fundamentals/moon.html#permanently-shadowed-regions",
    "href": "documentation/fundamentals/moon.html#permanently-shadowed-regions",
    "title": "2.6 The Moon",
    "section": "Permanently Shadowed Regions",
    "text": "Permanently Shadowed Regions\nSchörghofer et al. (2021) investigated the sizes of PSRs and found that their total area in the northern polar region (poleward of \\(80\\,\\mathrm{\\degree}\\)) is around \\(1.3\\times 10^{\\mathrm{4}}\\,\\mathrm{km^{\\mathrm{2}}}\\), while the southern polar region has a total area of \\(1.6\\times 10^{\\mathrm{4}}\\,\\mathrm{km^{\\mathrm{2}}}\\)."
  },
  {
    "objectID": "documentation/fundamentals/moon.html#interplanetary-magnetic-field",
    "href": "documentation/fundamentals/moon.html#interplanetary-magnetic-field",
    "title": "2.6 The Moon",
    "section": "Interplanetary Magnetic Field",
    "text": "Interplanetary Magnetic Field"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#electric-surface-potential",
    "href": "documentation/fundamentals/moon.html#electric-surface-potential",
    "title": "2.6 The Moon",
    "section": "Electric Surface Potential",
    "text": "Electric Surface Potential\nIn space, objects typically charge to a potential where the total current is zero, mainly from ambient electrons, ions, and photoelectron emission. In the case of the Moon, this implies that the lunar surface typically attains a negative potential in shadow, roughly equivalent to the electron temperature, and a positive potential in sunlight, approximately matching the photoelectron temperature (a few \\(\\,\\mathrm{eV}\\)). (Halekas et al., 2005)\nAccording to Futaana et al. (2012), the Moon’s absence of a considerable atmosphere and global magnetic field fosters direct interaction between its surface and the solar wind, resulting in the accumulation of electrostatic charges. The lunar surface potential varies based on factors like location, time of day, and prevailing solar wind conditions. Due to the majority of incoming plasma impacting the sunlit side of the Moon and getting adsorbed or neutralized, a plasma void wake structure forms downstream on the lunar night side. Through photoelectrons, the lunar dayside typically maintains a positive electrostatic potential of around +20 V, while the absence of photons on the opposite side leads to pronounced negative charges, reaching as low as -200 V. (Halekas et al., 2005; Wurz et al., 2022)"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#magnetic-anomalies",
    "href": "documentation/fundamentals/moon.html#magnetic-anomalies",
    "title": "2.6 The Moon",
    "section": "Magnetic Anomalies",
    "text": "Magnetic Anomalies"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#missions",
    "href": "documentation/fundamentals/moon.html#missions",
    "title": "2.6 The Moon",
    "section": "Missions",
    "text": "Missions\n\nDensity Projections\nDue to the scarcity of ground-based data, satellite measurements at varying altitudes are often used in the investigation of planetary exospheres. In order to compare measurements at different altitudes, the data must be projected into a common altitude, which usually is the exobase altitude, which is the surface of the planetary body given surface-bounded exospheres.\nChamberlain (1963) derived a model for the exospheric particle number density \\(n\\left(r\\right)\\) as a function of the radial distance from the center of the planetary body, based on the assumption of a hydrostatic equilibrium and a Maxwellian velocity distribution, see section Velocity Distributions: \\[\\begin{equation}\n    % \\numberDensity(\\radius) = \\numberDensity(\\radius+\\height) \\cdot \\partitionFunction \\cdot \\exp \\left(\\relativeEnergy\\left(\\radius\\right) - \\relativeEnergy\\left(\\radius+\\height\\right) \\right)\n    n= \\tilde n\\cdot \\zeta\\cdot \\exp \\left(\\epsilon- \\tilde\\epsilon\\right)\n    \\label{eq:chamberlain_projection}\n\\end{equation}\\] with the known number density \\(\\tilde n= n(\\tilde r)\\) at some known radial distance \\(\\tilde r= r+ h\\) with \\(r, h\\in\\mathbb{R}^+\\), relative potential energies \\(\\epsilon\\), and a partition function \\(\\zeta\\). If the radial distance is equal to the radius of the planetary body, the number density is equal to the surface number density \\(n_0\\). Equation \\(\\eqref{eq:chamberlain_projection}\\) is the general form of the isothermal barometric law (Chamberlain, 1963).\nThe relative energy of the projection function is given as absolute potential energy in units of thermal energy \\(k_BT\\): \\[\\begin{equation}\n    \\epsilon\\left(r\\right) = \\left| - \\frac{m\\hat mG}{k_BTr} \\right|\n    \\label{eq:relative_potential_energy}\n\\end{equation}\\] with the mass \\(m\\) of the particle, the mass \\(\\hat m\\) of the planetary body, and the gravitational constant \\(G\\) (Chamberlain, 1963). Both, \\(\\epsilon= \\epsilon\\left(r\\right)\\) and \\(\\tilde\\epsilon= \\epsilon\\left(r+h\\right)\\), are required for the partition function \\(\\zeta\\), which is the linear combination of three individual partition functions which are describing particles in ballistic orbits, \\(\\zeta_{bal}\\), particles in satellite orbits, \\(\\zeta_{sat}\\), and particles that are on escape trajectories, \\(\\zeta_{esc}\\): \\[\\begin{align}\n    \\zeta_{bal} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{sat} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{esc} &= \\frac{1}{\\sqrt{\\pi}} \\left( \\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\right. \\nonumber \\\\\n    &\\left. \\qquad \\cdot \\left(\\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right) \\right) \\\\[4mm]\n    \\Rightarrow \\zeta&= \\zeta_{bal} + \\zeta_{sat} + \\zeta_{esc}\n\\end{align}\\] with the gamma and lower incomplete gamma function, \\(\\Gamma\\) and \\(\\gamma\\), respectively (Cook et al., 2013).\n\n\nLACE\nThe LACE (Lunar Atmospheric Composition Experiment) on the Apollo 17 mission was part of the ALSEP (Apollo Lunar Surface Experiments Package) to investigate the composition and variation of the Moon’s exosphere. Specifically designed for the mission, the instrument consisted of a small, remotely operated package containing a mass spectrometer coupled with a pressure sensor. With its opening oriented upward, it was able to measure the downward stream of particles at the lunar surface at the Apollo 17 landing location, the Taurus-Littrow Valley. On December 27, 1971, the instrument was activated to start the data acquisition process \\(50\\,\\mathrm{h}\\) after local sunset to operate through one entire lunar night. Increasing exospheric number densities at the morning-terminator as well as higher outgassing rates led to elevated background gas levels and prompted the temporary suspension of operations during the lunar day, except a short check near \\(12\\,\\mathrm{h}\\) local time. In total, the LACE measured the nighttime densities for nine lunations. (Hoffman, 1975; Killen et al., 2019)\nThe instrument’s mass spectrometer measured the mass per unit charge ratio up to a maximum of \\(110\\,\\mathrm{}\\) in three mass ranges \\(1\\,\\mathrm{}\\) to \\(4\\,\\mathrm{}\\), \\(12\\,\\mathrm{}\\) to \\(48\\,\\mathrm{}\\), and \\(27.4\\,\\mathrm{}\\) to \\(110\\,\\mathrm{}\\) termed low, medium, and high. A triple-channel analyzer was able to capture data from all three ranges simultaneously as counts per \\(0.6\\,\\mathrm{s}\\) at every voltage step (Hoffman, 1975). Note that due to the measurement technique ambiguous data points of particles with double mass being doubly ionized were taken (Killen et al., 2019).\n\n\nLADEE\nThe LADEE (Lunar Atmosphere and Dust Environment Explorer) mission was created in 2008 to address the goals identified in the decadal survey report “Scientific Context for Exploration of the Moon”, which highlighted the lunar atmosphere as a priority for future lunar science missions. Among its main mission objectives was to determine the composition of the lunar exosphere, as well as its distribution and variability. On April 18th, 2014, LADEE was decommissioned through impact into the Moon after around \\(100\\,\\mathrm{d}\\) of nominal science operations. The gathered data was processed and submitted to the NASA PDS (Planetary Data System) for public access (Hine & Delory, 2014). The NMS (Neutral Mass Spectrometer) aboard the spacecraft measured the mass distribution of neutral species over a mass-to-charge range between \\(2\\,\\mathrm{}\\) to \\(150\\,\\mathrm{}\\). With its retrograde, equatorial orbit around the Moon, LADEE conducted systematic surveys of helium, neon, and argon densities confined in a \\(\\pm23\\,\\mathrm{\\degree}\\) near-equatorial band with altitudes ranging between \\(4\\,\\mathrm{}\\) and \\(61\\,\\mathrm{km}\\) (Benna et al., 2015).  pds-atmospheres.nmsu.edu  last visited: May 2023\n\n\n Figure Julia Download\n\n\n\n\n\n\n\n\n\n(a) Helium surface number densities.\n\n\n\n\n\n\n\n\n\n(b) Neon surface number densities.\n\n\n\n\n\n\n\n\n\n(c) Argon surface number densities.\n\n\n\n\nFigure 5: Helium (a), neon (b), and argon (c) surface number densities, based on derived data of the LADEE mission and projected to the surface based on Chamberlain (1963) barometric model. Maximum densities are highlighted with a red marker and the respective numeric value of the surface number density. The data was taken from the PDS (Hine & Delory, 2014). Gray areas indicate lunar nighttime.\n\n\n\n\nusing .ExESS\nusing DataFrames, CSV\nDATA_PATH = joinpath(@__DIR__, \"..\", \"..\", \"data\", \"ladee_data_derived\")\n\n#::. processing functions\nfunction get_file_names()\n    dirs = readdir(DATA_PATH)\n    dirs = filter(x -&gt; occursin(\"20\", x), dirs)\n    files = String[]\n    for dir in dirs\n        new_files = readdir(joinpath(DATA_PATH, dir))\n        new_files = filter(x -&gt; occursin(r\"csv$\", x), new_files)\n        files = vcat(files, joinpath.(dir, new_files))\n    end\n    return files\nend\nfunction get_file_names(element::String)\n    files = get_file_names()\n    files = filter(x -&gt; occursin(lowercase(element), x), files)\n    return files\nend\n\nfunction load_data(file::String)\n    df = DataFrame(CSV.File(joinpath(DATA_PATH, \"$file\")))\n    return df\nend\n\nfunction load_all_data(element::String)\n    files = get_file_names(element)\n    df = DataFrame()\n    for file in files\n        df = vcat(df, load_data(file))\n    end\n    return df\nend\n\nfunction find_max(df::DataFrame)\n    idxs = Int64[]\n    for (idx, val) in enumerate(df[:,14])\n        if !isnan(val); push!(idxs, idx); end\n    end\n    n = df[idxs,14]\n    val, idx = findmax(n)\n    return val, df[idx, 13], df[idx,12]\nend\n\n#::. plotting functions\nfunction plot_lat(element::String; kwargs...)\n    df = load_all_data(element)\n    plot_lat(df, element; kwargs...)\n    return nothing\nend\nfunction plot_lat(df::DataFrame, element::String; stdfilter=1.0, cmap=reverse(ColorSchemes.deep))\n    idxs = df[:,15] ./ df[:,14] .&lt; stdfilter\n\n    #::. figure and axis setup\n    fig = Figure(resolution=(1000,230))\n    ax = MyLTGeoAxis(fig[1, 1];\n        xlabelpadding=30,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax, -30, 30)\n    night_shade(ax)\n\n    #::. data\n    sc = scatter!(ax, df[idxs, 13]/24*360 .- 180, df[idxs, 12];\n        color=df[idxs, 14],\n        colormap=cmap,\n        colorrange=(0, 2e4),\n        markersize=2)\n\n    #::. plot maximum\n    nmax, lonmax, latmax = find_max(df[idxs,:])\n    scatter!(ax, lonmax/24*360 .- 180, latmax; color=\"red\", markersize=10, marker=:utriangle)\n    text!(ax, lonmax/24*360 .- 180, latmax; text=\"$(round((nmax/1e3); digits=1))\", halign=:left, valign=:bottom, color=\"red\")\n\n    #::. colorbar\n    Colorbar(fig[1,2], sc;\n        label=\"$element Abundance [10³/cm³]\",\n        ticks=([0,5000,10000,15000,20000], [\"0\", \"5\", \"10\", \"15\", \"20\"]),\n        highclip=cmap[end] |&gt; RGB{Colors.N0f8})\n    \n    #::. custom x-axis labels\n    ax2 = MyLTGeoAxis(fig[1, 1];\n        spinewidth = 0,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax2, -40, 30)\n    hidedecorations!(ax2)\n    text!(ax2, -140, -30; text= \"0\")\n    text!(ax2,  -63, -30; text= \"6\")\n    text!(ax2,   11, -30; text=\"12\")\n    text!(ax2,   89, -30; text=\"18\")\n    text!(ax2,  165, -30; text=\"24\")\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.pdf\"), fig)\n    # save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.svg\"), fig) # too big!\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.png\"), fig, px_per_unit=4)\n    return nothing\nend\n\n\n#::.\nget_all() = load_all_data(\"He\"), load_all_data(\"Ne\"), load_all_data(\"Ar\")\nfunction run_all(dfHe, dfNe, dfAr; T=250, kwargs...)\n    dfHe_p, dfNe_p, dfAr_p = copy(dfHe), copy(dfNe), copy(dfAr)\n    dfHe_p[:,14] .= projection_CHAMBERLAIN1963.(dfHe_p[:, 14], LUNAR_RADIUS .+ dfHe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(4))\n    dfNe_p[:,14] .= projection_CHAMBERLAIN1963.(dfNe_p[:, 14], LUNAR_RADIUS .+ dfNe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(20))\n    dfAr_p[:,14] .= projection_CHAMBERLAIN1963.(dfAr_p[:, 14], LUNAR_RADIUS .+ dfAr_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(40))\n    plot_lat(dfHe_p, \"He\"; kwargs...)\n    plot_lat(dfNe_p, \"Ne\"; kwargs...)\n    plot_lat(dfAr_p, \"Ar\"; kwargs...)\nend"
  },
  {
    "objectID": "documentation/fundamentals/moon.html#densities-by-exospheric-species",
    "href": "documentation/fundamentals/moon.html#densities-by-exospheric-species",
    "title": "2.6 The Moon",
    "section": "Densities by Exospheric Species",
    "text": "Densities by Exospheric Species\nThis section lists referenced values of the lunar exosphere surface densities, generally provided as a number density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\). Some references provide their values in terms of a column density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-2}}}\\right]\\), which includes the respective measurements column height, i.e., the illuminated line of sight of brightness measurements like LAMP.\nSee the additional information section in this section’s appendix to find details about some sources, their assumptions, and their measurement methods.\n\nAtomic Hydrogen – \\(\\ce{H}\\)\n\n\nTable 1: Overview of reported hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nupper limit, UVS Apollo 17\n\\(1.0 \\times 10^1\\)\nFastie et al. (1973)\n\n\nupper limit\n\\(1.7 \\times 10^1\\)\nFeldman & Morrison (1991)  Gladstone et al. (2009)\n\n\nLAMP\n\\(1.4 \\times 10^{-1}\\)\nGladstone et al. (2009)\n\n\nmodel predictions, dayside\n\\(8.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit\n\\(2.4 \\times 10^1\\)\nCook et al. (2013)\n\n\n\n\n\n\nMolecular Hydrogen – \\(\\ce{H2}\\)\n\n\nTable 2: Overview of reported molecular hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nmodel predictions, dayside  model predictions, nightside\n\\(2.0 \\times 10^3\\)  \\(1.2 \\times 10^4\\)\nHodges et al. (1973)\n\n\nLACE, upper limit, dayside  LACE, upper limit, nightside\n\\(6.0 \\times 10^3\\)  \\(6.5 \\times 10^4\\)\nHoffman et al. (1973)\n\n\nUVS Apollo 17, upper limit\n\\(1.2 \\times 10^4\\)\nFastie et al. (1973)\n\n\nApollo, upper limit, dayside  Apollo, upper limit, nightside\n\\(2.5 \\text{ to } 9.9 \\times 10^3\\)  \\(1.0 \\text{ to } 15.0 \\times 10^4\\)\nHeiken et al. (1991), chap 3.10\n\n\nupper limit  expected LAMP density\n\\(9.0 \\times 10^3\\)  \\(1.1 \\times 10^4\\)\nGladstone et al. (2009)\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2}\\)\n\\(2.1 \\times 10^3\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit, dusk  LAMP, upper limit, dawn\n\\(1.3 \\text{ to } 2.1 \\times 10^3\\)  \\(1.8 \\text{ to } 2.4 \\times 10^3\\)\nCook et al. (2013)\n\n\nLAMP, “effective”  LAMP, nightside, dusk  LAMP, nightside, dawn\n\\(0.8 \\text{ to } 1.6 \\times 10^3\\)  \\(0.5 \\text{ to } 1.5 \\times 10^3\\)  \\(0.9 \\text{ to } 1.9 \\times 10^3\\)\n Stern et al. (2013)\n\n\nCHACE, at latitudes: \\(20\\text{ to }50\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(50\\text{ to }70\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(70\\text{ to }90\\,\\mathrm{\\degree}\\)\n\\(4.0 \\text{ to } 6.0 \\times 10^2\\)  \\(5.0 \\text{ to } 6.5 \\times 10^2\\)  \\(6.5 \\text{ to } 8.5 \\times 10^2\\) \n Thampi et al. (2015)\n\n\nmodel predictions, equator, dayside  model predictions, equator, nightside  model predictions, equator, dayside, in magnetotail  model predictions, equator, nightside, in magnetotail\n\\(1.5 \\text{ to } 2.2 \\times 10^3\\)  \\(3.0 \\text{ to } 4.2 \\times 10^3\\)  \\(0.4 \\text{ to } 0.7 \\times 10^3\\)  \\(1.0 \\text{ to } 1.5 \\times 10^3\\)\n Tucker et al. (2021)\n\n\n\n\n\n\nHelium – \\(\\ce{He}\\)\n\n\nTable 3: Overview of reported helium surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(1.6 \\times 10^3\\)  \\(3.8 \\times 10^4\\)\nHodges et al. (1973)\n\n\nupper limit, dayside  upper limit, nightside\n\\(2.0 \\times 10^3\\)  \\(4.0 \\times 10^4\\)\nHoffman et al. (1973)\n\n\n\n\n\n\nHydroxyl – \\(\\ce{OH}\\)\n\n\nTable 4: Overview of reported hydroxyl surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]OH}\\)\n\\(1.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\n\n\n\n\nWater – \\(\\ce{H2O}\\)\n\n\nTable 5: Overview of reported water surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2O}\\)\n\\(2.9 \\times 10^3\\)\nWurz et al. (2012)\n\n\n\n\n\n\nNeon – \\(\\ce{Ne}\\)\n\n\nTable 6: Overview of reported Neon surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(4.0 \\text{ to } 7.0 \\times 10^3\\)  \\(1.0 \\text{ to } 2.0 \\times 10^5\\)\nHodges et al. (1973)\n\n\nsolar zenith angle:    \\(+168\\degree\\)    \\(-136\\degree\\)    \\(-112\\degree\\)    \\(-89\\degree\\)  \\(\\Rightarrow\\) average\n \\(9.4 \\times 10^4\\)  \\(7.7 \\times 10^4\\)  \\(7.1 \\times 10^4\\)  \\(8.7 \\times 10^4\\)  \\(8.2 \\times 10^4\\) \n   Hoffman et al. (1973)\n\n\n\n\n\n\nArgon – \\(\\ce{Ar}\\)"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html",
    "href": "documentation/fundamentals/coordinate_systems.html",
    "title": "2.1 Coordinate Systems",
    "section": "",
    "text": "Some introduction text…\n\nCartesian and Spherical Coordinates\nA clear distinction has been made between cartesian and spherical coordinates and cartesian and spherical elements. The former is used to describe the domain in which the vector is defined, while the latter is used to describe the vector and its components themselves. For example, a position vector in a cartesian coordinate system, \\(\\boldsymbol{\\mathbf{x}}\\), can be expressed in cartesian elements \\(\\left(x, y, z\\right)\\), which are the x-, y-, and z-components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}= \\begin{bmatrix}\n        x\\\\\n        y\\\\\n        z\n    \\end{bmatrix} \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n    \\label{eq:cartesian_coordinate}\n\\end{equation}\\]\n\n\nVectors defining a position or a velocity in a cartesian coordinate system and in cartesian elements, like the one shown in Eq. \\(\\eqref{eq:cartesian_coordinate}\\):\n GlobalCartesianPosition\n GlobalCartesianVelocity\nThe same vector in the same coordinate system and, thus, the same domain can also be expressed using spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\), which are the radial, azimuthal, and elevation components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}_s = \\begin{bmatrix}\n        r\\cos\\vartheta\\cos\\varphi\\\\\n        r\\sin\\vartheta\\cos\\varphi\\\\\n        r\\sin\\varphi\n    \\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n\\end{equation}\\] Note that the subscript \\(s\\) indicates that the vector is expressed in spherical elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s\\). On the other hand, a coordinate can also be projected into a spherical coordinate system, \\(\\boldsymbol{\\mathbf{r}}\\), which is a different domain, and expressed in spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}= \\begin{bmatrix}r\\\\ \\vartheta\\\\ \\varphi\\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n    \\label{eq:spherical_coordinate}\n\\end{equation}\\]\nThe same coordinate can also be expressed in cartesian elements \\(\\left(x, y, z\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}_c = \\begin{bmatrix}\n        \\sqrt{x^2 + y^2 + z^2} \\\\\n        \\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\\\\n        \\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\n    \\end{bmatrix}  \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n\\end{equation}\\]\n\n\nVectors defining a position or a velocity in a spherical coordinate system and in spherical elements, like the one shown in Eq. \\(\\eqref{eq:spherical_coordinate}\\):\n GlobalSphericalPosition\n GlobalSphericalVelocity\nNote that the subscript \\(c\\) indicates that the vector is expressed in cartesian elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). Even though physically speaking, all four coordinate vectors can describe the same position in physical space, mathematically speaking, they are different vectors, thus: \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s \\neq \\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). The following sections will go into more detail about the differences between these coordinate systems, where the names and are used to describe the domain and not the elements.\nAll coordinate vectors can also be written as a sum of scaled base vectors, where the base vectors are the unit vectors of the respective coordinate system. The base vectors of any cartesian coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_x= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_y= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the cartesian coordinate vector for both cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{x}}&= x\\hat{\\boldsymbol{\\mathbf{e}}}_x+ y\\hat{\\boldsymbol{\\mathbf{e}}}_y+ z\\hat{\\boldsymbol{\\mathbf{e}}}_z\\nonumber \\\\\n    &= \\left(r\\cos\\vartheta\\cos\\varphi\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\left(r\\sin\\vartheta\\cos\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\left(r\\sin\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\boldsymbol{\\mathbf{x}}_s.\n\\end{align}\\] Similarly, the base vectors of any spherical coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_r= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the spherical coordinate vector for both cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{r}}&= r\\hat{\\boldsymbol{\\mathbf{e}}}_r+ \\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ \\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\nonumber \\\\\n    &= \\left(\\sqrt{x^2 + y^2 + z^2}\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_r\\nonumber \\\\\n    &+ \\left(\\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta\\nonumber \\\\\n    &+ \\left(\\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\\\\n    &= \\boldsymbol{\\mathbf{r}}_c.\\nonumber\n\\end{align}\\]\nDue to the equalities of the vectors in their respective same coordinate system, the rest of this work will only use \\(\\boldsymbol{\\mathbf{x}}\\) and \\(\\boldsymbol{\\mathbf{r}}\\) without their indexed counterparts. The element type will be indicated by the context of the equation.\n\n\nSpacial Differentials\nThis work regularly relies on vector calculus, including substantial use of differentials and derivatives. The former uses two kinds of notations, depending on the use case of the differential. First, mathematical differentials of vectors are the vectorized form of the differentials of the vector components. In the following, the differentials will be set up for stationary conditions with constant base vectors, i.e.\n\\[\\begin{align}\n    \\frac{\\partial}{\\partial t} &= 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial r} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\varphi} = 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial x} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial z} = 0.\n\\end{align}\\]\nFor example, the differential of a stationary cartesian coordinate vector and cartesian elements is\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{x}}= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial z}dz= dx\\hat{\\boldsymbol{\\mathbf{e}}}_x+ dy\\hat{\\boldsymbol{\\mathbf{e}}}_y+ dz\\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix} dx\\\\ dy\\\\ dz\\end{bmatrix},\n\\end{equation}\\]\nand for spherical coordinates and elements\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\varphi}d\\varphi= dr\\hat{\\boldsymbol{\\mathbf{e}}}_r+ d\\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ d\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}.\n\\end{equation}\\]\nThe above total differentials are relatively simple to set up since their partial differentials cancel out to only contain one variable each. However, the differentials for the cartesian vector in spherical elements and the spherical vector in cartesian elements are more complicated, with the former differential given by\n\\[\\begin{align}\n    d\\boldsymbol{\\mathbf{x}}&= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\varphi}d\\varphi\\\\\n    &= \\left(\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) dr\\nonumber \\\\\n    &+ \\left(-r\\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ r\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y\\right) d\\vartheta\\nonumber \\\\\n    &+ \\left(-r\\cos\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x- r\\sin\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ r\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) d\\varphi\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi&  -r\\sin\\vartheta\\cos\\varphi& -r\\cos\\vartheta\\sin\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi& r\\cos\\vartheta\\cos\\varphi& - r\\sin\\vartheta\\sin\\varphi\\\\\n        \\sin\\varphi& 0 & r\\cos\\varphi\n    \\end{bmatrix} \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}  \\label{eq:total_cartesian_spherical_differential_matrix}\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi dr-r\\sin\\vartheta\\cos\\varphi d\\vartheta-r\\cos\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi dr+ r\\cos\\vartheta\\cos\\varphi d\\vartheta- r\\sin\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\varphi dr+ r\\cos\\varphi d\\varphi\n    \\end{bmatrix}. \\label{eq:total_cartesian_spherical_differential}\n\\end{align}\\]\nThe resulting vector in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential}\\) contains the scalar differentials of the spherical elements in each of its entries, which can also be pulled out of the vector and written as a linear combination using a matrix notation, shown in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\). While the differential of a spherical vector in cartesian elements can be calculated in the same way, which is \\(d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial z}dz\\), its trigonometric functions and subsequent differentiations make it less common and inefficient to use, which is why it is not shown here for brevity.\nThese vectorized total differentials are regularly used in vector calculus. A prime example is calculating the gradient \\(\\nabla\\) of a scalar function \\(f\\), which is given by \\[\\begin{equation}\n    \\frac{df}{d\\boldsymbol{\\mathbf{x}}} = \\nabla f = \\begin{bmatrix}\n        \\frac{\\partial f}{\\partial x} \\\\\n        \\frac{\\partial f}{\\partial y} \\\\\n        \\frac{\\partial f}{\\partial z}\n    \\end{bmatrix},\n\\end{equation}\\] as an example in a cartesian coordinate system and with cartesian elements. Many problems feature the second-order derivatives of a scalar function, which is called the Laplacian \\(\\nabla^2\\) and is given by \\[\\begin{equation}\n    \\nabla \\cdot \\nabla f = \\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}.\n\\end{equation}\\]\nBoth the gradient and the laplacian can also be expressed in spherical coordinates. The former makes use of the chain rule of differentiation, which evaluates to the inverse matrix of the coordinate projection of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\): \\[\\begin{align}\n    \\begin{bmatrix}\n        \\frac{\\partial}{\\partial x} \\\\\n        \\frac{\\partial}{\\partial y} \\\\\n        \\frac{\\partial}{\\partial z}\n    \\end{bmatrix} &= \\begin{bmatrix}\n        \\frac{\\partial r}{\\partial x} & \\frac{\\partial\\vartheta}{\\partial x} & \\frac{\\partial\\varphi}{\\partial x} \\\\\n        \\frac{\\partial r}{\\partial y} & \\frac{\\partial\\vartheta}{\\partial y} & \\frac{\\partial\\varphi}{\\partial y} \\\\\n        \\frac{\\partial r}{\\partial z} & \\frac{\\partial\\vartheta}{\\partial z} & \\frac{\\partial\\varphi}{\\partial z}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix} \\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi& -\\frac{\\sin\\vartheta}{r\\cos\\varphi} & -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\vartheta\\cos\\varphi& \\frac{\\cos\\vartheta}{r\\cos\\varphi} & -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\varphi& 0 & \\frac{\\cos\\varphi}{r}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial x} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_x}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial y} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_y}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial z} &= \\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}. \\label{eq:spherical_gradient_z}\n\\end{align}\\] The latter can be derived by applying the chain rule twice, which is a tedious but straightforward calculation, leading to: \\[\\begin{align}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right). \\label{eq:laplace_spherical}\n\\end{align}\\]\n\n\n\n\n\n\nDerivation of spherical Laplace operator.\n\n\n\nThe laplacian is the linear summation of the second-order cartesian partial derivative \\(\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\). The spherical laplacian can be derived by applying the chain rule of partial derivatives, shown in the gradient derivation in Eqs. \\(\\eqref{eq:spherical_gradient_x}\\), \\(\\eqref{eq:spherical_gradient_y}\\), \\(\\eqref{eq:spherical_gradient_z}\\) twice: \\[\\begin{align*}\n    \\frac{\\partial^2}{\\partial x^2} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial x} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial x} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial x} \\\\\n    &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\right) \\\\\n    &- \\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial y^2} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial y} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial y} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial y} \\\\\n    &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &+ \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial z^2} &= \\sin\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial z} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial z} \\\\\n    &= \\sin\\varphi\\frac{\\partial}{\\partial r} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right).\n\\end{align*}\\] Evaluating all partial derivatives and summing up all terms leads to a miraculous cancellation of terms, finally arriving at the following expression of Eq. \\(\\eqref{eq:laplace_spherical}\\) for the Laplacian in spherical coordinates: \\[\\begin{align*}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right).\n\\end{align*}\\]\n\n\nAnother example of the use of differentials is in integration, where it is used to represent an infinitesimal change in the variable. Shorthand versions of multi-dimensional integrals are often written using vector variables, such as \\[\\begin{equation}\n    \\int_X \\int_Y \\int_Z f dzdydx= \\int_Vf d^3\\boldsymbol{\\mathbf{x}},\n\\end{equation}\\] where \\(V\\) is the volume of the integration domain, with the infinitesimal volume element \\(d^3\\boldsymbol{\\mathbf{x}}\\in V= \\left\\{dx\\, dy\\, dz\\; | \\; dx\\in X, dy\\in Y, dz\\in Z \\right\\}\\). The superscript \\(\\bullet^3\\) in the differentials indicates that the differential is a vector but a scalar representation of the element’s size created by the vector elements. As before, the differential \\(d^3\\boldsymbol{\\mathbf{x}}\\) can also be expressed in spherical elements by using the Jacobian determinant, which is equal to the matrix of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\), of the transformation: \\[\\begin{equation}\n    d^3\\boldsymbol{\\mathbf{x}}= \\left|\\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\boldsymbol{\\mathbf{r}}}\\right| d^3\\boldsymbol{\\mathbf{r}}= r^2\\cos\\varphi drd\\vartheta d\\varphi.\n\\end{equation}\\] Figure 1 illustrates the spherical differential element \\(d^3\\boldsymbol{\\mathbf{r}}\\) in a three-dimensional cartesian coordinate system. The azimuth angle \\(\\vartheta\\) rotates inside of the \\(x\\)–\\(y\\) plane, while the elevation angle \\(\\varphi\\) rotates the vector out of that plane in \\(z\\) direction. While the azimuth arc decreases with the sine of the elevation angle, the small angle approximation can be used to approximate the differential element as a cuboid with the volume \\(d^3\\boldsymbol{\\mathbf{r}}\\approx r^2 \\sin\\varphi\\, drd\\vartheta d\\varphi\\).\n\n Figure LaTeX\n\n\n\n\n\nFigure 1: Three-dimensional sketch of a spherical differential element in a cartesian coordinate system.\n\n\n\n\n% based on: https://tikz.net/spherical_volume/\n\n%Axis Angles\n\\tdplotsetmaincoords{70}{110}\n\n%Macros\n\\pgfmathsetmacro{\\rvec}{6}\n\\pgfmathsetmacro{\\elevationvec}{40}\n\\pgfmathsetmacro{\\azimuthvec}{45}\n\n\\pgfmathsetmacro{\\dazimuthvec}{20}\n\\pgfmathsetmacro{\\delevationvec}{20}\n\\pgfmathsetmacro{\\drvec}{1.5}\n\n%Layers\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\pgfsetlayers{background, main, foreground}\n\n\\begin{tikzpicture}[tdplot_main_coords]\n    \n    %Coordinates\n    \\coordinate (O) at (0,0,0);\n    %\n    \\tdplotsetcoord{A}{\\rvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{B}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{C}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{D}{\\rvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    %\n    \\tdplotsetcoord{E}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F'}{\\rvec + \\drvec}{90}{\\azimuthvec}\n    \\tdplotsetcoord{G}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{G'}{\\rvec + \\drvec}{90}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{H}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    \n    %Axis\n    \\begin{pgfonlayer}{background}\n        \\draw[thick,-latex] (0,0,0) -- (7,0,0) node[pos=1.1]{$\\cartesianCoordinateX$};\n        \\draw[thick,-latex] (0,0,0) -- (0,7,0) node[pos=1.05]{$\\cartesianCoordinateY$};\n        \\draw[thick,-latex] (0,0,0) -- (0,0,6) node[pos=1.05]{$\\cartesianCoordinateZ$};\n    \\end{pgfonlayer}\n    \n    %Help Lines\n    \\begin{pgfonlayer}{background}\n        %Up\n        \\draw[thick, black] (O) -- (A) node[pos=0.6, above left, black] {$\\sphericalCoordinateRadius$};\n        \\draw (O) -- (B);\n        \\draw (O) -- (C);\n        \\draw[dashed] (O) -- (D);\n        %Down\n        \\draw (O) -- (F');\n        \\draw (O) -- (G');\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        %%Help Curves\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotsetthetaplanecoords{\\azimuthvec+\\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, dashed]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        %\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n        \\node[rotate=13] at (3,4.45,0) {$\\sphericalCoordinateRadius\\sin\\sphericalCoordinateElevation d\\sphericalCoordinateAzimuth$};\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec+\\drvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n    \\end{pgfonlayer}\n    \n    \n    %Angles\n    \\begin{pgfonlayer}{foreground}\n        %Phi, dPhi\n        \\tdplotdrawarc[-stealth]{(O)}{0.9}{0}{\\azimuthvec}{anchor=north}{$\\sphericalCoordinateAzimuth$}\n        \\tdplotdrawarc[-stealth]{(O)}{1.5}{\\azimuthvec}{\\azimuthvec + \\dazimuthvec}{}{}\n        \\node at (1.4,1.9,0) {$ d\\sphericalCoordinateAzimuth$};\n        \n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \n        %Theta, dTheta\n        \\tdplotdrawarc[tdplot_rotated_coords, -stealth]{(0,0,0)}{1.2}{90}{\\elevationvec + \\delevationvec}{}{}\n        %\\node at (0,0.3,1.3) {$\\sphericalCoordinateElevation$};\n        \\node at (1,1.25,0.55) {$\\sphericalCoordinateElevation$};\n        \\tdplotdrawarc[tdplot_rotated_coords, stealth-]{(0,0,0)}{2.}{\\elevationvec}{\\elevationvec + \\delevationvec}{anchor=south west}{$ d\\sphericalCoordinateElevation$}\n    \\end{pgfonlayer}\n    \n    %Differential Volume\n    \n    %%Lines\n    \\begin{pgfonlayer}{foreground}\n        \\draw[thick] (A) -- (E) node[midway, above left]{$ d\\sphericalCoordinateRadius$};\n        \\draw[thick] (B) -- (F);\n        \\draw[thick] (C) -- (G);\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        \\draw[dashed, thick] (D) -- (H);\n    \\end{pgfonlayer}\n    \n    \n    %%Curved\n    \\begin{pgfonlayer}{background}\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{below left}{$\\sphericalCoordinateRadius d\\sphericalCoordinateElevation$}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-30.3813}{-8.6492}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{17.2983}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{17.2983}{}{}\n    \\end{pgfonlayer}\n    \n    %Fill Color\n    \\begin{pgfonlayer}{main}\n        %Front\n        \\fill[black, opacity=0.15] (E) to (A)  to[bend left=4] (B) to (F) to[bend right=4] cycle;\n        \\fill[black, opacity=0.6] (E) to[bend left=4] (F)  to[bend left=2] (G) to[bend right=6.5] (H) to[bend right=4] cycle;\n        \\fill[black, opacity=0.4] (F) to[bend left=2] (G) to[bend left=1.5] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        %Back\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to[bend left=6] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to (H) to[bend right=2.5] (E) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (D) to (H) to[bend left=6] (G) to[bend right=2] (C) to[bend right=6] cycle;\n    \\end{pgfonlayer}\n        \n\\end{tikzpicture}\n\n\n\n\n\nTemporal Differentials\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/surface_interaction/physical_chemistry.html",
    "href": "documentation/surface_interaction/physical_chemistry.html",
    "title": "6.1 Physical Chemistry",
    "section": "",
    "text": "From Schörghofer (2023):\n\nAdsorption is a surface phenomenon.\nθ denotes the number of adsorbed particles per area.\nFor water ice, the number of molecules in a monolayer can be calculated from the density and molecular mass as θm = 10^19 molecules m^-2, i.e., 10 H2O molecules per nm^2.\nThe areal concentration of Si atoms in silica (SiO2) is nearly as high when calculated in the same manner (nine Si atoms per nm^2 for α-quartz, but not all nine atoms have the same distance from the surface).\n\nPolanyi-Wigner equation: (Schörghofer, 2023) \\[\\begin{equation}\n    \\frac{d\\theta}{dt} = - \\nu\\theta\\exp\\left(-\\frac{E_a}{k_BT}\\right)\n\\end{equation}\\] which describes a first-order process.\nPre-exponential factor \\(\\nu\\) for monolayer adsorbates usually in the order of \\(10^{\\mathrm{-13}}\\,\\mathrm{s^{\\mathrm{-1}}}\\) for atoms (close to their respective oscillation frequency), can be much higher for molecules (Minissale et al., 2023).\n\n\n\n\n\n\nDefinition: Monolayer\n\n\n\nA monolayer of particles refers to a single layer of adsorbed molecules or atoms on a surface. This term is essential in understanding the capacity and behavior of a surface to adsorb volatile substances. Specifically, for water ice, the number of molecules in a monolayer can be calculated from the density and molecular mass as \\(\\theta_m = 10^{\\mathrm{19}}\\,\\mathrm{m^{\\mathrm{-2}}}\\), or, \\(10\\,\\mathrm{nm^{\\mathrm{-2}}}\\). (Schörghofer, 2023)\n\n\n\n\n\n\nReferences\n\nMinissale, M., Aikawa, Y., Bergin, E., Bertin, M., Brown, W. A., Cazaux, S., Charnley, S. B., Coutens, A., Cuppen, H. M., Guzman, V., Linnartz, H., McCoustra, M. R. S., Rimola, A., Schrauwen, J. G. M., Toubin, C., Ugliengo, P., Watanabe, N., Wakelam, V., & Dulieu, F. (2023). Thermal Desorption of Interstellar Ices: A Review on the Controlling Parameters and Their Implications from Snowlines to Chemical Complexity. ACS Earth and Space Chemistry, 6(3), 597–630. https://doi.org/10.1021/acsearthspacechem.1c00357\n\n\nSchörghofer, N. (2023). Adsorption Kinetics of Water and Argon on Lunar Grains. The Planetary Science Journal, 4(9), 164. https://doi.org/10.3847/psj/acf19b\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/acronyms.html",
    "href": "documentation/acronyms.html",
    "title": "Acronyms",
    "section": "",
    "text": "Acronyms\n\n\n Table \\(\\LaTeX\\)\n\n\n\n\n\n\n\n\n\n\nALSEP\nApollo Lunar Surface Experiments Package\n\n\ncdf\nCME\ncumulative distribution function\nCoronal Mass Ejection\n\n\nDLRE\nDiviner Lunar Radiometer Experiment\n\n\nENA\nESA\nESD\nEnergetic Neutral Atoms\nEuropean Space Agency\nElectron Stimulated Desorption\n\n\nLACE\nLADEE\nLRO\nLROC\nLunar Atmospheric Composition Experiment\nLunar Atmosphere and Dust Environment Explorer\nLunar Reconnaissance Orbiter\nLunar Reconnaissance Orbiter Camera\n\n\nHEALPix\nHierarchical Equal Area iso-Latitude Pixelization\n\n\nIID\nIMF\nIndependent and Identically Distributed\nInterplanetary Magnetic Field\n\n\nMBD\nMBFD\nMESSENGER\nMMIV\nMaxwell-Boltzmann Distribution\nMaxwell-Boltzmann Flux Distribution\nMErcury Surface, Space ENvironment, GEochemistry, and Ranging\nMicrometeoroid Impact Vaporization\n\n\nNASA\nNMS\nNational Aeronautics and Space Administration\nNeutral Mass Spectrometer\n\n\npdf\nPDS\nPSD\nPSR\nprobability density function\nPlanetary Data System\nPhoton Stimulated Desorption\nPermanently Shadowed Region\n\n\nrms\nroot mean squared\n\n\nSSE\nSelenocentric Solar Ecliptic\n\n\nTPD\nTUM\nTemperature Program Desorption\nTechnical University of Munich\n\n\nUVS\nUltraviolet Spectrometer (Apollo 17)\n\n\nWAC\nWide Angle Camera (LROC)\n\n\n\n\n\n\\newacronym{ALSEP}{ALSEP}{Apollo Lunar Surface Experiments Package}\n\n\\newacronym{cdf}{cdf}{cumulative distribution function}\n\\newacronym{CME}{CME}{Coronal Mass Ejection}\n\n\\newacronym{DLRE}{DLRE}{Diviner Lunar Radiometer Experiment}\n\n\\newacronym{ENA}{ENA}{Energetic Neutral Atoms}\n\\newacronym{ESA}{ESA}{European Space Agency}\n\\newacronym{ESD}{ESD}{Electron Stimulated Desorption}\n\n\\newacronym{LACE}{LACE}{Lunar Atmospheric Composition Experiment}\n\\newacronym{LADEE}{LADEE}{Lunar Atmosphere and Dust Environment Explorer}\n\\newacronym{LRO}{LRO}{Lunar Reconnaissance Orbiter}\n\\newacronym{LROC}{LROC}{Lunar Reconnaissance Orbiter Camera}\n\n\\newacronym{HEALPix}{HEALPix}{Hierarchical Equal Area iso-Latitude Pixelization}\n\n\\newacronym{IID}{IID}{Independent and Identically Distributed}\n\\newacronym{IMF}{IMF}{Interplanetary Magnetic Field}\n\n\\newacronym{MBD}{MBD}{Maxwell-Boltzmann Distribution}\n\\newacronym{MBFD}{MBFD}{Maxwell-Boltzmann Flux Distribution}\n\\newacronym{MESSENGER}{MESSENGER}{MErcury Surface, Space ENvironment, GEochemistry, and Ranging}\n\\newacronym{MMIV}{MMIV}{Micrometeoroid Impact Vaporization}\n\n\\newacronym{NASA}{NASA}{National Aeronautis and Space Administration}\n\\newacronym{NMS}{NMS}{Neutral Mass Spectrometer}\n\n\\newacronym{pdf}{pdf}{probability density function}\n\\newacronym{PDS}{PDS}{Planetary Data System}\n\\newacronym{PSD}{PSD}{Photon Stimulated Desorption}\n\\newacronym{PSR}{PSR}{Permanently Shadowed Region}\n\n\\newacronym{rms}{rms}{root mean squared}\n\n\\newacronym{SSE}{SSE}{Selenocentric Solar Ecliptic}\n\n\\newacronym{TUM}{TUM}{Technical University of Munich}\n\n\\newacronym{UVS}{UVS}{Ultraviolet Spectrometer}\n\n\\newacronym{WAC}{WAC}{Wide Angle Camera}"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-distribution",
    "href": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-distribution",
    "title": "3.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Distribution",
    "text": "Maxwell-Boltzmann Distribution\nThe MBD (Maxwell-Boltzmann velocity distribution) is a probability distribution function that describes the distribution of velocities and speeds of particles in a gas or liquid. It is intimately connected to the kinetic gas theory, which explains the behavior of gases in terms of the motion of their constituent particles, which is proportional to their temperature.\n\n\n MaxwellBoltzmannVelocityDistribution\nThe one-dimensional pdf of the MBD, given for a velocity in the direction \\(x\\), is \\[\\begin{equation}\n   f(v_x)dv_x = \\sqrt{\\frac{m}{2\\pi k_BT}} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x\n   \\label{eq:mbd_1d}\n\\end{equation}\\] with the mass \\(m\\) and available thermodynamic temperature \\(T\\) of the particle, and the Boltzmann constant \\(k_B\\), properly normalized so that \\(\\int_{-\\infty}^\\infty f(v_x)dv_x = 1\\). Note that this distribution is identical to a Gaussian distribution with zero mean and variance of \\(k_BT/ m\\) (Crider & Vondrak, 2002; Smolka, 2022).\nOne can extend the distribution to three cartesian dimensions, with the velocity vector \\(\\boldsymbol{\\mathbf{v}}= \\left[v_x, v_y, v_z\\right]^T\\) and \\(d^3\\boldsymbol{\\mathbf{v}}= dv_xdv_ydv_z\\), by linearly combining all three pdf given in Eq. \\(\\eqref{eq:mbd_1d}\\) \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbd_3d}\n\\end{equation}\\] with the speed \\(v=\\sqrt{\\boldsymbol{\\mathbf{v}}^T\\boldsymbol{\\mathbf{v}}}\\). Identical to the one-dimensional form of the distribution, the three-dimensional one is based on a symmetric Gaussian distribution with zero mean. In order to convert it into a distribution of speeds, Eq. \\(\\eqref{eq:mbd_3d}\\) can be integrated twice over arbitrary solid angles, utilizing its symmetry. For this, the differential will be expressed in spherical coordinates \\(\\boldsymbol{\\mathbf{v}}\\left(v, \\vartheta, \\varphi\\right) = \\left[ v\\cos\\vartheta\\cos\\varphi,\\, v\\sin\\vartheta\\cos\\varphi,\\, v\\sin\\varphi\\right]^T\\), leading to the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) with \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\), which results in \\[\\begin{equation}\n    f(v)dv= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv. \\label{eq:mbd_speed_3d}\n\\end{equation}\\]\n\n\n cdf: integrated Eq. \\(\\eqref{eq:mbd_speed_3d}\\)   pdf: Eq. \\(\\eqref{eq:mbd_speed_3d}\\)\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann velocity distribution.\n\n\n\nEquation \\(\\eqref{eq:mbd_3d}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n        f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n        &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_{-\\infty}^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\quad\\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\;\\quad f(\\varphi) \\, d\\varphi\\quad\\cdot && \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} &\\cdot& \\quad \\overbrace{\\frac{1}{2}\\cos\\varphi\\; d\\varphi} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{0}^\\infty f(v) dv= \\int_{-\\pi/2}^{\\pi/2} f(\\varphi) d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\, d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional as well as their components are normalized.\n\n\n\n\n\n Figure Julia Downloads\n\n\n\n\n\nFigure 1: Normalized Maxwell-Boltzmann velocity and speed distributions according to Eqs. \\(\\eqref{eq:mbd_1d}\\), \\(\\eqref{eq:mbd_speed_3d}\\). For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbd_most_probable_speed}\\), \\(\\eqref{eq:mbd_mean_speed}\\), \\(\\eqref{eq:mbd_rms}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \nfunction mbd(name=\"mbd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbd1d  = sqrt(1/2/pi) .* exp.(-x1.^2 ./ 2)\n    mbd3d  = 4*pi*(1/2/pi)^1.5 .* x2.^2 .* exp.(-x2.^2 ./ 2)\n    mbd1d2 = 2*sqrt(1/2/pi) .* exp.(-x2.^2 ./ 2)\n\n    # plot distributions\n    lines!(ax, x1, mbd1d; color=TUMBlueDark)\n    lines!(ax, x2, mbd1d2; color=TUMBlueLight)\n    lines!(ax, x2, mbd3d; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(2);            fvp = 4*pi*(1/2/pi)^1.5*vp^2*exp(-vp^2/2)\n    vmean = 2/sqrt(pi) * vp; fvmean = 4*pi*(1/2/pi)^1.5*vmean^2*exp(-vmean^2/2)\n    vrms = sqrt(1.5) * vp;   fvrms = 4*pi*(1/2/pi)^1.5*vrms^2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*1.1, fvrms*1.01; text=\"root mean squared\", align=ALGN, fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBD\", \"1D-MBD, one-directional\", \"3D-MBD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbd.pdf   mbd.svg   mbd.png \n\n\n\n\n\nFigure 1 shows three normalized MBDs, using the mass \\(m\\) and temperature \\(T\\) for the normalization. The one-dimensional distribution (1D-MBD) according to Eq. \\(\\eqref{eq:mbd_1d}\\) shows the symmetric normal distribution, as the normalization \\(\\sqrt{m/ (k_BT)} = 1\\,\\mathrm{s/m}\\) leads to a Gaussian distribution with zero mean and unit variance. The second one-dimensional distribution (1D-MBD, one-directional) is showing the same equation but in its one-directional form, leading to only positive velocities. Mathematically, this operation changes the integration boundaries for the elevation angle \\(\\varphi\\) to \\(\\left(0, \\pi/2\\right)\\), which in turn leads to a doubling of the prefactor to assure pdf normalization: \\[\\begin{equation}\n    f_+(v_x)dv_x = \\begin{cases}\n        2 \\cdot f(v_x) dv_x, & \\quad v_x \\geq 0\\,\\mathrm{m/s}, \\\\\n        0, & \\quad \\text{else.}\n    \\end{cases}\n    \\label{eq:mbd_1d+}\n\\end{equation}\\] These one-directional forms of the MBD are helpful for velocities where one direction is obstructed, for example when launching particles from a surface, where a movement downwards into the ground is not physical. The third distribution (3D-MBD, speed) is presenting the graph of Eq. \\(\\eqref{eq:mbd_speed_3d}\\). Note that, as with the graph before, this distribution is also one-directional, though in this case, it is by nature, since the speed in the spherical coordinate system description can only assume a positive value. Additionally, the speed distribution has three indicated and typical speeds shown, which will be explained in the following.\n\nTypical Speeds\nOne of those typical speeds obtained from properties of the MBD is the most probable speed, \\(v_p\\), which describes the speed at which Eq. \\(\\eqref{eq:mbd_speed_3d}\\) reaches its maximum value. Since the pdf is normalized, we can infer that it must have at least one global extreme point at which its derivative equals zero: \\[\\begin{equation}\n   \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad\\Rightarrow\\qquad v_p = \\sqrt{\\frac{2k_BT}{m}}.\n    \\label{eq:mbd_most_probable_speed}\n\\end{equation}\\]\nAnother typical value that can be drawn from a distribution is the mean speed \\(\\langle v \\rangle\\), being the ensemble expectation according to Eq. \\(\\eqref{eq:ensemble_average}\\). For the speed distribution, the expected value can be calculated by the speed-weighted average of the distribution: \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty v\\; f(v) \\; dv= \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n    \\label{eq:mbd_mean_speed}\n\\end{equation}\\] Note that the expected speed \\(\\langle v \\rangle\\) of the distribution is not equal to the median \\(m\\) of the distribution, for which the expression \\(\\int_0^m f(v) dv\\) evaluates to .\nLastly and similar to the mean speed, the mean square speed \\(\\langle v^2 \\rangle\\) is an important value describing the distribution. As the second-order raw moment, it corresponds to the average kinetic energy of a particle and can be translated into the root mean squared speed \\(v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle}\\): \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n    \\label{eq:mbd_rms}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} = \\frac{d}{dv} \\left[ \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) \\right]_{v_p} &= 0 \\\\\n    %\\Rightarrow\\quad &&\\; \\frac{d}{d\\velocity} \\Big[ \\velocity^2 \\cdot \\exp\\left( -a\\velocity^2\\right) \\Big]_{\\velocity_p} &= 0  \\\\\n     \\Rightarrow\\quad &&\\; 2v_p \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^3 \\cdot \\exp\\left( -av_p^2 \\right) &= 0  \\\\\n     \\Rightarrow\\quad &&\\; v_p = \\sqrt{\\frac{1}{a}} &= \\sqrt{\\frac{2k_BT}{m}}\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\): \\[\\begin{align*}\n    \\langle v \\rangle &= \\int_0^\\infty v\\; f(v) \\; dv= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\int_0^\\infty v^3 \\cdot \\exp\\left( - a v^2 \\right)dv\\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ - \\frac{\\left(av^2 + 1\\right) \\cdot \\exp\\left(-av^2\\right)}{2a^2} \\right]_0^\\infty \\\\\n    %\\Rightarrow \\quad \\meanof{\\velocity} &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[\\frac{1}{2a^2} \\right] \\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= \\sqrt{\\frac{4}{\\pi a}} = \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbd_rms}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function: \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}\\cdot\\mathop{\\mathrm{erf}}{\\left(\\sqrt{a}v\\right)}}{8a^{5/2}} - \\frac{v\\exp\\left(-av^2\\right)\\cdot\\left(2av^2+3\\right)}{4a^2} \\right]_0^\\infty \\right)^{1/2}  \\\\\n    %\\Rightarrow\\quad \\velocity_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}}{8a^{5/2}} \\right]\\right)^{1/2}  \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\sqrt{\\frac{3}{2a}} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 1: Overview of normalized speeds \\(v\\) of the MBD, according to Eq. \\(\\eqref{eq:mbd_speed_3d}\\), including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(v_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(v_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = sqrt(1/2/pi)^3 * 4 * pi * v^2 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(2)\n    vm = sqrt(8/pi)\n    vr = sqrt(3)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\",\"\",\"\",raw\"$\\approx\\sqrt{4/\\pi}$\",raw\"$\\approx\\sqrt{3/2}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{\\pi/4}$\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\",raw\"$\\approx\\sqrt{2/3}$\",\"\",raw\"$\\approx\\sqrt{8/3\\pi}$\",\"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n    \n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbd_typical_speeds.md\", \"w\")\n    write(fid, maketable(), \"\\\\\\\\\"=&gt;\"\\\\\")\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\n\n\nNumrical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBD velocity, then any realization of \\(\\boldsymbol{\\mathbf{V}}\\) can be drawn from the respective pdf, in this case Eq. \\(\\eqref{eq:mbd_3d}\\), \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) =  \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right).\n\\end{equation}\\] Numerically speaking, to draw any realization from a randomly distributed variable, the latter has to be mapped on to one implemented state space, which in the most basic cases is a uniform distribution with the random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u \\sim f(r_u) = 1\\) and a normal distribution with the random variable \\(R_n\\in\\left(-\\infty,\\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n |\\mu,\\sigma^2\\right)\\) with zero mean and unit variance. Since \\(\\boldsymbol{\\mathbf{V}}\\) is three-dimensional, each individual dimension requires its own mapping. In its cartesian form, \\(\\boldsymbol{\\mathbf{V}}=\\left(V_x, V_y, V_z\\right)\\), all three components are equal to a scaled normal distrinbution, which can be used directly as \\[\\begin{alignat}{3}\n    V_i &= R_n \\cdot \\sqrt{\\frac{k_BT}{m}} \\; \\sim \\; \\mathcal{N} \\left(v_i \\Big| 0, \\frac{k_BT}{m}\\right) \\qquad && \\forall i \\in \\{x, y, z\\} \\label{eq:mbd_random_cartesian_component_2} \\\\\n    \\Rightarrow\\qquad v_i &= r_n \\cdot \\sqrt{\\frac{k_BT}{m}} \\qquad &&\\forall i \\in \\{x,y,z\\}.\n    \\label{eq:mbd_random_cartesian_component}\n\\end{alignat}\\] Should one dimension be one-directional, the absolute value \\(|r_n|\\) can be used iun Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\) instead.\nThe random variable \\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in its spherical form, with its three components the speed \\(V_v\\in \\left[0,\\infty\\right)\\) with realization \\(v\\) of \\(V_v\\sim f(v)\\), the elevation angle \\(V_\\varphi\\in \\left[-\\pi/2, \\pi/2\\right]\\) with realization \\(\\varphi\\) of \\(V_\\varphi\\sim f(\\varphi) = 1/2 \\cdot \\cos\\varphi\\), and the azimuth angle \\(V_\\vartheta\\in \\left[-\\pi,\\pi\\right)\\) with realization \\(\\vartheta\\) of \\(V_\\vartheta\\sim f(\\vartheta) = 1/2\\pi\\). Similar to the cartesian description above, these three random variables can be mathed to one of the numerically implemented distributions. Because all three pdfs of the random variables are normalized, their cdf can be set equal to the cdf of the uniform unit distribution \\(R_u \\sim f(r_u) = 1\\): \\[\\begin{alignat}{4}\n    r_v&= \\int_0^{r_v} f(r_u)dr_u &&= \\int_0^{v} f(\\tilde v) d\\tilde v\\label{eq:mbd_speed_random}\\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u)dr_u &&= \\int_{-\\pi/2}^{\\varphi} f(\\tilde\\varphi) d\\tilde\\varphi&&= \\frac{1}{2}\\left(\\sin\\varphi+ 1\\right) \\label{eq:mbd_elevation_random}\\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u)dr_u &&= \\int_{-\\pi}^{\\vartheta} f(\\tilde\\vartheta) d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}, \\label{eq:mbd_azimuth_random}\n\\end{alignat}\\] where the speed distribution is equal to Eq. \\(\\eqref{eq:mbd_speed_3d}\\). With the latter two integrals being trivial, the speed integral of Eq. \\(\\eqref{eq:mbd_speed_random}\\) evaluates to: \\[\\begin{equation}\n   r_v= \\mathop{\\mathrm{erf}}\\left( \\sqrt{\\frac{mv^2}{2k_BT}} \\right) - \\frac{2}{\\sqrt{\\pi}} \\cdot \\sqrt{\\frac{mv^2}{2k_BT}} \\cdot \\exp\\left( - \\frac{mv^2}{2k_BT}\\right).\n   \\label{eq:mbd_speed_random_evaluated}\n\\end{equation}\\] Due to the combination of the Gaussian error function \\(\\mathop{\\mathrm{erf}}\\) and an exponential function \\(\\exp\\), there is no elementary analytical expression of \\(v\\) as a function of \\(r_v\\). Thus, for numerical implementations Eq. \\(\\eqref{eq:mbd_speed_random_evaluated}\\) is usually pre-evaluated several times to build up an interpolation table that maps any uniform random \\(r_v\\) to a speific MBD speed. The other two components, see Eqs. \\(\\eqref{eq:mbd_elevation_random}\\), \\(\\eqref{eq:mbd_azimuth_random}\\), show that the elevation angle \\(\\varphi\\) is \\(\\sin\\)-distributed, while the azimuth angle \\(\\vartheta\\) is uniformly distributed.\n\n\n sample: Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\)"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "href": "documentation/drivers/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "title": "3.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Flux Distribution",
    "text": "Maxwell-Boltzmann Flux Distribution\nThe MBFD (Maxwell-Boltzmann flux velocity distribution) is a modified three-dimensional MBD, which is based on the upwards flux governed by the upwards velocity component. It is calculated by multiplying Eq. \\(\\eqref{eq:mbd_3d}\\) by this additional velocity component and re-normalizing the pdf (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022). Let \\(n\\) be a velocity-independent normalization factor, and \\(v_z &gt; 0\\) the upwards velocity component, then the three-dimensional form of the MBFD can be written as \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= n \\cdot \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbfd_raw}\n\\end{equation}\\]\n\n\n MaxwellBoltzmannFluxVelocityDistribution\nTo calculate the normalization factor \\(n\\), the flux distribution can be integrated over spherical coordinates and set to unity, with the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) and domains \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\). After solving the three-dimensional integral, the normalization factor can be derived to \\[\\begin{equation}\n     n = 2\\pi\\sqrt{\\frac{m}{2\\pi k_BT}},\n    \\label{eq:mbfd_normalization_factor}\n\\end{equation}\\] which can be included in the original description of the MBFD, given in Eq. \\(\\eqref{eq:mbfd_raw}\\), leading to \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd}\n\\end{equation}\\] in cartesian coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x \\, dv_y \\, dv_z\\), or \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v\\sin\\varphi\\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd_spherical}\n\\end{equation}\\] in spherical coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\varphi\\, d\\vartheta\\) (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022; Smith et al., 1978).\n\n\n cdf: integrated Eq. \\(\\eqref{eq:mbfd_speed}\\)   pdf: Eq. \\(\\eqref{eq:mbfd_speed}\\)\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann Flux velocity distribution.\n\n\n\nEquations \\(\\eqref{eq:mbfd}\\) and \\(\\eqref{eq:mbfd_spherical}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{2\\pi v_z \\left(\\frac{m}{2\\pi k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_0^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\quad f(\\varphi) \\, d\\varphi&\\cdot& \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{2\\cdot\\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} \\; &\\cdot& \\quad \\overbrace{2\\sin\\varphi\\cos\\varphi\\; d\\varphi\\phantom{\\frac{1}{1}}} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_0^\\infty f(v) dv= \\int_0^{\\pi/2} f(\\varphi) \\;d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\; d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional pdfs as well as their components are normalized.\n\n\n\nThrough integration over the solid angles of Eq. \\(\\eqref{eq:mbfd_spherical}\\), the MBFD speed distribution emerges as \\[\\begin{equation}\n    f(v)dv=  2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_speed}\n\\end{equation}\\] Note that the scaling factor \\(2\\) is a result from the integration over half the sphere through \\(\\varphi\\in\\left(0,\\pi/2\\right)\\). As before, this speed distribution can be analyzed to extract typical speeds.\n\n\n Figure Julia Downloads\n\n\n\n\n\nFigure 2: Normalized Maxwell-Boltzmann flux velocity and speed distributions according to Eq. \\(\\eqref{eq:mbfd_speed}\\). The 1D-MBFD distribution is perpendicular to the flux direction, 1D-MBFD, flux is parallel to the flux direction. For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbfd_most_probable_speed}\\), \\(\\eqref{eq:mbfd_mean_speed}\\), \\(\\eqref{eq:mbfd_rms_speed}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \n\nfunction mbfd(name=\"mbfd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbfdx  = sqrt(1/2/pi) * exp.(- x1.^2 ./ 2)\n    mbfdz  = x2 .* exp.(- x2.^2 ./ 2)\n    mbfdv  = x2.^3 ./ 2 .* exp.(- x2.^2 ./ 2)\n\n    \n    # plot distributions\n    lines!(ax, x1, mbfdx; color=TUMBlueDark)\n    lines!(ax, x2, mbfdz; color=TUMBlueLight)\n    lines!(ax, x2, mbfdv; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(3);         fvp = vp^3/2*exp(-vp^2/2)\n    vmean = sqrt(9*pi/8); fvmean = vmean^3/2*exp(-vmean^2/2)\n    vrms = sqrt(4);       fvrms = vrms^3/2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*1.1, fvrms*1.0; text=\"root mean squared\", align=(:left, :center), fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBFD\", \"1D-MBFD, flux\", \"3D-MBFD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbfd.pdf   mbfd.svg   mbfd.png \n\n\n\n\n\nFigure 2 shows the probability densities of three MBFD distributed, normalized velocities. The normalization of the velocities has been performed with \\(\\sqrt{m/k_BT} = 1\\). The 1D-MBFD curve shows the pdf of a velocity component perpendicular to the flux direction, which is equal to one-dimensional MBD velocities, see Eq. \\(\\eqref{eq:mbd_1d}\\), which in fact is equal to the scaled normal distribution \\(\\mathcal{N}(0, k_BT/m)\\). The second graph, 1D-MBFD, flux shows the distribution of a directed velocity component in flux direction, \\(f_\\parallel(v)\\), which is equal to \\[\\begin{equation}\n    f_\\parallel (v) dv= 2v\\left(\\frac{m}{2k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_1d_parallel}\n\\end{equation}\\] Last, the graph 3D-MBFD, speed shows the distribution of speeds of the three-dimensional form, given in Eq. \\(\\eqref{eq:mbfd_speed}\\). For the latter, the three typical speeds, the most probable speed \\(v_p\\), the mean speed \\(\\langle v \\rangle\\) or the expected speed, and the root mean squared speed \\(v_\\text{rms}\\), which are derived in the following. Note that, contrary to the MBD, the root mean squared speed is lower than the other two typical speeds due to its additional speed dependency, which shifts the entire distribution to higher values and, thus, to \\(f(v\\approx 0.0) \\approx 0.0\\).\n\nTypical Speeds\nThe most probable speed occurs at the maximum likelihood of the Eq. \\(\\eqref{eq:mbfd_speed}\\): \\[\\begin{equation}\n    \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad \\Rightarrow \\qquad v_p = \\sqrt{\\frac{3k_BT}{m}}.\n    \\label{eq:mbfd_most_probable_speed}\n\\end{equation}\\]\nThe expected value of the speed distribution, the mean speed \\(\\langle v \\rangle\\) is calculated by using the ensemble average equation, shown in Eq. \\(\\eqref{eq:ensemble_average}\\): \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty vf(v) dv= \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}} \\,\\cdot v_p.\n    \\label{eq:mbfd_mean_speed}\n\\end{equation}\\]\nLastly, the speed is calculated as \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v)dv\\right)^{1/2} = \\sqrt{\\frac{2k_BT}{m}} = \\sqrt{\\frac{2}{3}}\\,\\cdot v_p.\n    \\label{eq:mbfd_rms_speed}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann flux distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbfd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} =\\; \\frac{d}{dv} \\left[ 2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\\right]_{v_p} &= 0 \\\\\n    \\Rightarrow && \\left[3v_p^2 \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^4 \\cdot \\exp\\left( -av_p^2 \\right) \\right] &= 0 \\nonumber \\\\\n    \\Rightarrow &&\\; v_p = \\sqrt{\\frac{3}{2a}} &= \\sqrt{\\frac{3k_BT}{m}}.\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbfd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function:: \\[\\begin{align*}\n    % \\meanof{\\velocity} &= \\int_0^\\infty \\velocity f(\\velocity) d\\velocity = 2 \\left(\\frac{\\mass}{2\\BoltzmannConstant\\temperature}\\right)^2 \\cdot \\int_0^\\infty \\velocity^4 \\exp\\left(-\\frac{\\mass\\velocity^2}{2\\BoltzmannConstant\\temperature}\\right) d\\velocity = 2 a^2 \\int_0^\\infty \\velocity^4 \\exp\\left(- a\\velocity^2\\right) d\\velocity \\\\\n    \\langle v \\rangle &= \\int_0^\\infty vf(v) dv= 2 a^2 \\int_0^\\infty v^4 \\exp\\left(- av^2\\right) dv\\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\left[ \\frac{3\\sqrt{\\pi}\\mathop{\\mathrm{erf}}\\left(\\sqrt{a}v\\right)}{4\\sqrt{a}} - \\frac{v\\exp\\left(-av^2\\right) \\cdot \\left(2av^2 + 3\\right)}{2} \\right]_0^\\infty \\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\sqrt{\\frac{9\\pi}{16a}} = \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}}\\,\\cdot v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbfd_rms_speed}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\) \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left(\\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\left( \\int_0^\\infty 2a^2 v^5 \\exp\\left(-av^2\\right) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left( \\left[-\\frac{\\exp\\left(-av^2\\right) \\left(a^2v^4 + 2av^2 + 2 \\right)}{a}\\right]_0^\\infty \\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left(\\frac{2}{a}\\right)^{1/2} = \\sqrt{\\frac{4k_BT}{m}} = \\sqrt{\\frac{4}{3}}\\,\\cdot v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 2: Overview of normalized speeds \\(v\\) of the MBFD, according to Eq. , including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.693\\)\n\n\n\n\\(v_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(0.866\\)\n\\(\\approx\\sqrt{3/4}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(0.916\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(0.94\\)\n\\(\\approx\\sqrt{9\\pi/32}\\)\n\n\n\\(v_\\text{rms}\\)\n\\(0.594\\)\n\\(2.0\\)\n\\(1.155\\)\n\\(\\approx\\sqrt{4/3}\\)\n\\(1.064\\)\n\\(\\approx\\sqrt{32/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.16\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.395\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(1.54\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(1.822\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(2.149\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = 1/2 * v^3 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(3)\n    vm = sqrt(9*pi/8)\n    vr = sqrt(4)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", raw\"$\\approx\\sqrt{4/3}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{8/3\\pi}$\", \"\", \"\", raw\"$\\approx\\sqrt{32/9\\pi}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\", raw\"$\\approx\\sqrt{3/4}$\", \"\", raw\"$\\approx\\sqrt{9\\pi/32}$\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n\n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbfd_typical_speeds.md\", \"w\")\n    write(fid, maketable())\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\nTable 2 shows an overview of the speeds of the MBFD and their relation to the typical speeds. The \\(v_{XX}\\) denotes the speed at which the cdf evaluated to \\(F(v_{XX}) = \\int_0^{v_{XX}} f(v) dv= XX\\,\\mathrm{\\%}\\). The entries are sorted by their cdf with the typical speeds highlighted and placed at the correct position. Note that \\(v_{50}\\) denotes the median of the distribution, which is not equal to the expected value \\(\\langle v \\rangle\\).\n\n\nNumerical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBFD velocity, then any realization can be drawn from the respective pdf: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) = \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\n\\end{equation}\\] given in cartesian coordinates, see Eq. \\(\\eqref{eq:mbfd}\\) and Eq. \\(\\eqref{eq:mbfd_spherical}\\) for the function in spherical coordinates. Similar to the MBD, the numerical sampling of the random variable can be performed by mapping each random component to one implemented numerical distribution. As a reminder, the most basic numerical distributions are the uniform distribution with random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u\\sim f(r_u)=1\\) and a normal distribution with random variable \\(R_n\\in\\left(-\\infty, \\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n | 0, 1 \\right)\\) with zero mean and unit variance.\nIn cartesian coordinates, with \\(\\boldsymbol{\\mathbf{V}}= \\left(V_x, V_y, V_z\\right)\\), the first two directions are assumed to be perpendicular to the flux, while the z-direction is parallel to the flux. Thus, both the x- and the y-component, \\(v_x\\), and \\(v_y\\), can be numerically sampled like in the MBD, which is with scaled normal distributions, see Eqs. \\(\\eqref{eq:mbd_random_cartesian_component_2}\\), \\(\\eqref{eq:mbd_random_cartesian_component}\\). The flux direction is drawn from the \\(f_\\parallel\\) pdf, see Eq. \\(\\eqref{eq:mbfd_1d_parallel}\\), which can not be directly translated in either a uniform or a normal distribution. Therefore, the respective cdf, \\(F_\\parallel\\left(v_z\\right)\\), must be matched with the uniform cdf: \\[\\begin{align}\n    r_{v_z} &= \\int_0^{r_{v_z}} f(r_u) dr_u = \\int_0^{v_z} f_\\parallel(v) dv= F_\\parallel\\left(v_z\\right) = 1 - \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) \\\\\n    \\Rightarrow\\qquad v_z &= \\sqrt{-\\ln\\left(1-r_{v_z}\\right)\\frac{2k_BT}{m}}.\n    \\label{eq:mbfd_random_cartesian_component}\n\\end{align}\\]\n\\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in spherical coordinates as \\(\\boldsymbol{\\mathbf{V}}=\\left(V_v, V_\\varphi, V_\\vartheta\\right)\\) with the differential \\(d^3\\boldsymbol{\\mathbf{v}}=v^2 \\, \\cos\\varphi\\, dvd\\varphi d\\vartheta\\). The additional terms are distributed to the respective random variable: \\[\\begin{alignat}{3}\n    V_v&\\sim f(v) && \\qquad\\text{with realization }v, \\\\    \n    V_\\varphi&\\sim f(\\varphi) = 2\\sin\\varphi\\cos\\varphi&& \\qquad\\text{with realization }\\varphi, \\text{ and } \\\\    \n    V_\\vartheta&\\sim f(\\vartheta) = \\frac{1}{2\\pi} && \\qquad\\text{with realization }\\vartheta.\n\\end{alignat}\\] As before, the cdf of the random variables can be set to equal the cdf of the unit uniform distribution: \\[\\begin{alignat}{3}\n    r_v&= \\int_0^{r_v} f(r_u) dr_u = \\int_0^vf(\\tilde v)d\\tilde v, \\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u) dr_u = \\int_0^\\varphi f(\\tilde\\varphi)d\\tilde\\varphi&&= 1 - \\cos^2\\varphi, \\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u) dr_u = \\int_{-\\pi}^\\vartheta f(\\tilde\\vartheta)d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}.\n\\end{alignat}\\] While the latter two integrals are trivial, leading to a cosine-squared dependence of the elevation angle \\(\\varphi\\) and a uniform dependence on the azimuth angle \\(\\vartheta\\), the speed integral evaluates to \\[\\begin{equation}\n    r_v= 1 - \\exp \\left( -\\frac{mv^2}{2k_BT} \\right) \\cdot \\left( \\frac{mv^2}{2k_BT} + 1\\right).\n    \\label{eq:mbfd_random_speed}\n\\end{equation}\\] only \\(\\varphi=\\cos^{-1}\\left(1-r_\\varphi\\right)\\) and \\(\\vartheta= 2\\pi r_\\vartheta- \\pi\\) can both be directly calculated from their respective realization of the uniform unit random variable, as there is no direct inversion of Eq. \\(\\eqref{eq:mbfd_random_speed}\\).\n\n\n\n\n\n sample: Eqs. \\(\\eqref{eq:mbd_random_cartesian_component}\\), \\(\\eqref{eq:mbfd_random_cartesian_component}\\)"
  },
  {
    "objectID": "documentation/drivers/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "href": "documentation/drivers/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.693\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(0.866\\)\n\\(\\approx\\sqrt{3/4}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(0.916\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(0.94\\)\n\\(\\approx\\sqrt{9\\pi/32}\\)\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.594\\)\n\\(2.0\\)\n\\(1.155\\)\n\\(\\approx\\sqrt{4/3}\\)\n\\(1.064\\)\n\\(\\approx\\sqrt{32/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.16\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.395\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(1.54\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(1.822\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(2.149\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "presentations/presentations.html",
    "href": "presentations/presentations.html",
    "title": "Presentation & Videos",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nTSU Mini-Moon Seminar\n\n\n\n\n\n\n\nPresentation\n\n\n\n\n\n\n\n\n\n\n\nAug 15, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "api/api.html",
    "href": "api/api.html",
    "title": "Code",
    "section": "",
    "text": "The ExESS package is structured into four main parts, which are the four main folders in the /src directory:"
  },
  {
    "objectID": "api/api.html#repository-structure",
    "href": "api/api.html#repository-structure",
    "title": "Code",
    "section": "Repository Structure",
    "text": "Repository Structure\n\n\nExESS/  \n├── data/  \n├── res/  \n├── src/  \n│  ├── base/  \n│  ├── exospheres/  \n│  ├── grids/  \n│  ├── surfaces/  \n│  └── ExESS.jl  \n├── test/  \n├── . . .  \n└── README.md"
  },
  {
    "objectID": "api/api.html#source-files",
    "href": "api/api.html#source-files",
    "title": "Code",
    "section": "Source Files",
    "text": "Source Files\n\n\nBase Functionalities – base/\nExESS/src/base/ contains basic functionality that is used at multiple places in the code, e.g., physical constants, coordinate system definitions, utility functions, and some probability distributions.\n\nconstants.jl\n\ncs.jl\ndistributions.jl\nutils.jl\n\n\n\nExospheres – exospheres/\nExESS/src/exospheres/ contains all scripts that define functions that have something to do with simulating the exosphere. Due to the assumption of surface-bounded exospheres, Monte-Carlo methods are the preferred simulation tool as each individual particle of the exosphere can be simulated independently. Implemented functionalities are mostly based on ballistic trajectory calculations.\n\norbital_mechanics.jl\ntrajectories.jl\nutils.jl\n\n\n\nNumerical Grids – grids/\nExESS/src/grids/ contains all numerical discretization methods used in this package. While most functions can be called with AbstractVector inputs, their main use is meant to be in conjunction with the previously defined custom coordinate systems.\n\nglobal_healpix_2d_grids.jl\n\nglobal_spiral_2d_grids.jl\n\nglobal_structured_2d_grids.jl\n\nglobal_structured_3d_grids.jl\n\ntypes.jl\n\nutils.jl\n\n\n\nSurfaces – surfaces/\nExESS/src/surfaces/ contains all functions that are used to calculate surface properties, e.g., surface temperatures, reaction kinetics, thermal conductivities, and diffusion coefficients.\n\ndensity.jl\n\nporosity.jl\n\nreaction_rates.jl\n\nregolith.jl\n\ntemperature.jl\n\nthermal_conductivity_parzinger2014.jl\n\nutils.jl"
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html",
    "href": "api/exospheres/orbital_mechanics.html",
    "title": "Orbital Mechanics",
    "section": "",
    "text": "The mathematical definition of the implemented functions is presented in the documentation, in the section Ballistic Trajectories."
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html#usage",
    "href": "api/exospheres/orbital_mechanics.html#usage",
    "title": "Orbital Mechanics",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html#api",
    "href": "api/exospheres/orbital_mechanics.html#api",
    "title": "Orbital Mechanics",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nazimuth_angle_v – Function\n\n\n\n\n\n[1] azimuth_angle_v(v::AbstractVector)\n[2] azimuth_angle_v(v::LocalCartesianVelocity)\nCalculates the azimuth angle of the launch velocity vector v, measured mathematically positive from x (east). The resulting angle is given in radians, [-π, π).\nReturns NaN if v1=v2=0, i.e., for no planar velocities.\n\n\n\n\n\n\n\n\n\n\neccentric_anomaly_e_M – Function\n\n\n\n\n\n[1] eccentric_anomaly_e_M(e::Real, M::Real, N=10)\nCalculates the eccentric anomaly given the orbit’s eccentricity e and the mean anomaly M, which triggers a numerical approximation with N steps. The result is given in radians [0, 2π).\n\nAlternative Functions\neccentric_anomaly_e_theta\n\n\n\n\n\n\n\n\n\n\n\neccentric_anomaly_e_theta – Function\n\n\n\n\n\n[1] eccentric_anomaly_e_theta(e::Real, theta::Real)\nCalculates the eccentric anomaly given the orbit’s eccentricity e and the true anomaly theta. The result is given in radians [0, 2π).\n\nAlternative Functions\neccentric_anomaly_e_M\n\n\n\n\n\n\n\n\n\n\n\neccentricity_epskin_psi – Function\n\n\n\n\n\n[1] eccentricity_epskin_psi(epskin::Real, psi::Real)\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction epskin, and the zenith launch angle psi.\n\nAlternative Functions\neccentricity_epskin_v, eccentricity_r_m_v\n\n\n\n\n\n\n\n\n\n\n\neccentricity_epskin_v – Function\n\n\n\n\n\n[1] eccentricity_epskin_v(epskin::Real, v::AbstractVector)\n[2] eccentricity_epskin_v(epskin::Real, v::LocalCartesianVelocity)\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction epskin, and the velocity vector v.\n\nAlternative Functions\neccentricity_epskin_psi, eccentricity_r_m_v\n\n\n\n\n\n\n\n\n\n\n\neccentricity_r_m_v – Function\n\n\n\n\n\n[1] eccentricity_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] eccentricity_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the eccentricity of an elliptical trajetory based on the orbital radius r, the body’s mass m, and the velocity vector v.\n\nAlternative Functions\neccentricity_epskin_psi, eccentricity_epskin_v\n\n\n\n\n\n\n\n\n\n\n\nescape_velocity_r_m – Function\n\n\n\n\n\n[1] escape_velocity_r_m(r::Real, m::Real)\nCalculates the magnitude of the escape velocity for an orbital radius r and body mass m.\n\n\n\n\n\n\n\n\n\n\nflight_time_t0_t1 – Function\n\n\n\n\n\n[1] flight_time_t0_t1(t0::Real, t1::Real)\nCalculates the time of flight between the two orbital times t0 and t1.\n\nAlternative Functions\nflight_time_t0_P, flight_time_e_theta0_theta1_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_t0_P – Function\n\n\n\n\n\n[1] flight_time_t0_P(t0::Real, P::Real)\nCalculates the time of flight, given a symmetrical trajectory with a starting orbital time of t0 and a landing orbital time of P-t0, with the orbital period P.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_e_theta0_theta1_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_e_theta0_theta1_P – Function\n\n\n\n\n\n[1] flight_time_e_theta0_theta1_P(e::Real, theta0::Real, theta1::Real, P::Real)\nCalculates the time of flight between the two orbital positions theta0 and theta1, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_t0_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_e_theta0_P – Function\n\n\n\n\n\n[1] flight_time_e_theta0_P(e::Real, theta0::Real, P::Real)\nCalculates the time of flight, given a symmetrical trajectory between the two orbital positions theta0 and 2π - theta0, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_t0_P, flight_time_e_theta0_theta1_P\n\n\n\n\n\n\n\n\n\n\n\nepskin_vesc_v – Function\n\n\n\n\n\n[1] epskin_vesc_v(vesc::Real, v::AbstractVector)\n[2] epskin_vesc_v(vesc::Real, v::LocalCartesianVelocity)\nCalculates the squared fraction of the velocity vector v with respect to the escape velocity vesc.\n\nAlternative Functions\nepskin_r_m_v, epskin_r_a, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_r_m_v – Function\n\n\n\n\n\n[1] epskin_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] epskin_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the squared fraction of the velocity vector v, based on the orbital radius r and the body’s mass m.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_a, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_r_a – Function\n\n\n\n\n\n[1] epskin_r_a(r::Real, a::Real)\nCalculates the squared fraction of the velocity at the radial position r on an orbit defined through the semi-major axis a.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_m_v, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_e_theta – Function\n\n\n\n\n\n[1] epskin_e_theta(e::Real, theta::Real)\nCalculates the squared fraction of the velocity at the angular position theta on an orbit defined through the eccentricity e.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_m_v, epskin_r_a\n\n\n\n\n\n\n\n\n\n\n\nground_distance_R_dtheta – Function\n\n\n\n\n\n[1] ground_distance_R_dtheta(R::Real, dtheta::Real)\nCalculates the ground flight distance covered by an angle dtheta of an elliptical orbit, which intersects with a body of radius R.\n\nAlternative Functions\nground_distance_R_a_e\n\n\n\n\n\n\n\n\n\n\n\nground_distance_R_a_e – Function\n\n\n\n\n\n[1] ground_distance_R_a_e(R::Real, a::Real, e::Real)\nCalculates the ground flight distance covered based on the radius of the body R, the orbit’s semi-major axis a, and the eccentricity e.\n\nAlternative Functions\nground_distance_R_dtheta\n\n\n\n\n\n\n\n\n\n\n\nmean_anomaly_e_E – Function\n\n\n\n\n\n[1] mean_anomaly_e_E(e::Real, E::Real)\nCalculates the mean anomaly, given the orbit’s eccentricity e and the eccentric anomaly E.\n\nAlternative Functions\nmean_anomaly_e_theta\n\n\n\n\n\n\n\n\n\n\n\nmean_anomaly_e_theta – Function\n\n\n\n\n\n[1] mean_anomaly_e_theta(e::Real, theta::Real)\nCalculates the mean anomaly, given the orbit’s eccentricity e and the true anomaly theta.\n\nAlternative Functions\nmean_anomaly_e_E\n\n\n\n\n\n\n\n\n\n\n\norbit_period_a_m – Function\n\n\n\n\n\n[1] orbit_period_a_m(a::Real, m::Real)\nCalculates the period of an elliptical orbit, based on the semi-major axis a, and the body’s mass m.\n\n\n\n\n\n\n\n\n\n\norbit_time_M_P – Function\n\n\n\n\n\n[1] orbit_time_M_P(M::Real, P::Real)\nCalculates the time at the position of an orbit defined through the mean anomaly M, as well as the orbital period P.\n\nAlternative Functions\norbit_time_e_E_P, orbit_time_e_theta_P\n\n\n\n\n\n\n\n\n\n\n\norbit_time_e_E_P – Function\n\n\n\n\n\n[1] orbit_time_e_E_P(e::Real, E::Real, P::Real)\nCalculates the time at the position of an orbit defined through the eccentric anomaly E, the eccentricity e, and the orbital period P.\n\nAlternative Functions\norbit_time_M_P, orbit_time_e_theta_P\n\n\n\n\n\n\n\n\n\n\n\norbit_time_e_theta_P – Function\n\n\n\n\n\n[1] orbit_time_e_theta_P(e::Real, theta::Real, P::Real)\nCalculates the time at the position of an orbit defined through the true anomaly theta, the eccentricity e, and the orbital period P.\n\nAlternative Functions\norbit_time_M_P, orbit_time_e_E_P\n\n\n\n\n\n\n\n\n\n\n\nsemi_latus_rectum_a_e – Function\n\n\n\n\n\n[1] semi_latus_rectum_a_e(a::Real, e::Real)\nCalculates the semi-latus-rectum of the elliptical trajetory defined through the semi-major axis a and the eccentricity e.\n\nAlternative Functions\nsemi_latus_rectum_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_latus_rectum_r_e_theta – Function\n\n\n\n\n\n[1] semi_latus_rectum_r_e_theta(r::Real, e::Real, theta::Real)\nCalculates the semi-latus-rectum of the elliptical trajetory based on the orbital radius r, the eccentricity e, and the true anomaly theta\n\nAlternative Functions\nsemi_latus_rectum_a_e\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_epskin – Function\n\n\n\n\n\n[1] semi_major_axis_r_epskin(r::Real, epskin::Real)\nCalculates the semi-major axis of an elliptical orbit with the current orbital radius r and the trajectory’s squared escape velocity fraction epskin.\n\nAlternative Functions\nsemi_major_axis_r_m_v, semi_major_axis_p_e, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_m_v – Function\n\n\n\n\n\n[1] semi_major_axis_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] semi_major_axis_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the semi-major axis of an elliptical orbit with the current orbital radius r, the body’s mass m, and the velocity vector v.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_p_e, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_p_e – Function\n\n\n\n\n\n[1] semi_major_axis_p_e(p::Real, e::Real)\nCalculates the semi-major axis of an elliptical orbit with the semi-latus rectum p and eccentricity e.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_r_m_v, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_e_theta – Function\n\n\n\n\n\n[1] semi_major_axis_r_e_theta(r::Real, e::Real, theta::Real)\nCalculates the semi-major axis of an elliptical orbit with the oribital radius r, the eccentricity e, and the true anomaly theta.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_r_m_v, semi_major_axis_p_e\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_r_a_e – Function\n\n\n\n\n\n[1] true_anomaly_r_a_e(r::Real, a::Real, e::Real)\nCalculates the true anomaly at the radial position r based on the semi-major axis a, and the eccentricity of the orbit e.\n\nAlternative Functions\ntrue_anomaly_e_epskin, true_anomaly_epskin_v\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_e_epskin – Function\n\n\n\n\n\n[1] true_anomaly_e_epskin(e::Real, epskin::Real)\nCalculates the true anomaly based on the eccentricity of the orbit e and the current squared escape velocity fraction epskin.\n\nAlternative Functions\ntrue_anomaly_r_a_e, true_anomaly_epskin_v\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_epskin_v – Function\n\n\n\n\n\nNo documentation found.\nMain.ExESS.true_anomaly_epskin_v is a Function.\n# 2 methods for generic function \"true_anomaly_epskin_v\" from Main.ExESS:\n [1] true_anomaly_epskin_v(epskin::Real, v::AbstractVector)\n     @ ~/repos/exess/exess.jl/src/exospheres/orbital_mechanics.jl:426\n [2] true_anomaly_epskin_v(epskin::Real, v::LocalCartesianVelocity)\n     @ ~/repos/exess/exess.jl/src/exospheres/orbital_mechanics.jl:427\n\n\n\n\n\n\n\n\n\n\nzenith_angle_v – Function\n\n\n\n\n\n[1] zenith_angle_v(v::AbstractVector)\n[2] zenith_angle_v(v::LocalCartesianVelocity)\nCalculates the zenith launch angle based on the launch velocity vector v."
  },
  {
    "objectID": "api/base/utility.html",
    "href": "api/base/utility.html",
    "title": "Utility",
    "section": "",
    "text": "In base/utility.jl, you will find a collection of utility functions that are used throughout the package."
  },
  {
    "objectID": "api/base/utility.html#usage",
    "href": "api/base/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage\nAll the utility functions defined here are easy-to-use and generally self-explanatory. For example, the unit conversion functions amu2kg, eV2J, and J2eV:\nm_H = amu2kg(AMU_H) # 1.673781838440757e-27\nIn the example above, the atomic mass of hydrogen, stored in the custom constant AMU_H, is converted from atomic mass units to kilograms and stored in a new variable m_H (its value is provided in the comment).\neV = 1 # 1\nJ = eV2J(eV) # 1.602176634e-19\nev == J2eV(J) # true\nThe functions eV2J and J2eV convert the energy units electronvolt and joule. In the example above, the value of eV is converted to joules and stored in J. The conversion is then reversed, and the result is compared to the original value of eV. Note that all three functions accept any Real number type, returning either the input type, if that type is a subtype of AbstractFloat, or a Float64 otherwise (exception with the input type BigInt which leads the function to return a BigFloat)."
  },
  {
    "objectID": "api/base/utility.html#examples",
    "href": "api/base/utility.html#examples",
    "title": "Utility",
    "section": "Examples",
    "text": "Examples\n\nEscape Velocities and Energies\nThe following example shows how to use the utility functions to calculate the required energy of a particle to escape the gravitational pull of the Moon.\n# defines the masses of hydrogen, molecular hydrogen, hydroxyl, and water \n# in kilograms\nmasses = amu2kg.([AMU_H, AMU_H2, AMU_OH, AMU_H2O])\n\n# calculates the escape velocity of the Moon on its surface in m/s\nv_esc = escape_velocity_r_m(LUNAR_RADIUS, LUNAR_MASS)\n\n# define a function to calculate the kinetic energy of a particle, based on\n# its mass and velocity\nE_kin(m::Real; v=v_esc) = 0.5 * m * v_esc^2\n\n# calculate the kinetic energy of the particles defined above, in eV\nE = J2eV.(E_kin.(masses))\nIn the following, we will go through this example step-by-step. The first line of code defines the masses of hydrogen, molecular hydrogen, hydroxyl, and water in kilograms and saves their values in a vector masses. It uses the amu2kg function to turn the constants AMU_H, AMU_H2, AMU_OH, and AMU_H2O from atomic mass units to kilograms (note the amu2kg.(...) dot-notation to broadcast the function which is only defined for scalar inputs, to work with arrays):\nmasses = amu2kg.([AMU_H, AMU_H2, AMU_OH, AMU_H2O])\nThe output is a vector of four elements, each corresponding to the mass of one of the particles in kilograms:\n\n\n4-element Vector{Float64}:\n 1.673781838440757e-27\n 3.347563676881514e-27\n 2.824141014861615e-26\n 2.9915191987056904e-26\n\n\nThe next line calculates the velocity that each particle would need to escape the lunar gravity field, i.e., the escape velocity, for which the orbital mechanics function escape_velocity_r_m is used. Note that, as the name of the function suggests, it requires the radius and mass of the respective body for which the escape velocity shall be calculated as inputs, which are provided as the constants LUNAR_RADIUS and LUNAR_MASS:\nv_esc = escape_velocity_r_m(LUNAR_RADIUS, LUNAR_MASS)\nIt results in the following scalar value:\n\n\n2359.7179236582847\n\n\nThe third code line defines a new function called E_kin, which takes one argument m::Real as the mass of a particle in kilograms as a real number type, and one optional keyword argument v which is given the default value of our previously calculated escape velocity v_esc.\nE_kin(m::Real; v=v_esc) = 0.5 * m * v_esc^2\nNow, the function E_kin can be used to calculate the kinetic energy of particles with masses saved in masses, again, by broadcasting over the function with the dot notation. In order to provide the result in a more convenient unit, the function J2eV is applied to the result, which converts the energy from Joules to electronvolts:\nE = J2eV.(E_kin.(masses))\nwhich leads to the final output vector:\n\n\n4-element Vector{Float64}:\n 0.029085641336536464\n 0.05817128267307293\n 0.49075662523969016\n 0.5198422665762266"
  },
  {
    "objectID": "api/base/utility.html#api",
    "href": "api/base/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\namu2kg – Function\n\n\n\n\n\n[1] amu2kg(amu::Real)\nConverts atomic mass unit amu into kilo gram.\n\n\n\n\n\n\n\n\n\n\neV2J – Function\n\n\n\n\n\n[1] eV2J(eV::Real)\nConverts energy in electron volt eV to joule.\n\n\n\n\n\n\n\n\n\n\nJ2eV – Function\n\n\n\n\n\n[1] J2eV(J::Real)\nConverts energy in joule J to electron volt.\n\n\n\n\n\n\n\n\n\n\nlimit_acos – Function\n\n\n\n\n\n[1] limit_acos(x::Real)\nExtends the acos function for input outside of [-1,1] through clipping.\n\n\n\n\n\n\n\n\n\n\nsgn – Function\n\n\n\n\n\n[1] sgn(x::Real)\nReturns the sign of x with the custom definition sgn(0) = 1."
  },
  {
    "objectID": "api/base/distributions.html#type-structure",
    "href": "api/base/distributions.html#type-structure",
    "title": "Distributions",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractDistribution\n    ├─ MaxwellBoltzmannVelocityDistribution\n    └─ MaxwellBoltzmannFluxVelocityDistribution"
  },
  {
    "objectID": "api/base/distributions.html#usage",
    "href": "api/base/distributions.html#usage",
    "title": "Distributions",
    "section": "Usage",
    "text": "Usage\n\nVelocity Distributions\nFor the theoretical description of the velocity distributions, please read the documentation."
  },
  {
    "objectID": "api/base/distributions.html#api",
    "href": "api/base/distributions.html#api",
    "title": "Distributions",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nMaxwellBoltzmannVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannVelocityDistribution()\nEmpty struct defining a (3D) Maxwell-Boltzmann velocity distribution.\n\n\n\n\n\n\n\n\n\n\nMaxwellBoltzmannFluxVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannFluxVelocityDistribution()\nEmpty struct defining a (3D) Maxwell-Boltzmann flux velocity distribution.\n\n\n\n\n\nUtility Functions\n\n\n\n\n\n\ncdf – Function\n\n\n\n\n\n[1] cdf([S::Type], vd::AbstractVelocityDistribution, v::Tuple{Real, Real}, T::Real, m::Real; N=1000)\n[2] cdf([S::Type], vd::AbstractVelocityDistribution, v::Real, T::Real, m::Real; kwargs...)\nComputes the cumulative distribution function of the velocity distribution vd based on numerical integration of the respective probability density function between the upper and lower speed given in v (in [m s-1]) (if v is scalar, the lower boundary is zero). Takes the temperature T (in [K]) and the mass m (in [kg]) as arguments to evaluate the MB(F) distributions. The keyword argument N controls the number of numerical integration steps.\n\n\n\n\n\n\n\n\n\n\npdf – Function\n\n\n\n\n\n[1] pdf([S::Type], ::AbstractVelocityDistribution, v::Real, T::Real, m::Real)\nCalculates the probability density of MB(F) speed distributions, at the speed v (in [m s-1]), given the temperature T (in [K]), and the mass m (in [kg]).\n\n\n\n\n\n\n\n\n\n\nsample – Function\n\n\n\n\n\n[1] sample([S::Type], ::MaxwellBoltzmannVelocityDistribution, T::Real, m::Real; dims=3)\n[2] sample([S::Type], ::MaxwellBoltzmannFluxVelocityDistribution, T::Real, m::Real)\nSamples the distribtion, given the temperature T in [K], and the mass m in [kg]. For Maxwell-Boltzmann distributions, an optional keyword argument dims can be passed to control the dimensionality of the output vector. An optional type S can also be passed to control the type of the output vector."
  },
  {
    "objectID": "api/grids/utility.html#usage",
    "href": "api/grids/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/utility.html#api",
    "href": "api/grids/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nareas – Function\n\n\n\n\n\n[1] areas([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns the surface area of each grid element. For 3D grids, returns the base area of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoords – Function\n\n\n\n\n\n[1] coords([T::Type,] grid::AbstractGrid)\nReturns the coordinates of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoord2idx – Function\n\n\n\n\n\n[1] coord2idx(grid::AbstractGlobalGrid, [r::Real,] theta::Real, phi::Real)\n[2] coord2idx(grid::AbstractGlobalGrid, [r::AbstractVector,] theta::AbstractVector, phi::AbstractVector)\n[3] coord2idx(grid::AbstractGlobalGrid, coords::AbstractPosition)\n[4] coord2idx(grid::AbstractGlobalGrid, coords::Vector{AbstractPosition})\nCalculates the index of the grid element containing the given coordinates.\n\n\n\n\n\n\n\n\n\n\nsurfacecoords – Function\n\n\n\n\n\n[1] surfacecoords([T::Type,] grid::AbstractGrid)\nReturns only the coordinates of the surface (i.e. the base) of the discretized geometry.\n\n\n\n\n\n\n\n\n\n\nvolumes – Function\n\n\n\n\n\n[1] volumes([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns a vector of zeros(T) for each grid element. For 3D grids, returns the volume of each grid element."
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#type-structure",
    "href": "api/grids/global_structured_3d_grids.html#type-structure",
    "title": "Global, Structured, 3D Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#usage",
    "href": "api/grids/global_structured_3d_grids.html#usage",
    "title": "Global, Structured, 3D Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/global_structured_3d_grids.html#api",
    "href": "api/grids/global_structured_3d_grids.html#api",
    "title": "Global, Structured, 3D Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalStructured3DGrid – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid([T::Type,] r0::Real, h::AbstractVector, N_theta::Int64, N_phi::Int64)\n[3] GlobalStructured3DGrid([T::Type,] r::AbstractVector, N_theta::Int64, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_EqSim([T::Type,] r0::Real, h::AbstractVector, N_theta::Int64, N_phi::Int64)\n[3] GlobalStructured3DGrid_EqSim([T::Type,] r::AbstractVector, N_theta::Int64, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a hemisphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_Reduced – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_Reduced{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_Reduced([T::Type,] r0::Real, h::AbstractVector, N_phi::Int64)\n[3] GlobalStructured3DGrid_Reduced([T::Type,] r::AbstractVector, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured3DGrid_Reduced_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured3DGrid_Reduced_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured3DGrid end\n[2] GlobalStructured3DGrid_Reduced_EqSim([T::Type,] r0::Real, h::AbstractVector, N_phi::Int64)\n[3] GlobalStructured3DGrid_Reduced_EqSim([T::Type,] r::AbstractVector, N_phi::Int64)\nGlobal structured volume grid (3D) of type GlobalSphericalPosition{T} over a sphere of radius r0 with heights of the individual radial layers h. Alternatively, the radial distances can directly be specified by r (r = r0 .+ h). Note that all heights have to be positive. The grid is reduced in the azimuth direction to have approximately equal 2*pi*r*cos(phi)/N_theta grid element lengths.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr0\nT\nradius of global body (sphere)\n\n\nh\nVector{T}\nheights above radial base r0\n\n\nN_r\nInt64\nnumber of elements in radial direction\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\nvolumes\nVector{T}\nvolumes\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructors [2] or [3]."
  }
]