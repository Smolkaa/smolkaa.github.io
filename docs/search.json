[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Extraterrestrial Exosphere and Surface Simulations",
    "section": "",
    "text": "This website is still under construction!"
  },
  {
    "objectID": "manuals/package_installation/index.html#installation",
    "href": "manuals/package_installation/index.html#installation",
    "title": "ExESS Package Installation",
    "section": "Installation",
    "text": "Installation\nThis simulation tool was created as a custom package for the computer language Julia. Please refer to the official guide to installing Julia on your machine. To be able to use the ExESS package, the entire repository has to be downloaded from LRZ-GitLab. Afterward, the code can be used in several different ways. The entire module can be included directly by specifying the path of the downloaded package in the include call.\ninclude(joinpath(PathToPackage, \"src\", \"ExESS.jl\"))\nusing .ExESS"
  },
  {
    "objectID": "manuals/package_installation/index.html#required-packages",
    "href": "manuals/package_installation/index.html#required-packages",
    "title": "ExESS Package Installation",
    "section": "Required Packages",
    "text": "Required Packages\nThe ExESS package relies on multiple other packages that have to be added and installed by the user. They can be added using Julia’s package-manager Pkg:\nusing Pkg\nPkg.add(\"Interpolations\")\nPkg.add(\"NearestNeighbors\")\nPkg.add(\"DifferentialEquations\")\nPkg.add(\"SpecialFunctions\")"
  },
  {
    "objectID": "manuals/git_essentials/index.html",
    "href": "manuals/git_essentials/index.html",
    "title": "Git Essentials",
    "section": "",
    "text": "Collaboration with Git and the Git workflow are essential aspects of modern software development. Git, a powerful version control system, enables seamless collaboration among developers by facilitating code sharing, tracking changes, and resolving conflicts. The Git workflow refers to a structured approach to managing team-based coding projects, encompassing branching, merging, pull requests, and code reviews.\nThis page provides a collection of online materials that delve into essential concepts, ranging from fundamental Git commands to advanced collaboration techniques."
  },
  {
    "objectID": "manuals/git_essentials/index.html#git",
    "href": "manuals/git_essentials/index.html#git",
    "title": "Git Essentials",
    "section": "Git",
    "text": "Git\n\nA Beginner’s Guide to Git and Version Control (last visited: 28/07/2023)\nGetting Started with Git (last visited: 28/07/2023)\nCollaborating with Git (last visited: 28/07/2023)\nGit Documentation (last visited: 28/07/2023)"
  },
  {
    "objectID": "manuals/git_essentials/index.html#github",
    "href": "manuals/git_essentials/index.html#github",
    "title": "Git Essentials",
    "section": "GitHub",
    "text": "GitHub\nWhile Git is a version control system that allows developers to track changes in their codebase and collaborate with other developers, GitHub is an online service that provides hosting for Git repositories.\n\nGit vs. GitHub: What’s the Difference? (last visited: 28/07/2023)"
  },
  {
    "objectID": "manuals/git_essentials/index.html#gitlab-lrz",
    "href": "manuals/git_essentials/index.html#gitlab-lrz",
    "title": "Git Essentials",
    "section": "GitLab (LRZ)",
    "text": "GitLab (LRZ)\nBoth GitHub and GitLab are based around the overarching Git distributed control system. The LRZ GitLab is locally hosted and accessible with your (TUM/etc.) university account. Projects, groups, and repositories are only accessible to other authorized users of the LRZ GitLab.\n\nLRZ GitLab\nGitLab Documentation (last visited: 28/07/2023)"
  },
  {
    "objectID": "manuals/git_essentials/index.html#vscode-extensions",
    "href": "manuals/git_essentials/index.html#vscode-extensions",
    "title": "Git Essentials",
    "section": "VSCode Extensions",
    "text": "VSCode Extensions\nSome useful extensions to use Git version control within VSCode.\n\nGitLense – Git supercharged (last visited: 28/07/2023)"
  },
  {
    "objectID": "manuals/manuals.html",
    "href": "manuals/manuals.html",
    "title": "Manuals & Examples",
    "section": "",
    "text": "The following list contains all manuals, examples, and additional material that is available for the ExESS documentation and software. Note that you can use the filtering and ordering tools at the top of the list to filter and order the entries. Additionally, you can filter the entries by categories, which are listed in the right siderbar of this page. Here are some important manuals to check out:\n\nStudent Thesis: On-Boarding Checklist is recommended for all new students to get started with their university thesis and working with the ExESS package\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nExESS Package Installation\n\n\n\n\n\n\n\nJulia\n\n\nOn-Boarding\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\n  \n\n\n\n\nFibonnacci Sequence\n\n\n\n\n\n\n\nJulia\n\n\nExercise\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\n  \n\n\n\n\nGit Essentials\n\n\n\n\n\n\n\nOn-Boarding\n\n\n\n\n\n\n\n\n\n\n\nJul 28, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\n  \n\n\n\n\nJulia Programming Language: Links & Resources\n\n\n\n\n\n\n\nJulia\n\n\n\n\n\n\n\n\n\n\n\nJul 31, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\n  \n\n\n\n\nStudent Thesis: On-Boarding Checklist\n\n\n\n\n\n\n\nOn-Boarding\n\n\n\n\n\n\n\n\n\n\n\nJul 28, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\n  \n\n\n\n\nTrajectory Calculation\n\n\n\n\n\n\n\nJulia\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\nJul 17, 2023\n\n\nAlexander Smolka\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "manuals/onboarding_checklist/index.html",
    "href": "manuals/onboarding_checklist/index.html",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "",
    "text": "This page contains a checklist for students to get started working on their thesis based on the ExESS research project. While the General Checklist is applicable to students of all levels (Bachelor/Semester/Master) and all topics (theoretical/numerical/…); the other lists are only relevant for certains levels and topics. For questions, please contact me: a.smolka@tum.de."
  },
  {
    "objectID": "manuals/onboarding_checklist/index.html#sec-general",
    "href": "manuals/onboarding_checklist/index.html#sec-general",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "General Checklist",
    "text": "General Checklist\nThis general checklist shall be completed in the first week(s) of your student thesis work.\n\nreceive “LPE Thesis Starter Set”\n\nread and understand the “Student Thesis Information” presentation slides\n\nopen (and/or install) RocketChat\n\nuse RocketChat to send me a message containing one of the logical fallacies listed in the “Student Thesis Information”\n\nset up LRZ Sync&Share online folder\nregister your thesis\n\ncheck the information on the registration document (LRZ Sync&Share folder), sign the document, and upload the signed registration to the same folder\n\nset up weekly meeting (including a fixed, weekly repeating outlook meeting)\n\nplease prepare a short presentation for each regular meeting, which should at a minimum contain two slides; one with a list of the tasks you have completed since the last meeting and one with a list of the tasks you plan to complete until the next meeting\n\nset up a time-plan for your thesis and include the plan in your first presentation (see the example below)\n\n\n\n\n\n\n\nExample Time-Plan\n\n\n\nThe first time-plan does not need to be (can not and should not be) very detailed. It should however give a rough overview of the tasks you plan to complete and the time you plan to spend on each task. The following is an example of a first draft of a time-plan for a 6-month thesis. The time-plan is written in Mermaid, which is a markdown-like language for generating diagrams. The Mermaid code is included in the source of this page, so you can copy it and modify it for your own time-plan. You can also use the Mermaid Live Editor to generate your own time-plan.\nOver the course of your thesis, revisit the time-plan regularly and update it accordingly. This will help you to keep track of your progress and to identify potential problems early on. By adding more details to the time-plan over time, you will also have a good starting point for your thesis report.\n\n\n\n\ngantt\n  %% title Student Thesis Time-Plan\n  dateFormat DD-MM\n  axisFormat %m\n\n  section On-Boarding\n    On-Boarding Checklist: 01-01, 15d\n    Learning Julia: 01-01, 01-03\n  section Reading\n    Reading Papers: 01-01, 01-04\n  section Writing\n    Continuous Documentation: 01-01, 15-05\n    Thesis Writing: 15-04, 15-06\n    Thesis Review: 15-06, 01-07\n    Thesis Submission: milestone, 01-07"
  },
  {
    "objectID": "manuals/onboarding_checklist/index.html#sec-numerical",
    "href": "manuals/onboarding_checklist/index.html#sec-numerical",
    "title": "Student Thesis: On-Boarding Checklist",
    "section": "Numerical Based Thesis Checklist",
    "text": "Numerical Based Thesis Checklist\nIn case you are working on a numerical based thesis, the following checklist can help you get started with your work.\n\nset up Julia\n\ncheck out the list with recommended Julia Resources\n\nset up the ExESS package (if applicable)"
  },
  {
    "objectID": "api/grids/utility.html#usage",
    "href": "api/grids/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/utility.html#api",
    "href": "api/grids/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nareas – Struct\n\n\n\n\n\n[1] areas([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns the surface area of each grid element. For 3D grids, returns the base area of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoords – Struct\n\n\n\n\n\n[1] coords([T::Type,] grid::AbstractGrid)\nReturns the coordinates of each grid element.\n\n\n\n\n\n\n\n\n\n\ncoord2idx – Struct\n\n\n\n\n\n[1] coord2idx(grid::AbstractGlobalGrid, [r::Real,] theta::Real, phi::Real)\n[2] coord2idx(grid::AbstractGlobalGrid, [r::AbstractVector,] theta::AbstractVector, phi::AbstractVector)\n[3] coord2idx(grid::AbstractGlobalGrid, coords::AbstractPosition)\n[4] coord2idx(grid::AbstractGlobalGrid, coords::Vector{AbstractPosition})\nCalculates the index of the grid element containing the given coordinates.\n\n\n\n\n\n\n\n\n\n\nsurfacecoords – Struct\n\n\n\n\n\n[1] surfacecoords([T::Type,] grid::AbstractGrid)\nReturns only the coordinates of the surface (i.e. the base) of the discretized geometry.\n\n\n\n\n\n\n\n\n\n\nvolumes – Struct\n\n\n\n\n\n[1] volumes([T::Type,] grid::AbstractGrid)\nFor 2D grids, returns a vector of zeros(T) for each grid element. For 3D grids, returns the volume of each grid element."
  },
  {
    "objectID": "api/surfaces/temperature.html",
    "href": "api/surfaces/temperature.html",
    "title": "Temperature",
    "section": "",
    "text": "A more in-depth description of the implemented functions listed below can be found in the following sections:"
  },
  {
    "objectID": "api/surfaces/temperature.html#usage",
    "href": "api/surfaces/temperature.html#usage",
    "title": "Temperature",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/surfaces/temperature.html#api",
    "href": "api/surfaces/temperature.html#api",
    "title": "Temperature",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nlunar_surface_temperatures_diviner – Struct\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner(lng0::Real)\n[2] lunar_surface_temperatures_diviner(lng0::Real, lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner(lng0::Real, lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner(lng0::Real, xs::GlobalSphericalPosition) \n[4] lunar_surface_temperatures_diviner(lng0::Real, XS::Vector{GlobalSphericalPosition}) \n[5] lunar_surface_temperatures_diviner(lng0::Real, grid::Abstract2DGrid)\nReturns the Diviner measurements based lunar surface temperatures, with the sub-solar point shifted by lng (in radians) from the center.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_diviner_avg – Struct\n\n\n\n\n\n[1] lunar_surface_temperatures_diviner_avg()\n[2] lunar_surface_temperatures_diviner_avg(lng::Real, lat::Real)\n[3] lunar_surface_temperatures_diviner_avg(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[4] lunar_surface_temperatures_diviner_avg(xs::GlobalSphericalPosition)\n[5] lunar_surface_temperatures_diviner_avg(XS::Vector{GlobalSphericalPosition})\n[6] lunar_surface_temperatures_diviner_avg(grid::Abstract2DGrid)\nReturns the Diviner measurements based averaged lunar surface temperatures.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_BUTLER1997 – Struct\n\n\n\n\n\n[1] lunar_surface_temperatures_BUTLER1997(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_BUTLER1997(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_BUTLER1997(xs::GlobalSphericalPosition)\n[4] lunar_surface_temperatures_BUTLER1997(XS::Vector{GlobalSphericalPosition})\n[5] lunar_surface_temperatures_BUTLER1997(grid::Abstract2DGrid)\nCalculates the surface temperature based on the approximation given in Butler, 1997. Takes the SSE coordinates lngs and lats and returns the temperature vector of equal size at the given pair.\nT = 250*cos(Z)^1/4 + 100 on the Sun-side, and T = 100 on the night-side, in kelvin.\n\n\n\n\n\n\n\n\n\n\nlunar_surface_temperatures_HURLEY2015 – Struct\n\n\n\n\n\n[1] lunar_surface_temperatures_HURLEY2015(lng::Real, lat::Real)\n[2] lunar_surface_temperatures_HURLEY2015(lngs::AbstractVector, lats::AbstractVector; matrix=true)\n[3] lunar_surface_temperatures_HURLEY2015(xs::GlobalSphericalPosition)\n[3] lunar_surface_temperatures_HURLEY2015(XS::Vector{GlobalSphericalPosition})\n[4] lunar_surface_temperatures_HURLEY2015(grid::Abstract2DGrid)\nCalculates the lunar surface temperatures based on the analytic formula given in Hurley et al. 2015. All angular arguments are in radians."
  },
  {
    "objectID": "api/base/constants.html#usage",
    "href": "api/base/constants.html#usage",
    "title": "Constants",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/constants.html#api",
    "href": "api/base/constants.html#api",
    "title": "Constants",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nBase - Constants\n\n\n\n\n\nAVOGADRO_CONSTANT:         6.022141e+23 [mol-1]\nBOLTZMANN_CONSTANT:        1.380650e-23 [m2 kg s-2 K-1]\nELEMENTARY_CHARGE:         1.602177e-19 [C]\nGRAVITATIONAL_CONSTANT:    6.674080e-11 [m3 kg-1 s-2]\nPLANCK_CONSTANT:           6.626070e-34 [m2 kg s-1]\nSTEFAN_BOLTZMANN_CONSTANT: 5.670000e-08 [W m-2 K-4]\nUNIVERSAL_GAS_CONSTANT:    8.314463e+00 [J K-1 mol-1]\n\n\n\n\n\n\n\n\n\n\nBase - Constants - The Moon\n\n\n\n\n\nLUNAR_DAY:                 2.548800e+06 [s]\nLUNAR_MASS:                7.247673e+22 [kg]\nLUNAR_RADIUS:              1.737400e+06 [m]\nLUNAR_g0:                  1.602472e+00 [m s-2]\nLUNAR_vesc:                2.359718e+03 [m s-1]"
  },
  {
    "objectID": "api/base/distributions.html#type-structure",
    "href": "api/base/distributions.html#type-structure",
    "title": "Distributions",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractDistribution\n    ├─ MaxwellBoltzmannVelocityDistribution\n    └─ MaxwellBoltzmannFluxVelocityDistribution"
  },
  {
    "objectID": "api/base/distributions.html#usage",
    "href": "api/base/distributions.html#usage",
    "title": "Distributions",
    "section": "Usage",
    "text": "Usage\n\nVelocity Distributions\nFor the theoretical description of the velocity distributions, please read the documentation."
  },
  {
    "objectID": "api/base/distributions.html#api",
    "href": "api/base/distributions.html#api",
    "title": "Distributions",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nMaxwellBoltzmannVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannVelocityDistribution()\nEmpty struct defining a (3D) Maxwell-Boltzmann velocity distribution.\n\n\n\n\n\n\n\n\n\n\nMaxwellBoltzmannFluxVelocityDistribution – Struct\n\n\n\n\n\n[1] MaxwellBoltzmannFluxVelocityDistribution()\nEmpty struct defining a (3D) Maxwell-Boltzmann flux velocity distribution.\n\n\n\n\n\nUtility Functions\n\n\n\n\n\n\ncdf – Function\n\n\n\n\n\n[1] cdf(vd::AbstractDistribution, v::Tuple{Real, Real}, T::Real, m::Real; N=1000)\n[2] cdf(vd::AbstractDistribution, v::Real, T::Real, m::Real; kwargs...)\nComputes the cumulative distribution function of the velocity distribution vd based on numerical integration of the respective probability density function between the upper and lower speed given in v (in [m s-1]) (if v is scalar, the lower boundary is zero). Takes the temperature T (in [K]) and the mass m (in [kg]) as arguments to evaluate the MB(F) distributions. The keyword argument N controls the number of numerical integration steps.\n\n\n\n\n\n\n\n\n\n\npdf – Function\n\n\n\n\n\n[1] pdf(::AbstractDistribution, v::Real, T::Real, m::Real)\nCalculates the probability density of MB(F) speed distributions, at the speed v (in [m s-1]), given the temperature T (in [K]), and the mass m (in [kg]).\n\n\n\n\n\n\n\n\n\n\nsample – Function\n\n\n\n\n\n[1] sample([S::Type], ::AbstractDistribution, T::Real, m::Real; dims=3)\nSamples the dims-dimensional velocity distribtion, given the temperature T in [K], and the mass m in [kg]. Returns the vector as a type S, if specified."
  },
  {
    "objectID": "documentation/sources_sinks/thermal_sorption.html#maxwell-boltzmann-distribution",
    "href": "documentation/sources_sinks/thermal_sorption.html#maxwell-boltzmann-distribution",
    "title": "4.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Distribution",
    "text": "Maxwell-Boltzmann Distribution\nThe MBD (Maxwell-Boltzmann velocity distribution) is a probability distribution function that describes the distribution of velocities and speeds of particles in a gas or liquid. It is intimately connected to the kinetic gas theory, which explains the behavior of gases in terms of the motion of their constituent particles, which is proportional to their temperature.\n\n\n MaxwellBoltzmannVelocityDistribution\nThe one-dimensional pdf of the MBD, given for a velocity in the direction \\(x\\), is \\[\\begin{equation}\n   f(v_x)dv_x = \\sqrt{\\frac{m}{2\\pi k_BT}} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x\n   \\label{eq:mbd_1d}\n\\end{equation}\\] with the mass \\(m\\) and available thermodynamic temperature \\(T\\) of the particle, and the Boltzmann constant \\(k_B\\), properly normalized so that \\(\\int_{-\\infty}^\\infty f(v_x)dv_x = 1\\). Note that this distribution is identical to a Gaussian distribution with zero mean and variance of \\(k_BT/ m\\) (Crider & Vondrak, 2002; Smolka, 2022).\nOne can extend the distribution to three cartesian dimensions, with the velocity vector \\(\\boldsymbol{\\mathbf{v}}= \\left[v_x, v_y, v_z\\right]^T\\) and \\(d^3\\boldsymbol{\\mathbf{v}}= dv_xdv_ydv_z\\), by linearly combining all three pdf given in Eq. \\(\\eqref{eq:mbd_1d}\\) \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbd_3d}\n\\end{equation}\\] with the speed \\(v=\\sqrt{\\boldsymbol{\\mathbf{v}}^T\\boldsymbol{\\mathbf{v}}}\\). Identical to the one-dimensional form of the distribution, the three-dimensional one is based on a symmetric Gaussian distribution with zero mean. In order to convert it into a distribution of speeds, Eq. \\(\\eqref{eq:mbd_3d}\\) can be integrated twice over arbitrary solid angles, utilizing its symmetry. For this, the differential will be expressed in spherical coordinates \\(\\boldsymbol{\\mathbf{v}}\\left(v, \\vartheta, \\varphi\\right) = \\left[ v\\cos\\vartheta\\cos\\varphi,\\, v\\sin\\vartheta\\cos\\varphi,\\, v\\sin\\varphi\\right]^T\\), leading to the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) with \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\), which results in \\[\\begin{equation}\n    f(v)dv= \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv. \\label{eq:mbd_speed_3d}\n\\end{equation}\\]\n\n\n cdf: integrated Eq. \\(\\eqref{eq:mbd_speed_3d}\\)   pdf: Eq. \\(\\eqref{eq:mbd_speed_3d}\\)\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann velocity distribution.\n\n\n\nEquation \\(\\eqref{eq:mbd_3d}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n        f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n        &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot\\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_{-\\infty}^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\quad\\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\;\\quad f(\\varphi) \\, d\\varphi\\quad\\cdot && \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} &\\cdot& \\quad \\overbrace{\\frac{1}{2}\\cos\\varphi\\; d\\varphi} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta}\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{0}^\\infty f(v) dv= \\int_{-\\pi/2}^{\\pi/2} f(\\varphi) d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\, d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional as well as their components are normalized.\n\n\n\n\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\nFigure 1: Normalized Maxwell-Boltzmann velocity and speed distributions according to Eqs. \\(\\eqref{eq:mbd_1d}\\), \\(\\eqref{eq:mbd_speed_3d}\\). For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbd_most_probable_speed}\\), \\(\\eqref{eq:mbd_mean_speed}\\), \\(\\eqref{eq:mbd_rms}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \nfunction mbd(name=\"mbd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbd1d  = sqrt(1/2/pi) .* exp.(-x1.^2 ./ 2)\n    mbd3d  = 4*pi*(1/2/pi)^1.5 .* x2.^2 .* exp.(-x2.^2 ./ 2)\n    mbd1d2 = 2*sqrt(1/2/pi) .* exp.(-x2.^2 ./ 2)\n\n    # plot distributions\n    lines!(ax, x1, mbd1d; color=TUMBlueDark)\n    lines!(ax, x2, mbd1d2; color=TUMBlueLight)\n    lines!(ax, x2, mbd3d; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(2);            fvp = 4*pi*(1/2/pi)^1.5*vp^2*exp(-vp^2/2)\n    vmean = 2/sqrt(pi) * vp; fvmean = 4*pi*(1/2/pi)^1.5*vmean^2*exp(-vmean^2/2)\n    vrms = sqrt(1.5) * vp;   fvrms = 4*pi*(1/2/pi)^1.5*vrms^2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*1.1, fvrms*1.01; text=\"root mean squared\", align=ALGN, fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBD\", \"1D-MBD, one-directional\", \"3D-MBD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbd.pdf   mbd.svg   mbd.png \n\n\n\n\n\nFigure 1 shows three normalized MBDs, using the mass \\(m\\) and temperature \\(T\\) for the normalization. The one-dimensional distribution (1D-MBD) according to Eq. \\(\\eqref{eq:mbd_1d}\\) shows the symmetric normal distribution, as the normalization \\(\\sqrt{m/ (k_BT)} = 1\\,\\mathrm{s/m}\\) leads to a Gaussian distribution with zero mean and unit variance. The second one-dimensional distribution (1D-MBD, one-directional) is showing the same equation but in its one-directional form, leading to only positive velocities. Mathematically, this operation changes the integration boundaries for the elevation angle \\(\\varphi\\) to \\(\\left(0, \\pi/2\\right)\\), which in turn leads to a doubling of the prefactor to assure pdf normalization: \\[\\begin{equation}\n    f_+(v_x)dv_x = \\begin{cases}\n        2 \\cdot f(v_x) dv_x, & \\quad v_x \\geq 0\\,\\mathrm{m/s}, \\\\\n        0, & \\quad \\text{else.}\n    \\end{cases}\n    \\label{eq:mbd_1d+}\n\\end{equation}\\] These one-directional forms of the MBD are helpful for velocities where one direction is obstructed, for example when launching particles from a surface, where a movement downwards into the ground is not physical. The third distribution (3D-MBD, speed) is presenting the graph of Eq. \\(\\eqref{eq:mbd_speed_3d}\\). Note that, as with the graph before, this distribution is also one-directional, though in this case, it is by nature, since the speed in the spherical coordinate system description can only assume a positive value. Additionally, the speed distribution has three indicated and typical speeds shown, which will be explained in the following.\n\nTypical Speeds\nOne of those typical speeds obtained from properties of the MBD is the most probable speed, \\(v_p\\), which describes the speed at which Eq. \\(\\eqref{eq:mbd_speed_3d}\\) reaches its maximum value. Since the pdf is normalized, we can infer that it must have at least one global extreme point at which its derivative equals zero: \\[\\begin{equation}\n   \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad\\Rightarrow\\qquad v_p = \\sqrt{\\frac{2k_BT}{m}}.\n    \\label{eq:mbd_most_probable_speed}\n\\end{equation}\\]\nAnother typical value that can be drawn from a distribution is the mean speed \\(\\langle v \\rangle\\), being the ensemble expectation according to Eq. \\(\\eqref{eq:ensemble_average}\\). For the speed distribution, the expected value can be calculated by the speed-weighted average of the distribution: \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty v\\; f(v) \\; dv= \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n    \\label{eq:mbd_mean_speed}\n\\end{equation}\\] Note that the expected speed \\(\\langle v \\rangle\\) of the distribution is not equal to the median \\(m\\) of the distribution, for which the expression \\(\\int_0^m f(v) dv\\) evaluates to .\nLastly and similar to the mean speed, the mean square speed \\(\\langle v^2 \\rangle\\) is an important value describing the distribution. As the second-order raw moment, it corresponds to the average kinetic energy of a particle and can be translated into the root mean squared speed \\(v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle}\\): \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n    \\label{eq:mbd_rms}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} = \\frac{d}{dv} \\left[ \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot 4\\pi v^2 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) \\right]_{v_p} &= 0 \\\\\n    %\\Rightarrow\\quad &&\\; \\frac{d}{d\\velocity} \\Big[ \\velocity^2 \\cdot \\exp\\left( -a\\velocity^2\\right) \\Big]_{\\velocity_p} &= 0  \\\\\n     \\Rightarrow\\quad &&\\; 2v_p \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^3 \\cdot \\exp\\left( -av_p^2 \\right) &= 0  \\\\\n     \\Rightarrow\\quad &&\\; v_p = \\sqrt{\\frac{1}{a}} &= \\sqrt{\\frac{2k_BT}{m}}\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\): \\[\\begin{align*}\n    \\langle v \\rangle &= \\int_0^\\infty v\\; f(v) \\; dv= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\int_0^\\infty v^3 \\cdot \\exp\\left( - a v^2 \\right)dv\\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ - \\frac{\\left(av^2 + 1\\right) \\cdot \\exp\\left(-av^2\\right)}{2a^2} \\right]_0^\\infty \\\\\n    %\\Rightarrow \\quad \\meanof{\\velocity} &= 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[\\frac{1}{2a^2} \\right] \\\\\n    \\Rightarrow \\quad \\langle v \\rangle &= \\sqrt{\\frac{4}{\\pi a}} = \\sqrt{\\frac{8k_BT}{\\pi m}} = \\frac{2}{\\sqrt{\\pi}} v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbd_rms}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function: \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_o^\\infty v^2 f(v) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}\\cdot\\mathop{\\mathrm{erf}}{\\left(\\sqrt{a}v\\right)}}{8a^{5/2}} - \\frac{v\\exp\\left(-av^2\\right)\\cdot\\left(2av^2+3\\right)}{4a^2} \\right]_0^\\infty \\right)^{1/2}  \\\\\n    %\\Rightarrow\\quad \\velocity_\\text{rms} &= \\left( 4\\pi\\left(\\frac{a}{\\pi}\\right)^{3/2} \\cdot \\left[ \\frac{3\\sqrt{\\pi}}{8a^{5/2}} \\right]\\right)^{1/2}  \\\\\n    \\Rightarrow\\quad v_\\text{rms} &= \\sqrt{\\frac{3}{2a}} = \\sqrt{\\frac{3k_BT}{m}} = \\sqrt{\\frac{3}{2}} v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 1: Overview of normalized speeds \\(v\\) of the MBD, according to Eq. \\(\\eqref{eq:mbd_speed_3d}\\), including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(v_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(v_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = sqrt(1/2/pi)^3 * 4 * pi * v^2 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(2)\n    vm = sqrt(8/pi)\n    vr = sqrt(3)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\",\"\",\"\",raw\"$\\approx\\sqrt{4/\\pi}$\",raw\"$\\approx\\sqrt{3/2}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{\\pi/4}$\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\",raw\"$\\approx\\sqrt{2/3}$\",\"\",raw\"$\\approx\\sqrt{8/3\\pi}$\",\"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n    \n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbd_typical_speeds.md\", \"w\")\n    write(fid, maketable(), \"\\\\\\\\\"=&gt;\"\\\\\")\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\n\n\nNumrical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBD velocity, then any realization of \\(\\boldsymbol{\\mathbf{V}}\\) can be drawn from the respective pdf, in this case Eq. \\(\\eqref{eq:mbd_3d}\\), \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) =  \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right).\n\\end{equation}\\] Numerically speaking, to draw any realization from a randomly distributed variable, the latter has to be mapped on to one implemented state space, which in the most basic cases is a uniform distribution with the random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u \\sim f(r_u) = 1\\) and a normal distribution with the random variable \\(R_n\\in\\left(-\\infty,\\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n |\\mu,\\sigma^2\\right)\\) with zero mean and unit variance. Since \\(\\boldsymbol{\\mathbf{V}}\\) is three-dimensional, each individual dimension requires its own mapping. In its cartesian form, \\(\\boldsymbol{\\mathbf{V}}=\\left(V_x, V_y, V_z\\right)\\), all three components are equal to a scaled normal distrinbution, which can be used directly as \\[\\begin{alignat}{3}\n    V_i &= R_n \\cdot \\sqrt{\\frac{k_BT}{m}} \\; \\sim \\; \\mathcal{N} \\left(v_i \\Big| 0, \\frac{k_BT}{m}\\right) \\qquad && \\forall i \\in \\{x, y, z\\} \\label{eq:mbd_random_cartesian_component_2} \\\\\n    \\Rightarrow\\qquad v_i &= r_n \\cdot \\sqrt{\\frac{k_BT}{m}} \\qquad &&\\forall i \\in \\{x,y,z\\}.\n    \\label{eq:mbd_random_cartesian_component}\n\\end{alignat}\\] Should one dimension be one-directional, the absolute value \\(|r_n|\\) can be used iun Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\) instead.\nThe random variable \\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in its spherical form, with its three components the speed \\(V_v\\in \\left[0,\\infty\\right)\\) with realization \\(v\\) of \\(V_v\\sim f(v)\\), the elevation angle \\(V_\\varphi\\in \\left[-\\pi/2, \\pi/2\\right]\\) with realization \\(\\varphi\\) of \\(V_\\varphi\\sim f(\\varphi) = 1/2 \\cdot \\cos\\varphi\\), and the azimuth angle \\(V_\\vartheta\\in \\left[-\\pi,\\pi\\right)\\) with realization \\(\\vartheta\\) of \\(V_\\vartheta\\sim f(\\vartheta) = 1/2\\pi\\). Similar to the cartesian description above, these three random variables can be mathed to one of the numerically implemented distributions. Because all three pdfs of the random variables are normalized, their cdf can be set equal to the cdf of the uniform unit distribution \\(R_u \\sim f(r_u) = 1\\): \\[\\begin{alignat}{4}\n    r_v&= \\int_0^{r_v} f(r_u)dr_u &&= \\int_0^{v} f(\\tilde v) d\\tilde v\\label{eq:mbd_speed_random}\\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u)dr_u &&= \\int_{-\\pi/2}^{\\varphi} f(\\tilde\\varphi) d\\tilde\\varphi&&= \\frac{1}{2}\\left(\\sin\\varphi+ 1\\right) \\label{eq:mbd_elevation_random}\\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u)dr_u &&= \\int_{-\\pi}^{\\vartheta} f(\\tilde\\vartheta) d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}, \\label{eq:mbd_azimuth_random}\n\\end{alignat}\\] where the speed distribution is equal to Eq. \\(\\eqref{eq:mbd_speed_3d}\\). With the latter two integrals being trivial, the speed integral of Eq. \\(\\eqref{eq:mbd_speed_random}\\) evaluates to: \\[\\begin{equation}\n   r_v= \\mathop{\\mathrm{erf}}\\left( \\sqrt{\\frac{mv^2}{2k_BT}} \\right) - \\frac{2}{\\sqrt{\\pi}} \\cdot \\sqrt{\\frac{mv^2}{2k_BT}} \\cdot \\exp\\left( - \\frac{mv^2}{2k_BT}\\right).\n   \\label{eq:mbd_speed_random_evaluated}\n\\end{equation}\\] Due to the combination of the Gaussian error function \\(\\mathop{\\mathrm{erf}}\\) and an exponential function \\(\\exp\\), there is no elementary analytical expression of \\(v\\) as a function of \\(r_v\\). Thus, for numerical implementations Eq. \\(\\eqref{eq:mbd_speed_random_evaluated}\\) is usually pre-evaluated several times to build up an interpolation table that maps any uniform random \\(r_v\\) to a speific MBD speed. The other two components, see Eqs. \\(\\eqref{eq:mbd_elevation_random}\\), \\(\\eqref{eq:mbd_azimuth_random}\\), show that the elevation angle \\(\\varphi\\) is \\(\\sin\\)-distributed, while the azimuth angle \\(\\vartheta\\) is uniformly distributed.\n\n\n sample: Eq. \\(\\eqref{eq:mbd_random_cartesian_component}\\)"
  },
  {
    "objectID": "documentation/sources_sinks/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "href": "documentation/sources_sinks/thermal_sorption.html#maxwell-boltzmann-flux-distribution",
    "title": "4.2 Thermal Sorption",
    "section": "Maxwell-Boltzmann Flux Distribution",
    "text": "Maxwell-Boltzmann Flux Distribution\nThe MBFD (Maxwell-Boltzmann flux velocity distribution) is a modified three-dimensional MBD, which is based on the upwards flux governed by the upwards velocity component. It is calculated by multiplying Eq. \\(\\eqref{eq:mbd_3d}\\) by this additional velocity component and re-normalizing the pdf (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022). Let \\(n\\) be a velocity-independent normalization factor, and \\(v_z &gt; 0\\) the upwards velocity component, then the three-dimensional form of the MBFD can be written as \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= n \\cdot \\left(\\frac{m}{2\\pi k_BT}\\right)^{3/2} \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}}.\n    \\label{eq:mbfd_raw}\n\\end{equation}\\]\n\n MaxwellBoltzmannFluxVelocityDistribution\n\nTo calculate the normalization factor \\(n\\), the flux distribution can be integrated over spherical coordinates and set to unity, with the differential \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\vartheta\\, d\\varphi\\) and domains \\(v\\in\\mathbb{R}^+\\), \\(\\varphi\\in\\left[-\\pi/2, \\pi/2\\right)\\), and \\(\\vartheta\\in\\left[-\\pi,\\pi\\right)\\). After solving the three-dimensional integral, the normalization factor can be derived to \\[\\begin{equation}\n     n = 2\\pi\\sqrt{\\frac{m}{2\\pi k_BT}},\n    \\label{eq:mbfd_normalization_factor}\n\\end{equation}\\] which can be included in the original description of the MBFD, given in Eq. \\(\\eqref{eq:mbfd_raw}\\), leading to \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd}\n\\end{equation}\\] in cartesian coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x \\, dv_y \\, dv_z\\), or \\[\\begin{equation}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}= \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v\\sin\\varphi\\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) d^3\\boldsymbol{\\mathbf{v}},\n    \\label{eq:mbfd_spherical}\n\\end{equation}\\] in spherical coordinates with \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dv\\, d\\varphi\\, d\\vartheta\\) (Armand, 1977; Brinkmann, 1970; Schörghofer, 2022; Smith et al., 1978).\n\n\n cdf: integrated Eq. \\(\\eqref{eq:mbfd_speed}\\)   pdf: Eq. \\(\\eqref{eq:mbfd_speed}\\)\n\n\n\n\n\n\n\nCartesian and spherical components of the Maxwell-Boltzmann Flux velocity distribution.\n\n\n\nEquations \\(\\eqref{eq:mbfd}\\) and \\(\\eqref{eq:mbfd_spherical}\\) can be devided into its three components of the respective coordinate system. Note that every component is representing a normalized pdf itself.\nFirst, for cartesian coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= dv_x dv_y dv_z\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v_x) dv_x &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_y) dv_y &\\cdot& \\quad\\qquad\\qquad\\qquad f(v_z) dv_z \\\\\n    &= \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_x^2}{2k_BT}\\right) dv_x} &\\cdot& \\; \\overbrace{\\left(\\frac{m}{2\\pi k_BT}\\right)^{1/2} \\cdot \\exp\\left(-\\frac{mv_y^2}{2k_BT}\\right) dv_y} &\\cdot& \\; \\overbrace{2\\pi v_z \\left(\\frac{m}{2\\pi k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) dv_z},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_{-\\infty}^\\infty f(v_x) dv_x = \\int_{-\\infty}^\\infty f(v_y) dv_y = \\int_0^\\infty f(v_z) dv_z = 1.\n\\end{equation*}\\]\nSecond, for spherical coordinates \\(d^3\\boldsymbol{\\mathbf{v}}= v^2 \\cos\\varphi\\, dvd\\varphi d\\vartheta\\): \\[\\begin{alignat*}{6}\n    f(\\boldsymbol{\\mathbf{v}})d^3\\boldsymbol{\\mathbf{v}}&= \\qquad\\qquad\\qquad f(v) \\, dv&\\cdot& \\quad f(\\varphi) \\, d\\varphi&\\cdot& \\;\\quad f(\\vartheta) \\, d\\vartheta\\\\\n    &= \\overbrace{2\\cdot\\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv} \\; &\\cdot& \\quad \\overbrace{2\\sin\\varphi\\cos\\varphi\\; d\\varphi\\phantom{\\frac{1}{1}}} &\\cdot& \\quad \\overbrace{\\frac{1}{2\\pi} \\; d\\vartheta},\n\\end{alignat*}\\] with \\[\\begin{equation*}\n    \\int_0^\\infty f(v) dv= \\int_0^{\\pi/2} f(\\varphi) \\;d\\varphi= \\int_{-\\pi}^{\\pi} f(\\vartheta) \\; d\\vartheta= 1.\n\\end{equation*}\\] Note that all three-dimensional pdfs as well as their components are normalized.\n\n\n\nThrough integration over the solid angles of Eq. \\(\\eqref{eq:mbfd_spherical}\\), the MBFD speed distribution emerges as \\[\\begin{equation}\n    f(v)dv=  2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_speed}\n\\end{equation}\\] Note that the scaling factor \\(2\\) is a result from the integration over half the sphere through \\(\\varphi\\in\\left(0,\\pi/2\\right)\\). As before, this speed distribution can be analyzed to extract some typical speeds from it.\n\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n\nFigure 2: Normalized Maxwell-Boltzmann flux velocity and speed distributions according to Eq. \\(\\eqref{eq:mbfd_speed}\\). The 1D-MBFD distribution is perpendicular to the flux direction, 1D-MBFD, flux is parallel to the flux direction. For the distribution of speeds, the typical speeds according to Eqs. \\(\\eqref{eq:mbfd_most_probable_speed}\\), \\(\\eqref{eq:mbfd_mean_speed}\\), \\(\\eqref{eq:mbfd_rms_speed}\\) are shown. The velocities and speeds have been normalized according with \\(\\sqrt{m/k_BT} = 1\\,\\mathrm{s/m}\\).\n\n\n\n\nusing CairoMakie, Colors, ColorSchemes\n\nTUMBlack = colorant\"#000000\"\nTUMBlueDark = colorant\"#005293\"\nTUMBlueLight = colorant\"#64A0C8\"\n    \n\nfunction mbfd(name=\"mbfd\"; txt=true)\n\n    # prep figure\n    fig = Figure()\n    ax = Axis(fig[1,1];\n        xlabel=\"Normalized Velocity [-]\",\n        xticks=-6:2:6,\n        ylabel=\"Probability Density [-]\")\n\n    # distributions\n    x1, x2 = -4:0.01:5, 0:0.01:5\n    mbfdx  = sqrt(1/2/pi) * exp.(- x1.^2 ./ 2)\n    mbfdz  = x2 .* exp.(- x2.^2 ./ 2)\n    mbfdv  = x2.^3 ./ 2 .* exp.(- x2.^2 ./ 2)\n\n    \n    # plot distributions\n    lines!(ax, x1, mbfdx; color=TUMBlueDark)\n    lines!(ax, x2, mbfdz; color=TUMBlueLight)\n    lines!(ax, x2, mbfdv; color=TUMBlack)\n\n    # typical speeds (3d)\n    vp = sqrt(3);         fvp = vp^3/2*exp(-vp^2/2)\n    vmean = sqrt(9*pi/8); fvmean = vmean^3/2*exp(-vmean^2/2)\n    vrms = sqrt(2);       fvrms = vrms^3/2*exp(-vrms^2/2)\n\n    # plot typical speeds (3d)\n    scatter!(ax, [vp, vmean, vrms], [fvp, fvmean, fvrms]; \n        color=TUMBlack, markersize=10, strokewidth=2, strokecolor=:white)\n\n    if txt\n        ALGN, FS = (:left, :center), 10\n        text!(ax, vp*1.1, fvp*1.03; text=\"most probable\", align=ALGN, fontsize=FS)\n        text!(ax, vmean*1.1, fvmean*1.005; text=\"mean\", align=ALGN, fontsize=FS)\n        text!(ax, vrms*0.9, fvrms*1.0; text=\"root mean squared\", align=(:right, :center), fontsize=FS)\n    end\n\n    lines!(ax, [vp,vp], [0,fvp]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vmean,vmean], [0,fvmean]; color=TUMBlack, linestyle=:dash)\n    lines!(ax, [vrms,vrms], [0,fvrms]; color=TUMBlack, linestyle=:dash)\n\n    # add legend\n    lx = LineElement(color=TUMBlueDark, linestyle=:solid, linewidth=3)\n    lz = LineElement(color=TUMBlueLight, linestyle=:solid, linewidth=3)\n    lv = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    axislegend(ax, \n        [lx,lz,lv], \n        [\"1D-MBFD\", \"1D-MBFD, flux\", \"3D-MBFD, speed\"], \n        framevisible=false,\n        position=:lt)\n\n    # save figure\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n mbfd.pdf   mbfd.svg   mbfd.png \n\n\n\n\n\nFigure 2 shows the probability densities of three MBFD distributed, normalized velocities. The normalization of the velocities has been performed with \\(\\sqrt{m/k_BT} = 1\\). The 1D-MBFD curve is showing the pdf of a velocity component perpendicular to the flux direction, which is equal to one-dimensional MBD velocities, see Eq. \\(\\eqref{eq:mbd_1d}\\), which in fact is equal to the scaled normal distribution \\(\\mathcal{N}(0, k_BT/m)\\). The second graph, 1D-MBFD, flux shows the distribution of a directed velocity component in flux direction, \\(f_\\parallel(v)\\), which is equal to \\[\\begin{equation}\n    f_\\parallel (v) dv= 2v\\left(\\frac{m}{2k_BT}\\right) \\cdot \\exp\\left(-\\frac{mv^2}{2k_BT}\\right) dv.\n    \\label{eq:mbfd_1d_parallel}\n\\end{equation}\\] Last, the graph 3D-MBFD, speed shows the distribution of speeds of the three-dimensional form, given in Eq. \\(\\eqref{eq:mbfd_speed}\\). For the latter, the three typical speeds, the most probable speed \\(v_p\\), the mean speed \\(\\langle v \\rangle\\) or the expected speed, and the root mean squared speed \\(v_\\text{rms}\\), which are derived in the following. Note that, contrary to the MBD, the root mean squared speed is lower than the other two typical speeds, due to its additional speed dependency, which is shifting the entire distribution to higher values and, thus, to \\(f(v\\approx 0.0) \\approx 0.0\\).\n\nTypical Speeds\nThe most probable speed occurs at the maximum likelihood of the Eq. \\(\\eqref{eq:mbfd_speed}\\): \\[\\begin{equation}\n    \\left. \\frac{df(v)}{dv}\\right|_{v_p} = 0 \\qquad \\Rightarrow \\qquad v_p = \\sqrt{\\frac{3k_BT}{m}}.\n    \\label{eq:mbfd_most_probable_speed}\n\\end{equation}\\]\nThe expected value of the speed distribution, the mean speed \\(\\langle v \\rangle\\) is calculated by using the ensemble average equation, shown in Eq. \\(\\eqref{eq:ensemble_average}\\): \\[\\begin{equation}\n    \\langle v \\rangle = \\int_0^\\infty vf(v) dv= \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}} \\,\\cdot v_p.\n    \\label{eq:mbfd_mean_speed}\n\\end{equation}\\]\nLastly, the speed is calculated as \\[\\begin{equation}\n    v_\\text{rms} = \\sqrt{\\langle v^2 \\rangle} = \\left( \\int_0^\\infty v^2 f(v)dv\\right)^{1/2} = \\sqrt{\\frac{2k_BT}{m}} = \\sqrt{\\frac{2}{3}}\\,\\cdot v_p.\n    \\label{eq:mbfd_rms_speed}\n\\end{equation}\\]\n\n\n\n\n\n\n\nDerivation of typical speeds of the Maxwell-Boltzmann flux distribution.\n\n\n\nFirst, the derivation of Eq. \\(\\eqref{eq:mbfd_most_probable_speed}\\), with the most probable speed denoted as \\(v_p\\). Let \\(a = \\frac{m}{2k_BT}\\) and assuming that \\(v_p &gt; 0\\): \\[\\begin{alignat*}{3}\n    && \\left. \\frac{df(v)}{dv}\\right|_{v_p} =\\; \\frac{d}{dv} \\left[ 2 \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v^3 \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\\right]_{v_p} &= 0 \\\\\n    \\Rightarrow && \\left[3v_p^2 \\cdot \\exp\\left( -av_p^2 \\right) - 2av_p^4 \\cdot \\exp\\left( -av_p^2 \\right) \\right] &= 0 \\nonumber \\\\\n    \\Rightarrow &&\\; v_p = \\sqrt{\\frac{3}{2a}} &= \\sqrt{\\frac{3k_BT}{m}}.\n\\end{alignat*}\\]\nSecond, the derivation of Eq. \\(\\eqref{eq:mbfd_mean_speed}\\), with the mean speed denoted as \\(\\langle v \\rangle\\). Let \\(a = \\frac{m}{2k_BT}\\): \\[\\begin{align*}\n    % \\meanof{\\velocity} &= \\int_0^\\infty \\velocity f(\\velocity) d\\velocity = 2 \\left(\\frac{\\mass}{2\\BoltzmannConstant\\temperature}\\right)^2 \\cdot \\int_0^\\infty \\velocity^4 \\exp\\left(-\\frac{\\mass\\velocity^2}{2\\BoltzmannConstant\\temperature}\\right) d\\velocity = 2 a^2 \\int_0^\\infty \\velocity^4 \\exp\\left(- a\\velocity^2\\right) d\\velocity \\\\\n    \\langle v \\rangle &= \\int_0^\\infty vf(v) dv= 2 a^2 \\int_0^\\infty v^4 \\exp\\left(- av^2\\right) dv\\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\left[ \\frac{3\\sqrt{\\pi}\\mathop{\\mathrm{erf}}\\left(\\sqrt{a}v\\right)}{4\\sqrt{a}} - \\frac{v\\exp\\left(-av^2\\right) \\cdot \\left(2av^2 + 3\\right)}{2} \\right]_0^\\infty \\\\\n    \\Rightarrow\\qquad \\langle v \\rangle &= \\sqrt{\\frac{9\\pi}{16a}} = \\sqrt{\\frac{9\\pi k_BT}{8m}} = \\sqrt{\\frac{3\\pi}{8}}\\,\\cdot v_p.\n\\end{align*}\\]\nThird and last, the derivation of Eq. \\(\\eqref{eq:mbfd_rms_speed}\\), with the root mean squared speed denoted as \\(v_\\text{rms}\\). Let \\(a = \\frac{m}{2k_BT}\\), and \\(\\mathop{\\mathrm{erf}}\\) the Gaussian error function: \\[\\begin{align*}\n    v_\\text{rms} &= \\sqrt{\\langle v^2 \\rangle} = \\left(\\int_0^\\infty v^2 f(v) dv\\right)^{1/2} = \\left( \\int_0^\\infty 2a^2 v^5 \\exp\\left(-av^2\\right) dv\\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left( \\left[-\\frac{\\exp\\left(-av^2\\right) \\left(a^2v^4 + 2av^2 + 2 \\right)}{a}\\right]_0^\\infty \\right)^{1/2} \\\\\n    \\Rightarrow\\qquad v_\\text{rms} &= \\left(\\frac{2}{a}\\right)^{1/2} = \\sqrt{\\frac{2k_BT}{m}} = \\sqrt{\\frac{2}{3}}\\,\\cdot v_p.\n\\end{align*}\\]\n\n\n\n\n\n Table Julia Downloads\n\n\n\n\nTable 2: Overview of normalized speeds \\(v\\) of the MBFD, according to Eq. , including a comparison with its typical speeds, the most probable speed, \\(v_p\\), the mean speed, \\(\\langle v \\rangle\\), and the root mean squared speed, \\(v_\\text{rms}\\).\n\n\n\\(v\\)\n\\(\\int_0^vf(v)dv\\)\n\\(v/ \\sqrt{\\frac{k_BT}{m}}\\)\n\\(v/ v_p\\)\n\n\\(v/ \\langle v \\rangle\\)\n\n\\(v/ v_\\text{rms}\\)\n\n\n\n\n\n\\(v_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.98\\)\n\n\n\n\\(v_\\text{rms}\\)\n\\(0.264\\)\n\\(1.414\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\\(0.752\\)\n\\(\\approx\\sqrt{16/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(v_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\n\n\\(v_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(1.295\\)\n\n\n\n\\(\\langle v \\rangle\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(1.329\\)\n\\(\\approx\\sqrt{9\\pi/16\\pi}\\)\n\n\n\\(v_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.641\\)\n\n\n\n\\(v_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.972\\)\n\n\n\n\\(v_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(2.178\\)\n\n\n\n\\(v_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(2.576\\)\n\n\n\n\\(v_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(3.039\\)\n\n\n\n\n\n\n\nusing PrettyTables\n\n#::. functions\nfunction maketable()\n    # speed distribution, normalized\n    f(v) = sqrt(1/2/pi)^3 * 4 * pi * v^2 * exp(- v^2 / 2)\n\n    # typical speeds, normalized\n    vp = sqrt(2)\n    vm = sqrt(8/pi)\n    vr = sqrt(3)\n\n    # integrals for typical speeds\n    dv = 1e-4\n    Fvp = sum(f(vi)*dv for vi in 0:dv:vp)\n    Fvm = sum(f(vi)*dv for vi in 0:dv:vm)\n    Fvr = sum(f(vi)*dv for vi in 0:dv:vr)\n\n    # integral speeds\n    F = [0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.999]\n    v = [_findv(f, F[i]; dv=dv) for i in eachindex(F)]\n\n    # prep table data\n    FF = vcat(F, [Fvp, Fvm, Fvr])\n    V = vcat(v, [vp, vm, vr])\n    Vvp = V./vp\n    Vvm = V./vm\n    Vvr = V./vr\n    \n    # sorting\n    idx_sorted = [1,8,2,9,10,3,4,5,6,7]\n    FF = FF[idx_sorted]\n    V = V[idx_sorted]\n    Vvp = Vvp[idx_sorted]\n    Vvm = Vvm[idx_sorted]\n    Vvr = Vvr[idx_sorted]\n\n    Vstr = [\n        raw\"$\\velocity_{25}$\",\n        raw\"$\\velocity_p$\",\n        raw\"$\\velocity_{50}$\",\n        raw\"$\\meanof{\\velocity}$\",\n        raw\"$\\velocity_\\text{rms}$\",\n        raw\"$\\velocity_{75}$\",\n        raw\"$\\velocity_{90}$\",\n        raw\"$\\velocity_{95}$\",\n        raw\"$\\velocity_{99}$\",\n        raw\"$\\velocity_{99.9}$\",\n    ]\n\n    # additional columns for analytically exact values\n    Vvp_extra = [\"\",\"\",\"\",raw\"$\\approx\\sqrt{4/\\pi}$\",raw\"$\\approx\\sqrt{3/2}$\",\"\", \"\", \"\", \"\", \"\"]\n    Vvm_extra = [\"\", raw\"$\\approx\\sqrt{\\pi/4}$\", \"\", \"\", raw\"$\\approx\\sqrt{3\\pi/8}$\", \"\", \"\", \"\", \"\", \"\"]\n    Vvr_extra = [\"\",raw\"$\\approx\\sqrt{2/3}$\",\"\",raw\"$\\approx\\sqrt{8/3\\pi}$\",\"\", \"\", \"\", \"\", \"\", \"\"]\n\n    # table\n    header = [\n        raw\"$\\velocity$\", \n        raw\"$\\int_0^\\velocity f(\\velocity)d\\velocity$\", \n        raw\"$\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}$\", \n        raw\"$\\velocity / \\velocity_p$\", \"\",\n        raw\"$\\velocity / \\meanof{\\velocity}$\", \"\", \n        raw\"$\\velocity / \\velocity_\\text{rms}$\", \"\"]\n    data = hcat(Vstr, FF, V, Vvp, Vvp_extra, Vvm, Vvm_extra, Vvr, Vvr_extra)\n    \n    # formatter\n    f = (v, i, j) -&gt; !(j in [1,5,7,9]) ? \"\\$$(round(v, digits=3))\\$\" : v\n\n    return pretty_table(String, data; backend=Val(:text), tf=tf_markdown, header=header, alignment=:l, formatters=f)\nend\n\nfunction _findv(f, F; dv=0.0001)\n    v = 0:dv:10\n    SUM = 0\n    for vi in v\n        SUM += f(vi) * dv\n        if SUM &gt;= F; return vi; end\n    end\n    return nothing\nend\n\nfunction writetable()\n    fid = open(\"raw_mbfd_typical_speeds.md\", \"w\")\n    write(fid, maketable())\n    close(fid)\nend\n\n\n\n raw.md \n\n\n\n\n\nTable 2 shows an overview of the speeds of the MBFD and their relation to the typical speeds. The \\(v_{XX}\\) denotes the speed at which the cdf evaluated to \\(F(v_{XX}) = \\int_0^{v_{XX}} f(v) dv= XX\\,\\mathrm{\\%}\\). The entries are sorted by their cdf with the typical speeds highlighted and placed at the correct position. Note that \\(v_{50}\\) denotes the median of the distribution, which is not equal to the expected value \\(\\langle v \\rangle\\).\n\n\nNumerical Sampling\nLet \\(\\boldsymbol{\\mathbf{V}}\\) be the random variable of the MBFD velocity, then any realization can be drawn from the respective pdf: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{V}}\\sim f(\\boldsymbol{\\mathbf{v}}) = \\frac{2}{\\pi} \\cdot \\left(\\frac{m}{2k_BT}\\right)^2 \\cdot v_z \\cdot \\exp\\left( -\\frac{mv^2}{2k_BT}\\right)\n\\end{equation}\\] given in cartesian coordinates, see Eq. \\(\\eqref{eq:mbfd}\\) and Eq. \\(\\eqref{eq:mbfd_spherical}\\) for the function in spherical coordinates. Similar to the MBD, the numerical sampling of the random variable can be performed by mapping each random component to one implemented numerical distribution. As a reminder, the most basic numerical distributions are the uniform distribution with random variable \\(R_u\\in\\left[0,1\\right]\\) with realization \\(r_u\\) of \\(R_u\\sim f(r_u)=1\\) and a normal distribution with random variable \\(R_n\\in\\left(-\\infty, \\infty\\right)\\) with realization \\(r_n\\) of \\(R_n\\sim f(r_n) = \\mathcal{N}\\left(r_n | 0, 1 \\right)\\) with zero mean and unit variance.\nIn cartesian coordinates, with \\(\\boldsymbol{\\mathbf{V}}= \\left(V_x, V_y, V_z\\right)\\), three first two directions are assumed to be perpendicular to the flux, while the z-direction is parallel to the flux. Thus, both the x- and the y-component, \\(v_x\\) and \\(v_y\\), can be numerically sampled like in the MBD, which is with scaled normal distributions, see Eqs. \\(\\eqref{eq:mbd_random_cartesian_component_2}\\), \\(\\eqref{eq:mbd_random_cartesian_component}\\). The flux direction is drawing from the \\(f_\\parallel\\) pdf, see Eq. \\(\\eqref{eq:mbfd_1d_parallel}\\), which can not directly translated in either a uniform or a normal distribution. Therefor, the respective cdf, \\(F_\\parallel\\left(v_z\\right)\\), must be matched with the uniform cdf: \\[\\begin{align}\n    r_{v_z} &= \\int_0^{r_{v_z}} f(r_u) dr_u = \\int_0^{v_z} f_\\parallel(v) dv= F_\\parallel\\left(v_z\\right) = 1 - \\exp\\left(-\\frac{mv_z^2}{2k_BT}\\right) \\\\\n    \\Rightarrow\\qquad v_z &= \\sqrt{-\\ln\\left(1-r_{v_z}\\right)\\frac{2k_BT}{m}}.\n    \\label{eq:mbfd_random_cartesian_component}\n\\end{align}\\]\n\\(\\boldsymbol{\\mathbf{V}}\\) can also be expressed in spherical coordinates as \\(\\boldsymbol{\\mathbf{V}}=\\left(V_v, V_\\varphi, V_\\vartheta\\right)\\) with the differential \\(d^3\\boldsymbol{\\mathbf{v}}=v^2 \\, \\cos\\varphi\\, dvd\\varphi d\\vartheta\\). The additional terms are distributed to the respective random variable: \\[\\begin{alignat}{3}\n    V_v&\\sim f(v) && \\qquad\\text{with realization }v, \\\\    \n    V_\\varphi&\\sim f(\\varphi) = 2\\sin\\varphi\\cos\\varphi&& \\qquad\\text{with realization }\\varphi, \\text{ and } \\\\    \n    V_\\vartheta&\\sim f(\\vartheta) = \\frac{1}{2\\pi} && \\qquad\\text{with realization }\\vartheta.\n\\end{alignat}\\] As before, the cdf of the random variables can be set to equal the cdf of the unit uniform distribution: \\[\\begin{alignat}{3}\n    r_v&= \\int_0^{r_v} f(r_u) dr_u = \\int_0^vf(\\tilde v)d\\tilde v, \\\\\n    r_\\varphi&= \\int_0^{r_\\varphi} f(r_u) dr_u = \\int_0^\\varphi f(\\tilde\\varphi)d\\tilde\\varphi&&= 1 - \\cos^2\\varphi, \\\\\n    r_\\vartheta&= \\int_0^{r_\\vartheta} f(r_u) dr_u = \\int_{-\\pi}^\\vartheta f(\\tilde\\vartheta)d\\tilde\\vartheta&&= \\frac{\\vartheta+\\pi}{2\\pi}.\n\\end{alignat}\\] While the latter two integrals are trivial, leading to a cosine-squared dependence of the elevation angle \\(\\varphi\\) and a uniform dependence on the azimuth angle \\(\\vartheta\\), the speed integral evaluates to \\[\\begin{equation}\n    r_v= 1 - \\exp \\left( -\\frac{mv^2}{2k_BT} \\right) \\cdot \\left( \\frac{mv^2}{2k_BT} + 1\\right).\n    \\label{eq:mbfd_random_speed}\n\\end{equation}\\] only \\(\\varphi=\\cos^{-1}\\left(1-r_\\varphi\\right)\\) and \\(\\vartheta= 2\\pi r_\\vartheta- \\pi\\) can both be directly calculated from their respective realization of the uniform unit random variable, as there is no direct inversion of Eq. \\(\\eqref{eq:mbfd_random_speed}\\).\n\n\n\n\n\n sample: Eqs. \\(\\eqref{eq:mbd_random_cartesian_component}\\), \\(\\eqref{eq:mbfd_random_cartesian_component}\\)"
  },
  {
    "objectID": "documentation/sources_sinks/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "href": "documentation/sources_sinks/thermal_sorption/tables/mbfd_typical_speeds/raw_mbfd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.387\\)\n\\(0.801\\)\n\n\\(0.738\\)\n\n\\(0.98\\)\n\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.264\\)\n\\(1.414\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\\(0.752\\)\n\\(\\approx\\sqrt{16/9\\pi}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.442\\)\n\\(1.732\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.832\\)\n\\(1.058\\)\n\n\\(0.975\\)\n\n\\(1.295\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.527\\)\n\\(1.88\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\\(1.329\\)\n\\(\\approx\\sqrt{9\\pi/16\\pi}\\)\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.321\\)\n\\(1.34\\)\n\n\\(1.234\\)\n\n\\(1.641\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.789\\)\n\\(1.61\\)\n\n\\(1.484\\)\n\n\\(1.972\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(3.08\\)\n\\(1.778\\)\n\n\\(1.638\\)\n\n\\(2.178\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.644\\)\n\\(2.104\\)\n\n\\(1.938\\)\n\n\\(2.576\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.297\\)\n\\(2.481\\)\n\n\\(2.286\\)\n\n\\(3.039\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/planetary_measurements/missions.html#projected-surface-number-densities",
    "href": "documentation/planetary_measurements/missions.html#projected-surface-number-densities",
    "title": "3.2 Missions",
    "section": "Projected Surface Number Densities",
    "text": "Projected Surface Number Densities\n\n\n Figure Julia Download\n\n\n\n\n\n\n\n\n(a) Helium surface number densities.\n\n\n\n\n\n\n\n(b) Neon surface number densities.\n\n\n\n\n\n\n\n(c) Argon surface number densities.\n\n\n\nFigure 1: Helium (a), neon (b), and argon (c) surface number densities, based on derived data of the LADEE mission and projected to the surface based on Chamberlain (1963) barometric model. Maximum densities are highlighted with a red marker and the respective numeric value of the surface number density. The data was taken from the PDS (Hine & Delory, 2014). Gray areas indicate lunar nighttime.\n\n\n\n\nusing .ExESS\nusing DataFrames, CSV\nDATA_PATH = joinpath(@__DIR__, \"..\", \"..\", \"data\", \"ladee_data_derived\")\n\n#::. processing functions\nfunction get_file_names()\n    dirs = readdir(DATA_PATH)\n    dirs = filter(x -&gt; occursin(\"20\", x), dirs)\n    files = String[]\n    for dir in dirs\n        new_files = readdir(joinpath(DATA_PATH, dir))\n        new_files = filter(x -&gt; occursin(r\"csv$\", x), new_files)\n        files = vcat(files, joinpath.(dir, new_files))\n    end\n    return files\nend\nfunction get_file_names(element::String)\n    files = get_file_names()\n    files = filter(x -&gt; occursin(lowercase(element), x), files)\n    return files\nend\n\nfunction load_data(file::String)\n    df = DataFrame(CSV.File(joinpath(DATA_PATH, \"$file\")))\n    return df\nend\n\nfunction load_all_data(element::String)\n    files = get_file_names(element)\n    df = DataFrame()\n    for file in files\n        df = vcat(df, load_data(file))\n    end\n    return df\nend\n\nfunction find_max(df::DataFrame)\n    idxs = Int64[]\n    for (idx, val) in enumerate(df[:,14])\n        if !isnan(val); push!(idxs, idx); end\n    end\n    n = df[idxs,14]\n    val, idx = findmax(n)\n    return val, df[idx, 13], df[idx,12]\nend\n\n#::. plotting functions\nfunction plot_lat(element::String; kwargs...)\n    df = load_all_data(element)\n    plot_lat(df, element; kwargs...)\n    return nothing\nend\nfunction plot_lat(df::DataFrame, element::String; stdfilter=1.0, cmap=reverse(ColorSchemes.deep))\n    idxs = df[:,15] ./ df[:,14] .&lt; stdfilter\n\n    #::. figure and axis setup\n    fig = Figure(resolution=(1000,230))\n    ax = MyLTGeoAxis(fig[1, 1];\n        xlabelpadding=30,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax, -30, 30)\n    night_shade(ax)\n\n    #::. data\n    sc = scatter!(ax, df[idxs, 13]/24*360 .- 180, df[idxs, 12];\n        color=df[idxs, 14],\n        colormap=cmap,\n        colorrange=(0, 2e4),\n        markersize=2)\n\n    #::. plot maximum\n    nmax, lonmax, latmax = find_max(df[idxs,:])\n    scatter!(ax, lonmax/24*360 .- 180, latmax; color=\"red\", markersize=10, marker=:utriangle)\n    text!(ax, lonmax/24*360 .- 180, latmax; text=\"$(round((nmax/1e3); digits=1))\", halign=:left, valign=:bottom, color=\"red\")\n\n    #::. colorbar\n    Colorbar(fig[1,2], sc;\n        label=\"$element Abundance [10³/cm³]\",\n        ticks=([0,5000,10000,15000,20000], [\"0\", \"5\", \"10\", \"15\", \"20\"]),\n        highclip=cmap[end] |&gt; RGB{Colors.N0f8})\n    \n    #::. custom x-axis labels\n    ax2 = MyLTGeoAxis(fig[1, 1];\n        spinewidth = 0,\n        xticks=([-180, -90, 0, 90, 180], [\"\",\"\",\"\",\"\",\"\",]),\n        yticks=[-30,-15,0,15,30])\n    ylims!(ax2, -40, 30)\n    hidedecorations!(ax2)\n    text!(ax2, -140, -30; text= \"0\")\n    text!(ax2,  -63, -30; text= \"6\")\n    text!(ax2,   11, -30; text=\"12\")\n    text!(ax2,   89, -30; text=\"18\")\n    text!(ax2,  165, -30; text=\"24\")\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.pdf\"), fig)\n    # save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.svg\"), fig) # too big!\n    save(joinpath(@__DIR__, \"ladee_n0_$(element)_proj.png\"), fig, px_per_unit=4)\n    return nothing\nend\n\n\n#::.\nget_all() = load_all_data(\"He\"), load_all_data(\"Ne\"), load_all_data(\"Ar\")\nfunction run_all(dfHe, dfNe, dfAr; T=250, kwargs...)\n    dfHe_p, dfNe_p, dfAr_p = copy(dfHe), copy(dfNe), copy(dfAr)\n    dfHe_p[:,14] .= projection_CHAMBERLAIN1963.(dfHe_p[:, 14], LUNAR_RADIUS .+ dfHe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(4))\n    dfNe_p[:,14] .= projection_CHAMBERLAIN1963.(dfNe_p[:, 14], LUNAR_RADIUS .+ dfNe_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(20))\n    dfAr_p[:,14] .= projection_CHAMBERLAIN1963.(dfAr_p[:, 14], LUNAR_RADIUS .+ dfAr_p[:, 10]*1e3, LUNAR_RADIUS, T, amu2kg(40))\n    plot_lat(dfHe_p, \"He\"; kwargs...)\n    plot_lat(dfNe_p, \"Ne\"; kwargs...)\n    plot_lat(dfAr_p, \"Ar\"; kwargs...)\nend\n\n\n\n LADEE_n0_Helium.png \n LADEE_n0_Neon.png \n LADEE_n0_Argon.png"
  },
  {
    "objectID": "documentation/planetary_measurements/lunar_exosphere_densities.html",
    "href": "documentation/planetary_measurements/lunar_exosphere_densities.html",
    "title": "3.3 Lunar Exosphere Surface Densities",
    "section": "",
    "text": "This section lists referenced values of the lunar exosphere surface densities, generally provided as a number density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\). Some references are providing their values in terms of a column density in \\(\\left[\\,\\mathrm{cm^{\\mathrm{-2}}}\\right]\\), which includes the respectives measurements coulumn height, i.e., the illuminated line of sight of brightness measurements like LAMP.\nSee the additional information section on this section’s appendix to find details about some sources, their assumptions, and their measurement methods.\n\nAtomic Hydrogen – \\(\\ce{H}\\)\n\n\nTable 1: Overview of reported hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nupper limit, UVS Apollo 17\n\\(1.0 \\times 10^1\\)\nFastie et al. (1973)\n\n\nupper limit\n\\(1.7 \\times 10^1\\)\nFeldman & Morrison (1991)  Gladstone et al. (2009)\n\n\nLAMP\n\\(1.4 \\times 10^{-1}\\)\nGladstone et al. (2009)\n\n\nmodel predictions, dayside\n\\(8.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit\n\\(2.4 \\times 10^1\\)\nCook et al. (2013)\n\n\n\n\n\n\nMolecular Hydrogen – \\(\\ce{H2}\\)\n\n\nTable 2: Overview of reported molecular hydrogen surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nmodel predictions, dayside  model predictions, nightside\n\\(2.0 \\times 10^3\\)  \\(1.2 \\times 10^4\\)\nHodges et al. (1973)\n\n\nLACE, upper limit, dayside  LACE, upper limit, nightside\n\\(6.0 \\times 10^3\\)  \\(6.5 \\times 10^4\\)\nHoffman et al. (1973)\n\n\nUVS Apollo 17, upper limit\n\\(1.2 \\times 10^4\\)\nFastie et al. (1973)\n\n\nApollo, upper limit, dayside  Apollo, upper limit, nightside\n\\(2.5 \\text{ to } 9.9 \\times 10^3\\)  \\(1.0 \\text{ to } 15.0 \\times 10^4\\)\nHeiken et al. (1991), chap 3.10\n\n\nupper limit  expected LAMP density\n\\(9.0 \\times 10^3\\)  \\(1.1 \\times 10^4\\)\nGladstone et al. (2009)\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2}\\)\n\\(2.1 \\times 10^3\\)\nWurz et al. (2012)\n\n\nLAMP, upper limit, dusk  LAMP, upper limit, dawn\n\\(1.3 \\text{ to } 2.1 \\times 10^3\\)  \\(1.8 \\text{ to } 2.4 \\times 10^3\\)\nCook et al. (2013)\n\n\nLAMP, “effective”  LAMP, nightside, dusk  LAMP, nightside, dawn\n\\(0.8 \\text{ to } 1.6 \\times 10^3\\)  \\(0.5 \\text{ to } 1.5 \\times 10^3\\)  \\(0.9 \\text{ to } 1.9 \\times 10^3\\)\n Stern et al. (2013)\n\n\nCHACE, at latitudes: \\(20\\text{ to }50\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(50\\text{ to }70\\,\\mathrm{\\degree}\\)  CHACE, at latitudes: \\(70\\text{ to }90\\,\\mathrm{\\degree}\\)\n\\(4.0 \\text{ to } 6.0 \\times 10^2\\)  \\(5.0 \\text{ to } 6.5 \\times 10^2\\)  \\(6.5 \\text{ to } 8.5 \\times 10^2\\) \n Thampi et al. (2015)\n\n\nmodel predictions, equator, dayside  model predictions, equator, nightside  model predictions, equator, dayside, in magnetotail  model predictions, equator, nightside, in magnetotail\n\\(1.5 \\text{ to } 2.2 \\times 10^3\\)  \\(3.0 \\text{ to } 4.2 \\times 10^3\\)  \\(0.4 \\text{ to } 0.7 \\times 10^3\\)  \\(1.0 \\text{ to } 1.5 \\times 10^3\\)\n Tucker et al. (2021)\n\n\n\n\n\n\nHelium – \\(\\ce{He}\\)\n\n\nTable 3: Overview of reported helium surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(1.6 \\times 10^3\\)  \\(3.8 \\times 10^4\\)\nHodges et al. (1973)\n\n\nupper limit, dayside  upper limit, nightside\n\\(2.0 \\times 10^3\\)  \\(4.0 \\times 10^4\\)\nHoffman et al. (1973)\n\n\n\n\n\n\nHydroxyl – \\(\\ce{OH}\\)\n\n\nTable 4: Overview of reported hydroxyl surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]OH}\\)\n\\(1.0 \\times 10^0\\)\nWurz et al. (2012)\n\n\n\n\n\n\nWater – \\(\\ce{H2O}\\)\n\n\nTable 5: Overview of reported water surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nApollo, upper limit, dayside\n\\(0.5 \\times 10^0\\)\nHeiken et al. (1991), chap 3.10\n\n\nmodel predictions, upper limit, dayside  \\(\\ce{p+-&gt;[100\\%]H2O}\\)\n\\(2.9 \\times 10^3\\)\nWurz et al. (2012)\n\n\n\n\n\n\nNeon – \\(\\ce{Ne}\\)\n\n\nTable 6: Overview of reported Neon surface number densities in reviewed and published literature.\n\n\n\n\n\n\n\nDescription\nValue \\(\\left[\\,\\mathrm{cm^{\\mathrm{-3}}}\\right]\\)\nReference(s)\n\n\n\n\nModel predictions, dayside  Model predictions, nightside\n\\(4.0 \\text{ to } 7.0 \\times 10^3\\)  \\(1.0 \\text{ to } 2.0 \\times 10^5\\)\nHodges et al. (1973)\n\n\nsolar zenith angle:    \\(+168\\degree\\)    \\(-136\\degree\\)    \\(-112\\degree\\)    \\(-89\\degree\\)  \\(\\Rightarrow\\) average\n \\(9.4 \\times 10^4\\)  \\(7.7 \\times 10^4\\)  \\(7.1 \\times 10^4\\)  \\(8.7 \\times 10^4\\)  \\(8.2 \\times 10^4\\) \n   Hoffman et al. (1973)\n\n\n\n\n\n\nArgon – \\(\\ce{Ar}\\)\n\n\n\nAdditional Information\n\n\nGladstone et al. (2009) assume for the LAMP derivations a \\(30\\,\\mathrm{min}\\), \\(3\\sigma\\) observation, and a path length of \\(300\\,\\mathrm{km}\\).\nHodges et al. (1973) assumed a solar wind proton influx of \\(3 \\times 10^8 \\,\\mathrm{s^{\\mathrm{-1}}cm^{\\mathrm{-3}}}\\) for their simulations.\nCHACE measurements were made during a Moon’s pass through Earth’s magnetotail, reducing the solar wind influx of particles dramatically.\nHeiken et al. (1991) reported a joint upper limit of \\(0.5 \\times 10^0\\) for both \\(\\ce{OH}\\) and \\(\\ce{H2O}\\)\n\n\n\n\nReferences\n\nCook, J. C., Stern, S. A., Feldman, P. D., Gladstone, G. R., Retherford, K. D., & Tsang, C. C. C. (2013). New upper limits on numerous atmospheric species in the native lunar atmosphere. Icarus. https://doi.org/10.1016/j.icarus.2013.04.010\n\n\nFastie, Wm. G., Feldman, P. D., Henry, R. C., Moos, H. W., Barth, C. A., Thomas, G. E., & M. Donahue, andThomas. (1973). A Search for Far-Ultraviolet Emissions from the Lunar Atmosphere. 2023. https://doi.org/10.1126/science.182.4113.710\n\n\nFeldman, P. D., & Morrison, D. (1991). The Apollo 17 Ultraviolet Spectrometer: Lunar Atmosphere Measurements revited. Geophysical Research Letters, 18(11), 2105–2108. https://doi.org/10.1029/91GL01998\n\n\nGladstone, G. R., Stern, S. A., Retherford, K. D., Black, R. K., Slater, D. C., Davis, M. W., Versteeg, M. H., Persson, K. B., Parker, J. W., Kaufmann, D. E., Egan, A. F., Greathouse, T. K., Feldman, P. D., Hurley, D., Pryor, W. R., & Hendrix, A. R. (2009). LAMP: The Lyman Alpha Mapping project on NASA’s lunar reconnaissance orbiter mission. Space Science Reviews, 150(1-4), 161–181. https://doi.org/10.1007/s11214-009-9578-6\n\n\nHeiken, G. H., Vaniman, D. T., & French, B. M. (1991). Lunar sourcebook: a user’s guide to the Moon: A user’s guide to the moon (p. 756). Cambridge University Press.\n\n\nHodges, R. R. Jr., Hoffman, J. H., & Johnson, F. S. (1973). Composition and dynamics of lunar atmosphere. Proceedings of the Fourth Lunar Science Conference, 3, 2855–2864.\n\n\nHoffman, J. H., Hodges, R. R., Johnson, F. S., & Evans, D. E. (1973). Lunar atmospheric composition results from Apollo 17. Proceedings of the Fourth Lunar Science Conference, 3, 2865–2875.\n\n\nStern, S. A., Cook, J. C., Chaufray, J. Y., Feldman, P. D., Gladstone, G. R., & Retherford, K. D. (2013). Lunar atmospheric H2 detections by the LAMP UV spectrograph on the Lunar Reconnaissance Orbiter. Icarus, 226(2), 1210–1213. https://doi.org/10.1016/j.icarus.2013.07.011\n\n\nThampi, S. V., Sridharan, R., Das, T. P., Ahmed, S. M., Kamalakar, J. A., & Bhardwaj, A. (2015). The spatial distribution of molecular hydrogen in the lunar atmosphere—new results. Planetary and Space Science, 106, 142–147. https://doi.org/10.1016/j.pss.2014.12.018\n\n\nTucker, O. J., Farrell, W. M., & Poppe, A. R. (2021). On the effect of magnetospheric shielding on the lunar hydrogen cycle. Journal of Geophysical Research: Planets, 126(2). https://doi.org/10.1029/2020je006552\n\n\nWurz, P., Abplanalp, D., Tulej, M., & Lammer, H. (2012). A neutral gas mass spectrometer for the investigation of lunar volatiles. Planetary and Space Science, 74(1), 264–269. https://doi.org/10.1016/j.pss.2012.05.016\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/introduction/introduction.html",
    "href": "documentation/introduction/introduction.html",
    "title": "1. Introduction",
    "section": "",
    "text": "Some Title\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html",
    "href": "documentation/fundamentals/numerical_grids.html",
    "title": "2.2 Numerical Grids",
    "section": "",
    "text": "Some introduction text…"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured",
    "href": "documentation/fundamentals/numerical_grids.html#structured",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured\nThe global, structured, two-dimensional grid is discretizing the surface of a perfectly spherical body of fixed radius \\(r\\) using a regular, structured grid with a fixed angular resolution \\(\\Delta\\vartheta\\times \\Delta\\varphi\\), in azimuth and elevation direction, respectively. Since the definition includes spherical elements, the grid is created in global spherical coordinates \\(\\boldsymbol{\\mathbf{r}}= \\left[r, \\vartheta, \\varphi\\right]^T\\), see Cartesian and Spherical Coordinates.\n\n\n GlobalStructuredGrid: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\) - \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\nCoordinate Calculation\nThe spherical coordinates, the azimuth \\(\\vartheta\\) and elevation \\(\\varphi\\), are created as follows: \\[\\begin{alignat}{4}\n    \\vartheta_i &= - \\pi + \\frac{\\pi}{N_\\vartheta} + (i-1)\\Delta\\vartheta& \\quad\\text{for } i \\in \\{1, \\dots, N_\\vartheta\\} & \\quad\\text{with } \\Delta\\vartheta= \\frac{2\\pi}{N_\\vartheta} \\label{eq:gs2dgrid_azimuth} \\\\\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi& \\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\} & \\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi} \\label{eq:gs2dgrid_elevation}\n\\end{alignat}\\] where \\(N_\\vartheta\\) and \\(N_\\varphi\\) define the number of elements in the azimuth and elevation direction, respectively. The created points of the grid are located in the center of each rectangular grid cell, i.e., at \\(\\Delta\\vartheta/ 2 = \\pi /N_\\vartheta\\) and \\(\\Delta\\varphi/ 2 = \\pi / \\left(2N_\\varphi\\right)\\) of each elements sides. Let \\(k\\) be a common index with \\(k = (i-1)N_\\varphi+ j\\), then every grid element’s coordinate can be written as \\(\\boldsymbol{\\mathbf{r}}_k = \\left(r, \\vartheta_i, \\varphi_j\\right)\\).\n\n\n coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\)   surfacecoords: identical to coords\n\n\n\n\n\n\nAzimuth Periodicity\n\n\n\n\n\nDue to the \\(2\\pi\\)-periodicity of the azimuth angle \\(\\vartheta\\), the structure, which is the constant \\(\\Delta\\vartheta\\) angular distance between elements, has to be shown across its periodic boundaries: \\[\\begin{align*}\n    \\vartheta_1 + 2\\pi - \\vartheta_{N_\\vartheta} &= \\left(- \\pi + \\frac{\\pi}{N_\\vartheta}\\right) + 2\\pi - \\left(- \\pi + \\frac{\\pi}{N_\\vartheta} + (N_\\vartheta-1)\\frac{2\\pi}{N_\\vartheta} \\right) = \\frac{2\\pi}{N_\\vartheta} = \\Delta\\vartheta\n\\end{align*}\\]\n\n\n\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\n\n\n\n\nFigure 1: Global, structured, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e. radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_2d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_proj(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if theta &lt; -170; continue; end\n        lines!(ax, ones(100)*theta .- 180/N_theta, range(-90,90,100); color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_3d(N_theta=20, N_phi=10;)\n    grid = GlobalStructured2DGrid(Float32,1,N_theta,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for theta in unique(rad2deg.(Xs[:,2]))\n        if abs(theta) &gt;= 90; continue; end\n        theta -= 180/N_theta\n        x = [cosd(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [sind(theta) * cos(x) for x in range(-pi/2,pi/2,100)]\n        z = [sin(x) for x in range(-pi/2,pi/2,100)]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all()\n    gs2dgrid_2d(20,10)\n    gs2dgrid_proj(20,10)\n    gs2dgrid_3d(20,10)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$) ;\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190) ;\n\n\\end{tikzpicture}\n\n\n\n figure.svg \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\nFigure 1 shows an example of a spherical surface discretization based on the global, structured, two-dimensional grid. Elements were created based on Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_elevation}\\) with \\(N_\\vartheta= 20\\) elements in azimuth and \\(N_\\varphi= 10\\) elements in elevation, leading to a total of \\(200\\) grid elements and, thus, coordinates \\(\\boldsymbol{\\mathbf{r}}_k\\) for \\(k\\in\\{1,\\dots,200\\}\\). The grid resolution is \\(\\Delta\\vartheta\\times\\Delta\\varphi= 18\\,\\mathrm{\\degree}\\times18\\,\\mathrm{\\degree}\\). The figure shows three different views of the same numerical discretization. The top left in a conventional axis making use of the two-dimensionality of the grid, with the azimuth angle \\(\\vartheta\\) on the horizontal axis and the elevation angle \\(\\varphi\\) on the vertical axis. This view highlights the structured nature of the discretization scheme with equally resolved angular elements across the entire domain. The centered graph is a projected view of the spherical coordinates, visualized on a flattened spherical surface based on a projection method (Jenny2008?). While this flattened surface is neither a conformal nor an equal-area projection of an actual sphere, it provides a good and easily understandable visual representation of the spherical nature of the grid. The structure of the discretization scheme is still visible, while the accumulation of grid elements in the polar region becomes apparent. This accumulation is a direct result of the spherical nature of the grid, where the same angular resolution \\(\\Delta\\vartheta\\times\\Delta\\varphi\\) leads to a smaller area of the grid elements in the polar region. The bottom right graph depicts the same discretization scheme in a conventional, cartesian coordinate system, which shows the grid in its physical, three-dimensional form, where the polar grid elements are undistorted. Note that this last representation of the grid only shows half of the sphere (\\(x&gt; 0\\)) since the other half is identical due to the symmetry of the spherical coordinate system.\nThe transformation from one of the visualizations to another is termed either a or a in Figure 1, depending on the type of coordinate system of the destination. The compilation of the three shown views helps to understand both the structural nature of the grid and the general downside of using such a simple discretization scheme, i.e., the clumping of elements around the poles. As already apparent from the area calculation seen in Eq. \\(\\eqref{eq:area_gs2dgrid}\\), the surface coverage of each element on the same elevation is equal, while it decreases with \\(\\sin\\varphi\\rightarrow 0\\) towards the poles.\n\n\nArea Calculation\nWith the same index notation, the area of each spherical grid element can be calculated as the integral over its angles at each angular position: \\[\\begin{align}\n    A_k &= \\int_{\\vartheta_i-\\frac{\\Delta\\vartheta}{2}}^{\\vartheta_i+\\frac{\\Delta\\vartheta}{2}} \\int_{\\varphi_j-\\frac{\\Delta\\varphi}{2}}^{\\varphi_j+\\frac{\\Delta\\varphi}{2}} r^2 \\cos \\left( \\varphi\\right) d\\varphi d\\vartheta\\\\\n    \\Rightarrow\\qquad A_k &= r^2 \\cdot \\Delta\\vartheta\\cdot \\left(\\sin\\left(\\varphi_j + \\frac{\\Delta\\varphi}{2}\\right) - \\sin\\left(\\varphi_j - \\frac{\\Delta\\varphi}{2}\\right)\\right).\n    \\label{eq:area_gs2dgrid}\n\\end{align}\\] Note that the definition for the area is independent of the azimuth angle \\(\\vartheta\\), thus equal across all \\(N_\\vartheta\\) elements in the azimuth direction.\n\n\n areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)\n\n\nContinuous to Discrete Mapping\nIn many applications of numerical grids, it is necessary to map coordinates in the continuous domain to the discrete grid points, i.e., to find the grid element the continuous coordinate is located in. For the structural grid, the problem can be defined in terms of the shared index \\(k\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\boldsymbol{\\mathbf{r}}_k = \\left[r, \\vartheta_k, \\varphi_k\\right]^T\\), or in terms of the individual indices \\(i\\) and \\(j\\) as \\(\\boldsymbol{\\mathbf{r}}\\mapsto \\left[r, \\vartheta_i, \\varphi_j\\right]\\) with \\(k = (i-1)N_\\varphi+ j\\). The latter approach can be analytically solved for the azimuth and elevation indices using the function, \\(\\lceil\\bullet\\rceil\\), to round the floating-point calculations to the next higher integer index: \\[\\begin{align}\n    i &= \\left\\lceil \\frac{\\left(\\vartheta+\\pi\\right)N_\\vartheta}{2\\pi} \\right\\rceil = \\left\\lceil \\frac{\\vartheta+\\pi}{\\Delta\\vartheta} \\right\\rceil, \\label{eq:gs2dgrid_coord2idx_azimuth}\\\\\n    j &= \\left\\lceil \\frac{\\left(\\varphi+\\pi/2\\right)N_\\varphi}{\\pi} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil. \\label{eq:gs2dgrid_coord2idx_elevation}\n\\end{align}\\] Numerical problems can arise around the boundaries of the numerical grid due to \\(\\lceil 0 \\rceil = 0\\). As no zeroth grid element exists, the inputs must be pretreated to avoid this problem. For the azimuth angle, the angle is mapped to the half-open interval \\(\\left(-\\pi, \\pi\\right]\\), thus if \\(\\vartheta=-\\pi\\) then \\(\\vartheta\\mapsto \\vartheta+ 2\\pi\\). The elevation is mapped to the open interval \\(\\left(-\\pi/2, \\pi/2\\right)\\) and should \\(|\\varphi| = \\pi/2\\) then \\(\\varphi\\mapsto \\varphi- \\mathop{\\mathrm{sgn}}\\left(\\varphi\\right)\\epsilon\\), with the machine accuracy \\(\\epsilon\\) being the smallest floating point number available to the machine.\n\n\ncoord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\)\n\n\nEquatorial Symmetry\nFor some applications, equatorial symmetry of the underlying problem can be assumed, which can be exploited to reduce the number of grid elements. In this case, the grid is only defined for \\(\\varphi\\in \\left[0, \\pi/2\\right)\\), and the elevation is subsequently calculated similar to Eq. \\(\\eqref{eq:gs2dgrid_elevation}\\): \\[\\begin{equation}\n    \\varphi_j = \\frac{\\pi}{4N_\\varphi} + (j-1)\\Delta\\varphi\\quad\\text{for } j \\in \\{1, \\dots, N_\\varphi\\}  \\quad\\text{with}\\quad \\Delta\\varphi= \\frac{\\pi}{2N_\\varphi}\n    \\label{eq:gs2dgrid_eqsim_elevation}\n\\end{equation}\\] This also changes the function mapping continuous coordinates to specific and discrete grid elements; see Eq. \\(\\eqref{eq:gs2dgrid_coord2idx_elevation}\\): \\[\\begin{equation}\n    j = \\left\\lceil \\frac{\\left|\\varphi\\right| \\cdot N_\\varphi}{\\pi/2} \\right\\rceil = \\left\\lceil \\frac{\\varphi+\\pi/2}{\\Delta\\varphi} \\right\\rceil.\n    \\label{eq:gs2dgrid_eqsim_coord2idx_elevation}\n\\end{equation}\\] Taking the absolute value of the elevation angle in the equation above ensures that the function is defined for the entire sphere. Still, the mapping always projects the coordinate onto the upper hemisphere.\n\n\n GlobalStructuredGrid_EqSim Eqs. \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\) - \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)   areas: Eq. \\(\\eqref{eq:area_gs2dgrid}\\)   coords: Eqs. \\(\\eqref{eq:gs2dgrid_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_elevation}\\)   coord2idx: Eqs. \\(\\eqref{eq:gs2dgrid_coord2idx_azimuth}\\), \\(\\eqref{eq:gs2dgrid_eqsim_coord2idx_elevation}\\)"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced\nIn order to counter the disadvantages of the full grid, the reduced, structured grid was introduced. The main goal of this discretization scheme is to keep the advantages of the structured grid as much as possible while reducing the number of elements, especially those at high elevation angles. Mathematically speaking, during the creation of the grid, the individual elements are as close as possible to equal area squares with a constant, physical resolution of \\(\\left(r\\cdot\\cos\\varphi\\cdot\\Delta\\vartheta\\right)\\times\\left(r\\cdot\\Delta\\varphi\\right)\\).\n\nCoordinate Calculation\nThe coordinates for the grid are calculated by iterating over the fixed number \\(N_\\varphi\\) of elevation angles (which calculation is equal to the standard, structured grid, see Eq.~(\\(\\ref{eq:gs2dgrid_elevation}\\))), which lead to a variable number \\(\\left(N_\\vartheta\\right)_j\\) of azimuth angles for each elevation angle \\(\\varphi_j\\): \\[\\begin{alignat}{3}\n    \\varphi_j &= - \\frac{\\pi}{2} + \\frac{\\pi}{2N_\\varphi} + (j-1)\\Delta\\varphi&&\\quad\\text{with } \\Delta\\varphi= \\frac{\\pi}{N_\\varphi}  \\label{eq:gs2dgrid_reduced_elevation} \\\\\n    &\\Rightarrow\\quad \\left(N_\\vartheta\\right)_j = \\left\\lceil \\frac{2\\pi\\varphi_j}{\\pi N_\\varphi} \\right\\rceil \\label{eq:gs2dgrid_reduced_azimuth_elements} \\\\\n    \\vartheta_{i,j} &= - \\pi + \\frac{\\pi}{\\left(N_\\vartheta\\right)_j} + (i-1)\\Delta\\vartheta_j &&\\quad\\text{with } \\Delta\\vartheta_j = \\frac{2\\pi}{\\left(N_\\vartheta\\right)_j} \\label{eq:gs2dgrid_reduced_azimuth}\n\\end{alignat}\\] for \\(j \\in \\{1, \\dots, N_\\varphi\\}\\) and \\(i \\in \\{1, \\dots, \\left(N_\\vartheta\\right)_j\\}\\), respectively.\n\n\n Figure Julia LaTeX Downloads\n\n\n\n\n\n\n\n\n\nFigure 2: Global, structured, reduced, two-dimensional numerical grid in cartesian (lower right) and spherical (center and upper left) coordinates in arbitrary units. Arrows indicate the projection from the spherical to the cartesian coordinate system and vice versa. Note that the grid is only two-dimensional in the spherical coordinate system, assuming a constant third-dimension, i.e. radius \\(r\\).\n\n\n\n\nusing .ExESS\nusing CairoMakie, GeoMakie\n\n#::. functions\nfunction gs2dgrid_reduced_2d(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = Axis(fig[1,1];\n        xautolimitmargin=(0,0),\n        xlabel=\"Azimuth\",\n        yautolimitmargin=(0,0),\n        ylabel=\"Elevation\",)\n    hidedecorations!(ax; label=false)\n    ylims!(ax, -90, 90)\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_2d.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_proj(N_phi=10)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n\n    # setup figure\n    fig = Figure(;resolution=(600,300))\n    ax = MyLTGeoAxis(fig[1,1]; \n        xlabel=\"Azimuth\",\n        xticks=[0],\n        ylabel=\"Elevation\",) \n    hidedecorations!(ax; label=false);\n\n    # grid points\n    scatter!(ax, rad2deg.(Xs[:,2]), rad2deg.(Xs[:,3]), markersize=3, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        if phi &lt; -85; continue; end\n        lines!(ax, [-180, 180], [phi, phi] .- 90/N_phi; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            lines!(ax, [theta, theta], [-90 + (i-1)*180/length(grid.N_theta),-90 + i*180/length(grid.N_theta)]; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_proj.png\"), fig, px_per_unit=4)\n    nothing\nend\n\nfunction gs2dgrid_reduced_3d(N_phi=10;)\n    grid = GlobalStructured2DGrid_Reduced(Float32,1,N_phi)\n    Xs = vcat(vec.(coords(grid))'...)\n    Xc = vcat(vec.(coords(GlobalCartesianPosition, grid))'...)\n\n    #\n    fig = Figure(;resolution=(400,400))\n    ax = Axis3(fig[1,1];\n        aspect=:data,\n        azimuth=-0.3pi,\n        elevation=0.4,\n        xlabeloffset=0,\n        ylabeloffset=0,\n        zlabeloffset=0,)\n    hidedecorations!(ax; label=false)\n\n    # filter\n    x, y, z = Float64[], Float64[], Float64[]\n    for i in eachindex(Xc[:,1])\n        if Xc[i,1] &lt; 0; continue; end\n        push!(x, Xc[i,1])\n        push!(y, Xc[i,2])\n        push!(z, Xc[i,3])\n    end\n    scatter!(ax, x, y, z, markersize=4, color=:black)\n\n    # custom grid lines\n    for phi in unique(rad2deg.(Xs[:,3]))\n        phi -= 90/N_phi\n        x = [cosd(phi) * cos(x) for x in range(-pi/2,pi/2,100)]\n        y = [cosd(phi) * sin(x) for x in range(-pi/2,pi/2,100)]\n        z = [sind(phi) * ones(100)...]\n        lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n    end\n    for i in eachindex(grid.N_theta)\n        N_theta = grid.N_theta[i]\n        dtheta = 360/N_theta\n        for theta in range(-180, 180, step=dtheta)\n            if abs(theta) &gt;= 90; continue; end\n            phi0, phi1 = -90 + (i-1)*180/length(grid.N_theta), -90 + i*180/length(grid.N_theta)\n            \n            x = [cosd(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            y = [sind(theta) * cosd(x) for x in range(phi0,phi1,100)]\n            z = [sind(x) for x in range(phi0,phi1,100)]\n\n            lines!(ax, x, y, z; color=(:black, 0.3), linewidth=0.5)\n        end\n    end\n\n    # save figure\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.pdf\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.svg\"), fig)\n    save(joinpath(@__DIR__, \"gs2dgrid_reduced_3d.png\"), fig, px_per_unit=4)\n\n    nothing\nend\n\n#::. call all functions\nfunction run_all(N=10)\n    gs2dgrid_reduced_2d(N)\n    gs2dgrid_reduced_proj(N)\n    gs2dgrid_reduced_3d(N)\nend\n\n\n\\begin{tikzpicture}\n\n    \\pgfdeclarelayer{background layer}\n    \\pgfdeclarelayer{foreground layer}\n    \\pgfsetlayers{background layer,main,foreground layer}\n\n    \\node (2d) at (0,0) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_2d.pdf}};\n    \\node[below right = -2 and -14 of 2d] (proj) {\\includegraphics[natwidth=600px, natheight=300px]{./gs2dgrid_reduced_proj.pdf}};\n    \n    \\begin{pgfonlayer}{background layer}\n        \\node[below right = -5.5 and -10 of proj] (3d) {\\includegraphics[natwidth=400px, natheight=400px, trim={0 30pt 0 0}, clip]{./gs2dgrid_reduced_3d.pdf}};\n    \\end{pgfonlayer}\n\n    \\draw[-latex, very thick] ($(3d.90)+(0,-3)$) to [in=0, out=90] node[near end, above, yshift=40px]{\\LARGE{spherical projection}} ($(2d.0)+(-4,0)$) ;\n    \n    \\draw[-latex, very thick] (2d.220) to [in=180, out=270] node[near end, below, yshift=-30px]{\\LARGE{cartesian projection}} (3d.190) ;\n\n\\end{tikzpicture}\n\n\n\n figure.svg \n 2d.svg   2d.pdf   2d.png \n proj.svg   proj.pdf   proj.png \n 3d.svg   3d.pdf   3d.png \n\n\n\n\n\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nEquatorial Symmetry"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#spiral",
    "href": "documentation/fundamentals/numerical_grids.html#spiral",
    "title": "2.2 Numerical Grids",
    "section": "Spiral",
    "text": "Spiral\n\nCoordinate Calculation\nPoints on a spherical surface \\(\\mathbb{S}^2\\) which form a path in the form of a spiral can be expressed in spherical coordinates of the form \\[\\begin{equation}\n    \\vartheta=L\\varphi, \\qquad 0 \\leq \\varphi\\leq \\pi\n\\end{equation}\\] with the polar angle \\(\\varphi\\) and the azimuth \\(\\vartheta\\), or the latitude and longitude, respectively (Hardin et al., 2016). The factor \\(L\\) gives the slope of the spiral. One generation method of \\(N\\) points defines the two spherical coordinates as\n\\[\\begin{aligned}\n    L =& \\; \\sqrt{N\\pi}, \\\\\n    h_k =& \\; 1 -\\frac{2k-1}{N}, \\\\\n    \\varphi_k =& \\; \\cos^{-1}(h_k), \\\\\n    \\vartheta_k =& \\; L\\varphi_k\n\\end{aligned}\\]\nfor \\(k = 1,\\dots, N\\), where the slope \\(L\\) is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by \\(2\\pi\\) in \\(\\vartheta\\) (Hardin et al., 2016).\nA specialized method of creating a set of spiral points implements the Fibonacci sequence \\[\\begin{equation}\n    \\left\\{ F_k \\right\\} = \\left\\{1, 1, 2, 3, 5, 8, 13, \\dots \\right\\}\n\\end{equation}\\] and the golden ratio \\(\\varphi = \\frac{1 + \\sqrt{5}}{2}.\\) The general algorithm defines a lattice of points on the square \\(\\left[ 0,1 \\right)^2\\), which is subsequently mapped to a unit sphere using the Lambert cylindrical equal-area projection \\(\\Lambda\\): \\[\\begin{equation}\n    \\Lambda(x,y) = \\left( \\sqrt{1-(2y-1)^2}\\cdot\\cos\\left(2\\pi x\\right), \\sqrt{1-(2y-1)^2}\\cdot\\sin\\left(2\\pi x\\right), 2y-1 \\right)\n\\end{equation}\\] in Cartesian coordinates, and \\[\\begin{equation}\n    \\Lambda(x,y) = \\left(\\cos^{-1}(2y-1), 2\\pi x\\right) = \\left( \\varphi, \\vartheta\\right)\n\\end{equation}\\] in spherical coordinates. The points \\((x, y)\\) on the square \\(\\left[ 0,1 \\right)^2\\) are created through \\[\\begin{equation}\n    (\\tilde x, y)_{F_k} = \\left( \\frac{iF_{k-1}}{F_k} , \\frac{i}{F_k} \\right), \\qquad 0 \\leq i \\leq F_k\n\\end{equation}\\] where \\(x= \\tilde x- \\lfloor \\tilde x\\rfloor\\) as just the fractional part of \\(\\tilde x\\) (Hardin et al., 2016). While this implementation can only be applied for \\(N+1\\) elements, where \\(N \\in \\{ F_k \\}\\), a more general approach involves the golden ratio \\(\\varphi\\). Based on Binet’s formula the calculation of \\((x, y)\\) can be changed to \\[\\begin{equation}\n    (\\tilde x, y)_{N} = \\left( \\frac{i}{\\varphi}, \\frac{i}{N} \\right), \\qquad 0 \\leq i \\leq N.\n\\end{equation}\\]\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping\n\n\nAnalysis of Point Distribution\nAlmost all points have equal distances from one another. Numerical analyses of the Fibonacci-based spiral sequence \\(\\omega_N\\) in Hardin et al. (2016) found minimal separations to appear at the poles with value \\(|x_1 - x_4|, \\, x_i\\in\\omega_N\\) and maximum hole in the lattice to occurs in the triangle \\((x_2, x_3, x_5)\\)."
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#healpix",
    "href": "documentation/fundamentals/numerical_grids.html#healpix",
    "title": "2.2 Numerical Grids",
    "section": "HEALPix",
    "text": "HEALPix\nHEALPix, Hierarchical Equal Area iso-Latitude Pixelization (Hardin et al., 2016), was developed by NASA to have three distinct properties, which are that\n\nthe sphere is hierarchically tessellated into curvilinear quadrilaterals,\nthe pixelization is an equal area partition of \\(\\mathbb{S}^2\\), and\nthe point sets are distributed along fixed lines of latitude.\n\n\nCoordinate Calculation\nThe generation of such points firstly requires a division of the sphere into twelve equal area, four sided pixels defined by:\n\\[\\begin{aligned}\n    |\\cos\\varphi|&gt;\\frac{2}{3}, \\qquad \\vartheta=m\\frac{\\pi}{2}, \\qquad & \\quad m = 0,1,2,3 \\\\\n    \\cos\\varphi= \\frac{-2-4m}{3} + \\frac{8\\vartheta}{3\\pi}, \\qquad \\frac{m\\pi}{2} \\leq \\vartheta\\leq \\frac{(m+1)\\pi}{2}, \\qquad & \\quad m=0,1,2,3 \\\\\n    \\cos\\varphi=\\frac{2-4m}{3}-\\frac{8\\vartheta}{3\\pi}, \\qquad \\frac{-(m+1)\\pi}{2} \\leq \\vartheta\\leq \\frac{-m\\pi}{2}, \\qquad & \\quad  m=0,1,2,3.\n\\end{aligned}\\]\nThese pixels can be further partitioned into a \\(k \\times k\\) grid of sub-pixels of the same shape and area. The points of the set are located in the centers of each pixel. The subdivision leads to \\(k\\) iso-latitudinal rings at the polar region \\(|\\cos\\varphi|&gt;2/3\\), with \\[\\begin{equation}\n    |\\cos\\varphi_i|=1-\\frac{i^2}{3k^2}, \\qquad \\vartheta_j=\\frac{\\pi}{2i} \\left( j - \\frac{1}{2} \\right),\n\\end{equation}\\]\nthus, every \\(i\\)-th ring has \\(4i\\) equally spaced points. Closer to the equatorial region, \\(2k-1\\) iso-latitudinal rings with \\(4k\\) points each emerge. These points are indexed by \\(k \\leq |i| \\leq 2k\\) and \\(1 \\leq j \\leq 4k\\): \\[\\begin{equation}\n    |\\cos\\varphi_i| = \\frac{4}{3} - \\frac{2i}{3k}, \\qquad \\vartheta_j = \\frac{\\pi}{2k} \\left( j - \\frac{s}{2} \\right), \\qquad s = (i-k+1) \\mod 2.\n\\end{equation}\\]\nThe last index, \\(s\\), describes the phase shift between the rings. Finally, this configuration produces a set of \\(N=12k^2\\) points (Hardin et al., 2016).\n\n\nArea Calculation\n\n\nContinuous to Discrete Mapping"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-1",
    "href": "documentation/fundamentals/numerical_grids.html#structured-1",
    "title": "2.2 Numerical Grids",
    "section": "Structured",
    "text": "Structured"
  },
  {
    "objectID": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "href": "documentation/fundamentals/numerical_grids.html#structured-reduced-1",
    "title": "2.2 Numerical Grids",
    "section": "Structured, Reduced",
    "text": "Structured, Reduced"
  },
  {
    "objectID": "documentation/fundamentals/coordinate_systems.html",
    "href": "documentation/fundamentals/coordinate_systems.html",
    "title": "2.1 Coordinate Systems",
    "section": "",
    "text": "Some introduction text…\n\nCartesian and Spherical Coordinates\nA clear distinction has been made between cartesian and spherical coordinates and cartesian and spherical elements. The former are used to describe the domain in which the vector is defined, while the latter are used to describe the vector and its components itself. For example, a position vector in a cartesian coordinate system, \\(\\boldsymbol{\\mathbf{x}}\\), can be expressed in cartesian elements \\(\\left(x, y, z\\right)\\), which are the x-, y-, and z-components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}= \\begin{bmatrix}\n        x\\\\\n        y\\\\\n        z\n    \\end{bmatrix} \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n    \\label{eq:cartesian_coordinate}\n\\end{equation}\\]\n\n\nVectors defining a position or a velocity in a cartesian coordinate system and in cartesian elements, like the one shown in Eq. \\(\\eqref{eq:cartesian_coordinate}\\):\n GlobalCartesianPosition\n GlobalCartesianVelocity\nThe same vector in the same coordinate system and, thus, the same domain, can also be expressed used spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\), which are the radial, azimuthal, and elevation components of the vector: \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{x}}_s = \\begin{bmatrix}\n        r\\cos\\vartheta\\cos\\varphi\\\\\n        r\\sin\\vartheta\\cos\\varphi\\\\\n        r\\sin\\varphi\n    \\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n\\end{equation}\\] Note that the subscript \\(s\\) indicates that the vector is expressed in spherical elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s\\). On the other hand, a coordinate can also be projected into a spherical coordiante system, \\(\\boldsymbol{\\mathbf{r}}\\), which is a different domain, and expressed in spherical elements \\(\\left(r, \\vartheta, \\varphi\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}= \\begin{bmatrix}r\\\\ \\vartheta\\\\ \\varphi\\end{bmatrix} \\qquad\\text{with }r\\in\\mathbb{R}^+,\\;\\vartheta\\in\\left[-\\pi,\\pi\\right),\\;\\varphi\\in\\left[-\\frac{\\pi}{2},\\frac{\\pi}{2}\\right].\n    \\label{eq:spherical_coordinate}\n\\end{equation}\\]\nThe same coordinate can also be expressed in cartesian elements \\(\\left(x, y, z\\right)\\): \\[\\begin{equation}\n    \\boldsymbol{\\mathbf{r}}_c = \\begin{bmatrix}\n        \\sqrt{x^2 + y^2 + z^2} \\\\\n        \\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\\\\n        \\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\n    \\end{bmatrix}  \\qquad\\text{with } x\\in\\mathbb{R},\\;y\\in\\mathbb{R},\\;z\\in\\mathbb{R}.\n\\end{equation}\\]\n\n\nVectors defining a position or a velocity in a spherical coordinate system and in spherical elements, like the one shown in Eq. \\(\\eqref{eq:spherical_coordinate}\\):\n GlobalSphericalPosition\n GlobalSphericalVelocity\nNote that the subscript \\(c\\) indicates that the vector is expressed in cartesian elements. Both vectors describe the same coordinate in the same coordinate system, thus \\(\\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). Even though, physically speaking, all four coordinate vectors can describe the same position in physical space, mathematically speaking, they are different vectors, thus: \\(\\boldsymbol{\\mathbf{x}}= \\boldsymbol{\\mathbf{x}}_s \\neq \\boldsymbol{\\mathbf{r}}= \\boldsymbol{\\mathbf{r}}_c\\). The following sections will go into more detail about the differences of these coordinate systems, where the names and are used to describe the domain and not the elements.\nAll coordinate vectors can also be written as a sum of scaled base vectors, where the base vectors are the unit vectors of the respective coordinate system. The base vectors of any cartesian coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_x= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_y= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the cartesian coordinate vector, for both in cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{x}}&= x\\hat{\\boldsymbol{\\mathbf{e}}}_x+ y\\hat{\\boldsymbol{\\mathbf{e}}}_y+ z\\hat{\\boldsymbol{\\mathbf{e}}}_z\\nonumber \\\\\n    &= \\left(r\\cos\\vartheta\\cos\\varphi\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\left(r\\sin\\vartheta\\cos\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\left(r\\sin\\varphi\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_z= \\boldsymbol{\\mathbf{x}}_s.\n\\end{align}\\] Similarly, the base vectors of any spherical coordinate system are: \\[\\begin{equation}\n    \\hat{\\boldsymbol{\\mathbf{e}}}_r= \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta= \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\text{,}\\qquad\\text{and}\\qquad\n    \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n\\end{equation}\\] which leads to the following expression for the spherical coordinate vector, for both in cartesian and spherical elements: \\[\\begin{align}\n    \\boldsymbol{\\mathbf{r}}&= r\\hat{\\boldsymbol{\\mathbf{e}}}_r+ \\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ \\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\nonumber \\\\\n    &= \\left(\\sqrt{x^2 + y^2 + z^2}\\right)\\hat{\\boldsymbol{\\mathbf{e}}}_r+ \\left(\\mathop{\\mathrm{sgn}}\\left(y\\right)\\cdot\\cos^{-1}\\left(\\frac{x}{\\sqrt{x^2 + y^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ \\left(\\sin^{-1}\\left(\\frac{z}{\\sqrt{x^2 + y^2 + z^2}}\\right)\\right) \\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi\\\\\n    &= \\boldsymbol{\\mathbf{r}}_c.\\nonumber\n\\end{align}\\]\nDue to the equalities of the vectors in their respective same coordinate system, the rest of this work will only use \\(\\boldsymbol{\\mathbf{x}}\\) and \\(\\boldsymbol{\\mathbf{r}}\\) without their indexed counterparts. The element type will be indicated by the context of the equation.\n\n\nSpacial Differentials\nThis work is regularly relying on vector calculus which includes a substantial use of differentials and derivatives. The former uses two kinds of notations, depending on the use case of the differential. First, mathematical differentials of vectors are the vectorized form of the differentials of the vector components. In the following, the differentials will be set up for stationary conditions with constant base vectors, i.e.\n\\[\\begin{align}\n    \\frac{\\partial}{\\partial t} &= 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial r} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_x}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_y}{\\partial\\varphi} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial r} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\vartheta} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_z}{\\partial\\varphi} = 0, \\\\\n    \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial x} &= \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_r}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta}{\\partial z} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial x} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial y} = \\frac{\\partial\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi}{\\partial z} = 0.\n\\end{align}\\]\nFor example, the differential of a stationary cartesian coordinate vector and cartesian elements is\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{x}}= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial z}dz= dx\\hat{\\boldsymbol{\\mathbf{e}}}_x+ dy\\hat{\\boldsymbol{\\mathbf{e}}}_y+ dz\\hat{\\boldsymbol{\\mathbf{e}}}_z= \\begin{bmatrix} dx\\\\ dy\\\\ dz\\end{bmatrix},\n\\end{equation}\\]\nand for spherical coordinates and elements\n\\[\\begin{equation}\n    d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial\\varphi}d\\varphi= dr\\hat{\\boldsymbol{\\mathbf{e}}}_r+ d\\vartheta\\hat{\\boldsymbol{\\mathbf{e}}}_\\vartheta+ d\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_\\varphi= \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}.\n\\end{equation}\\]\nThe above total differentials are relatively simple to set up since their respective partial differentials cancel out to only contain one variable each. However, the differentials for the cartesian vector in spherical elements and the spherical vector in cartesian elements are more complicated, with the former differential given by\n\\[\\begin{align}\n    d\\boldsymbol{\\mathbf{x}}&= \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial r}dr+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\vartheta}d\\vartheta+ \\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\varphi}d\\varphi\\\\\n    &= \\left(\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ \\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ \\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) dr\\nonumber \\\\\n    &+ \\left(-r\\sin\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x+ r\\cos\\vartheta\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y\\right) d\\vartheta\\nonumber \\\\\n    &+ \\left(-r\\cos\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_x- r\\sin\\vartheta\\sin\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_y+ r\\cos\\varphi\\hat{\\boldsymbol{\\mathbf{e}}}_z\\right) d\\varphi\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi&  -r\\sin\\vartheta\\cos\\varphi& -r\\cos\\vartheta\\sin\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi& r\\cos\\vartheta\\cos\\varphi& - r\\sin\\vartheta\\sin\\varphi\\\\\n        \\sin\\varphi& 0 & r\\cos\\varphi\n    \\end{bmatrix} \\begin{bmatrix} dr\\\\ d\\vartheta\\\\ d\\varphi\\end{bmatrix}  \\label{eq:total_cartesian_spherical_differential_matrix}\\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi dr-r\\sin\\vartheta\\cos\\varphi d\\vartheta-r\\cos\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\vartheta\\cos\\varphi dr+ r\\cos\\vartheta\\cos\\varphi d\\vartheta- r\\sin\\vartheta\\sin\\varphi d\\varphi\\\\\n        \\sin\\varphi dr+ r\\cos\\varphi d\\varphi\n    \\end{bmatrix}. \\label{eq:total_cartesian_spherical_differential}\n\\end{align}\\]\nThe resulting vector in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential}\\) contains the scalar differentials of the spherical elements in each of its entries, which can also be pulled out of the vector and written as a linear combination using a matrix notation, shown in Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\). While the differential of a spherical vector in cartesian elements can be calculated in the same way, which is \\(d\\boldsymbol{\\mathbf{r}}= \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial x}dx+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial y}dy+ \\frac{\\partial\\boldsymbol{\\mathbf{r}}}{\\partial z}dz\\), its trigonometric functions and subsequent differentiations make it less common and inefficient to use, which is why it is not shown here for brevity.\nThese vectorized total differentials are regularly used in vector calculus. A prime example is calculating the gradient \\(\\nabla\\) of a scalar function \\(f\\), which is given by \\[\\begin{equation}\n    \\frac{df}{d\\boldsymbol{\\mathbf{x}}} = \\nabla f = \\begin{bmatrix}\n        \\frac{\\partial f}{\\partial x} \\\\\n        \\frac{\\partial f}{\\partial y} \\\\\n        \\frac{\\partial f}{\\partial z}\n    \\end{bmatrix},\n\\end{equation}\\] as an example in a cartesian coordinate system and with cartesian elements. Many problems feature the second-order derivatives of a scalar function, which is called the Laplacian \\(\\nabla^2\\) and is given by \\[\\begin{equation}\n    \\nabla \\cdot \\nabla f = \\nabla^2 f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}.\n\\end{equation}\\]\nBoth the gradient and the laplacian can also be expressed in spherical coordinates. The former makes use of the chain rule of differentiation, which evaluates to the inverse matrix of the coordinate projection of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\): \\[\\begin{align}\n    \\begin{bmatrix}\n        \\frac{\\partial}{\\partial x} \\\\\n        \\frac{\\partial}{\\partial y} \\\\\n        \\frac{\\partial}{\\partial z}\n    \\end{bmatrix} &= \\begin{bmatrix}\n        \\frac{\\partial r}{\\partial x} & \\frac{\\partial\\vartheta}{\\partial x} & \\frac{\\partial\\varphi}{\\partial x} \\\\\n        \\frac{\\partial r}{\\partial y} & \\frac{\\partial\\vartheta}{\\partial y} & \\frac{\\partial\\varphi}{\\partial y} \\\\\n        \\frac{\\partial r}{\\partial z} & \\frac{\\partial\\vartheta}{\\partial z} & \\frac{\\partial\\varphi}{\\partial z}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix} \\\\\n    &= \\begin{bmatrix}\n        \\cos\\vartheta\\cos\\varphi& -\\frac{\\sin\\vartheta}{r\\cos\\varphi} & -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\vartheta\\cos\\varphi& \\frac{\\cos\\vartheta}{r\\cos\\varphi} & -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\\\\n        \\sin\\varphi& 0 & \\frac{\\cos\\varphi}{r}\n    \\end{bmatrix}\\begin{bmatrix}\n        \\frac{\\partial}{\\partial r} \\\\\n        \\frac{\\partial}{\\partial\\vartheta} \\\\\n        \\frac{\\partial}{\\partial\\varphi}\n    \\end{bmatrix}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial x} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_x}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial y} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\label{eq:spherical_gradient_y}\\\\\n    \\Rightarrow\\qquad \\frac{\\partial}{\\partial z} &= \\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}. \\label{eq:spherical_gradient_z}\n\\end{align}\\] The latter can be derived by applying the chain rule twice, which is a tedious but straightforward calculation, leading to: \\[\\begin{align}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right). \\label{eq:laplace_spherical}\n\\end{align}\\]\n\n\n\n\n\n\nDerivation of spherical Laplace operator.\n\n\n\nThe laplacian is the linear summation of the second-order cartesian partial derivative \\(\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\). The spherical laplacian can be derived by applying the chain rule of partial derivatives, shown in the gradient derivation in Eqs. \\(\\eqref{eq:spherical_gradient_x}\\), \\(\\eqref{eq:spherical_gradient_y}\\), \\(\\eqref{eq:spherical_gradient_z}\\) twice: \\[\\begin{align*}\n    \\frac{\\partial^2}{\\partial x^2} &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial x} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial x} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial x} \\\\\n    &= \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\right) \\\\\n    &- \\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\cos\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} -\\frac{\\sin\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\cos\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial y^2} &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial y} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta}\\frac{\\partial}{\\partial y} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial y} \\\\\n    &= \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &+ \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    &- \\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( \\sin\\vartheta\\cos\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\vartheta}{r\\cos\\varphi} \\frac{\\partial}{\\partial\\vartheta} -\\frac{\\sin\\vartheta\\sin\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) \\\\\n    %\n    \\frac{\\partial^2}{\\partial z^2} &= \\sin\\varphi\\frac{\\partial}{\\partial r}\\frac{\\partial}{\\partial z} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi}\\frac{\\partial}{\\partial z} \\\\\n    &= \\sin\\varphi\\frac{\\partial}{\\partial r} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right) + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\left( -\\sin\\varphi\\frac{\\partial}{\\partial r} + \\frac{\\cos\\varphi}{r} \\frac{\\partial}{\\partial\\varphi} \\right).\n\\end{align*}\\] Evaluating all partial derivatives and summing up all terms leads to a miraculous cancellation of terms, finally arriving at the following expression of Eq.~(\\(\\ref{eq:laplace_spherical}\\)) for the Laplacian in spherical coordinates: \\[\\begin{align*}\n    \\nabla^2 &= \\frac{\\partial^2}{\\partial r^2} + \\frac{2}{r}\\frac{\\partial}{\\partial r} + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2} \\frac{\\partial^2}{\\partial\\varphi^2} - \\frac{\\sin\\varphi}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\\\\n    &= \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\cos^2\\varphi}\\frac{\\partial}{\\partial\\vartheta} + \\frac{1}{r^2\\cos\\varphi} \\frac{\\partial}{\\partial\\varphi} \\left(\\cos\\varphi\\frac{\\partial}{\\partial\\varphi}\\right).\n\\end{align*}\\]\n\n\nAnother example of the use of differentials is in integration, where it is used to represent an infinitesimal change in the variable. Shorthand versions of multi-dimensional integrals are often written using vector variables, such as \\[\\begin{equation}\n    \\int_X \\int_Y \\int_Z f dzdydx= \\int_Vf d^3\\boldsymbol{\\mathbf{x}},\n\\end{equation}\\] where \\(V\\) is the volume of the integration domain, with the infinitesimal volume element \\(d^3\\boldsymbol{\\mathbf{x}}\\in V= \\left\\{dx\\, dy\\, dz\\; | \\; dx\\in X, dy\\in Y, dz\\in Z \\right\\}\\). The superscript \\(\\bullet^3\\) in the differentials indicates that the differential is a vector but a scalar representation of the element’s size created by the vector elements. As before, the differential \\(d^3\\boldsymbol{\\mathbf{x}}\\) can also be expressed in spherical elements by using the Jacobian determinant, which is equal to the matrix of Eq. \\(\\eqref{eq:total_cartesian_spherical_differential_matrix}\\), of the transformation: \\[\\begin{equation}\n    d^3\\boldsymbol{\\mathbf{x}}= \\left|\\frac{\\partial\\boldsymbol{\\mathbf{x}}}{\\partial\\boldsymbol{\\mathbf{r}}}\\right| d^3\\boldsymbol{\\mathbf{r}}= r^2\\cos\\varphi drd\\vartheta d\\varphi.\n\\end{equation}\\] Figure 1 illustrates the spherical differential element \\(d^3\\boldsymbol{\\mathbf{r}}\\) in a three-dimensional cartesian coordinate system. The azimuth angle \\(\\vartheta\\) rotates inside of the \\(x\\)–\\(y\\) plane, while the elevation angle \\(\\varphi\\) rotates the vector out of that plane in \\(z\\) direction. While the azimuth arc decreases with the sine of the elevation angle, the small angle approximation can be used to approximate the differential element as a cuboid with the volume \\(d^3\\boldsymbol{\\mathbf{r}}\\approx r^2 \\sin\\varphi\\, drd\\vartheta d\\varphi\\).\n\n Figure LaTeX\n\n\n\n\n\n\n\n\n\nFigure 1: Three-dimensional sketch of a spherical differential element in a cartesian coordinate system.\n\n\n\n\n% based on: https://tikz.net/spherical_volume/\n\n%Axis Angles\n\\tdplotsetmaincoords{70}{110}\n\n%Macros\n\\pgfmathsetmacro{\\rvec}{6}\n\\pgfmathsetmacro{\\elevationvec}{40}\n\\pgfmathsetmacro{\\azimuthvec}{45}\n\n\\pgfmathsetmacro{\\dazimuthvec}{20}\n\\pgfmathsetmacro{\\delevationvec}{20}\n\\pgfmathsetmacro{\\drvec}{1.5}\n\n%Layers\n\\pgfdeclarelayer{background}\n\\pgfdeclarelayer{foreground}\n\n\\pgfsetlayers{background, main, foreground}\n\n\\begin{tikzpicture}[tdplot_main_coords]\n    \n    %Coordinates\n    \\coordinate (O) at (0,0,0);\n    %\n    \\tdplotsetcoord{A}{\\rvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{B}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{C}{\\rvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{D}{\\rvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    %\n    \\tdplotsetcoord{E}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec}\n    \\tdplotsetcoord{F'}{\\rvec + \\drvec}{90}{\\azimuthvec}\n    \\tdplotsetcoord{G}{\\rvec + \\drvec}{\\elevationvec + \\delevationvec}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{G'}{\\rvec + \\drvec}{90}{\\azimuthvec + \\dazimuthvec}\n    \\tdplotsetcoord{H}{\\rvec + \\drvec}{\\elevationvec}{\\azimuthvec + \\dazimuthvec}\n    \n    %Axis\n    \\begin{pgfonlayer}{background}\n        \\draw[thick,-latex] (0,0,0) -- (7,0,0) node[pos=1.1]{$\\cartesianCoordinateX$};\n        \\draw[thick,-latex] (0,0,0) -- (0,7,0) node[pos=1.05]{$\\cartesianCoordinateY$};\n        \\draw[thick,-latex] (0,0,0) -- (0,0,6) node[pos=1.05]{$\\cartesianCoordinateZ$};\n    \\end{pgfonlayer}\n    \n    %Help Lines\n    \\begin{pgfonlayer}{background}\n        %Up\n        \\draw[thick, black] (O) -- (A) node[pos=0.6, above left, black] {$\\sphericalCoordinateRadius$};\n        \\draw (O) -- (B);\n        \\draw (O) -- (C);\n        \\draw[dashed] (O) -- (D);\n        %Down\n        \\draw (O) -- (F');\n        \\draw (O) -- (G');\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        %%Help Curves\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotsetthetaplanecoords{\\azimuthvec+\\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, dashed]{(O)}{\\rvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords]{(O)}{\\rvec+\\drvec}{\\elevationvec+\\delevationvec}{90}{}{}\n        %\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n        \\node[rotate=13] at (3,4.45,0) {$\\sphericalCoordinateRadius\\sin\\sphericalCoordinateElevation d\\sphericalCoordinateAzimuth$};\n        \\tdplotdrawarc[tdplot_main_coords]{(O)}{\\rvec+\\drvec}{\\azimuthvec}{\\azimuthvec+\\dazimuthvec}{}{}\n    \\end{pgfonlayer}\n    \n    \n    %Angles\n    \\begin{pgfonlayer}{foreground}\n        %Phi, dPhi\n        \\tdplotdrawarc[-stealth]{(O)}{0.9}{0}{\\azimuthvec}{anchor=north}{$\\sphericalCoordinateAzimuth$}\n        \\tdplotdrawarc[-stealth]{(O)}{1.5}{\\azimuthvec}{\\azimuthvec + \\dazimuthvec}{}{}\n        \\node at (1.4,1.9,0) {$ d\\sphericalCoordinateAzimuth$};\n        \n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \n        %Theta, dTheta\n        \\tdplotdrawarc[tdplot_rotated_coords, -stealth]{(0,0,0)}{1.2}{90}{\\elevationvec + \\delevationvec}{}{}\n        %\\node at (0,0.3,1.3) {$\\sphericalCoordinateElevation$};\n        \\node at (1,1.25,0.55) {$\\sphericalCoordinateElevation$};\n        \\tdplotdrawarc[tdplot_rotated_coords, stealth-]{(0,0,0)}{2.}{\\elevationvec}{\\elevationvec + \\delevationvec}{anchor=south west}{$ d\\sphericalCoordinateElevation$}\n    \\end{pgfonlayer}\n    \n    %Differential Volume\n    \n    %%Lines\n    \\begin{pgfonlayer}{foreground}\n        \\draw[thick] (A) -- (E) node[midway, above left]{$ d\\sphericalCoordinateRadius$};\n        \\draw[thick] (B) -- (F);\n        \\draw[thick] (C) -- (G);\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        \\draw[dashed, thick] (D) -- (H);\n    \\end{pgfonlayer}\n    \n    \n    %%Curved\n    \\begin{pgfonlayer}{background}\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[dashed, tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n    \\end{pgfonlayer}\n    \\begin{pgfonlayer}{foreground}\n        \\tdplotsetthetaplanecoords{\\azimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{below left}{$\\sphericalCoordinateRadius d\\sphericalCoordinateElevation$}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetthetaplanecoords{\\azimuthvec + \\dazimuthvec}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{\\elevationvec}{\\delevationvec + \\elevationvec}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-50.4313}{-6.4086}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{12.8173}{}{}\n        %\n        \\tdplotsetrotatedcoords{55}{-30.3813}{-8.6492}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec}{0}{17.2983}{}{}\n        \\tdplotdrawarc[tdplot_rotated_coords, thick]{(O)}{\\rvec + \\drvec}{0}{17.2983}{}{}\n    \\end{pgfonlayer}\n    \n    %Fill Color\n    \\begin{pgfonlayer}{main}\n        %Front\n        \\fill[black, opacity=0.15] (E) to (A)  to[bend left=4] (B) to (F) to[bend right=4] cycle;\n        \\fill[black, opacity=0.6] (E) to[bend left=4] (F)  to[bend left=2] (G) to[bend right=6.5] (H) to[bend right=4] cycle;\n        \\fill[black, opacity=0.4] (F) to[bend left=2] (G) to[bend left=1.5] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\end{pgfonlayer}\n    \\begin{pgfonlayer}{background}\n        %Back\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to[bend left=6] (C) to[bend right=2.5] (B) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (A) to[bend left=2] (D) to (H) to[bend right=2.5] (E) to[bend right=4] cycle;\n        \\fill[black!50, opacity=0.5] (D) to (H) to[bend left=6] (G) to[bend right=2] (C) to[bend right=6] cycle;\n    \\end{pgfonlayer}\n        \n\\end{tikzpicture}\n\n\n\n\n\nTemporal Differentials\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/trajectories/non-ballistic_trajectories.html",
    "href": "documentation/trajectories/non-ballistic_trajectories.html",
    "title": "5.2 Non-Ballistic Trajectories",
    "section": "",
    "text": "CitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html",
    "href": "documentation/trajectories/ballistic_trajectories.html",
    "title": "5.1 Ballistic Trajectories",
    "section": "",
    "text": "Intro"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-azimuth-angle",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-azimuth-angle",
    "title": "5.1 Ballistic Trajectories",
    "section": "Azimuth Angle – \\(\\vartheta\\)",
    "text": "Azimuth Angle – \\(\\vartheta\\)\nThe azimuth angle \\(\\vartheta\\) can be calculated using the following multi-case definition: \\[\\begin{equation}\n    \\vartheta\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\begin{cases}\n        \\cos^{-1}\\left(v_2/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2\\geq0\\\\\n        -\\cos^{-1}\\left(v_2/\\sqrt{v_1^2 + v_2^2}\\right) & \\text{for } v_2&lt;0\n    \\end{cases} \\label{eq:azimuth_angle_v}\n\\end{equation}\\] with a local cartesian velocity vector \\(\\boldsymbol{\\mathbf{v}}= \\left[v_1, v_2, v_3\\right]^T\\). The equation can be rewritten as a single-case equation, avoiding the inverse cosine expression: \\[\\begin{equation}\n    \\cos\\vartheta= \\frac{v_2}{\\sqrt{v_1^2+v_2^2}}.\n\\end{equation}\\]  azimuth_angle_v: \\(\\vartheta\\left(\\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:azimuth_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-eccentric-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-eccentric-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "Ecccentric Anomaly – \\(E\\)",
    "text": "Ecccentric Anomaly – \\(E\\)\n\\[\\begin{align}\n    E\\left(e, \\theta\\right) &= \\begin{cases}\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) & \\text{for } 0\\leq\\theta&lt;\\pi\\\\\n        2 \\tan^{-1}\\left( \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\frac{\\theta}{2}\\right) \\right) + 2\\pi & \\text{for } \\pi\\leq\\theta&lt;2\\pi\n    \\end{cases}  \\label{eq:eccentric_anomaly_e_theta} \\\\[3mm]\n     E_{i+1}\\left(e, M, E_i\\right) &= M+ e\\sin E_i \\quad\\text{ with }\\quad E_0 = M\\label{eq:eccentric_anomaly_e_M}\n\\end{align}\\] Similar to the azimuth angle before, Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\) can be rewritten as a single-case equation, avoiding the inverse tangent expression: \\[\\begin{equation}\n    \\tan\\left(E/2\\right) = \\sqrt{\\frac{1-e}{1+e}} \\cdot \\tan\\left(\\theta/2\\right).\n\\end{equation}\\]  eccentric_anomaly_e_theta: \\(E\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)   eccentric_anomaly_e_M: \\(E\\left(e, M\\right)\\): Eq. \\(\\eqref{eq:eccentric_anomaly_e_M}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-eccentricity",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-eccentricity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Eccentricity – \\(e\\)",
    "text": "Eccentricity – \\(e\\)\n\\[\\begin{align}\n    e\\left(\\epsilon_{kin}, \\psi\\right) &= \\sqrt{1 - 4 \\epsilon_{kin}\\cdot (1 - \\epsilon_{kin}) \\cdot \\sin^2 \\psi}  \\label{eq:eccentricity_epskin_psi} \\\\\n    e\\left(a, p\\right) &= \\sqrt{1 - \\frac{p}{a}}  \\label{eq:eccentricity_a_p} \\\\\n    e\\left(r, p, \\theta\\right) &= \\frac{1}{\\cos\\theta}\\cdot\\left(\\frac{p}{r} - 1\\right)  \\label{eq:eccentricity_r_p_theta} \\\\\n    e\\left(E, M\\right) &= \\frac{E- M}{\\sin E}  \\label{eq:eccentricity_E_M}\n\\end{align}\\]\n\n\n eccentricity_epskin_psi: \\(e\\left(\\epsilon_{kin}, \\psi\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\)\n eccentricity_epskin_v: \\(e\\left(\\epsilon_{kin}, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\) with \\(v=v(\\psi)\\) from Eq. \\(\\eqref{eq:zenith_angle_v}\\)\n eccentricity_r_m_v: \\(e\\left(r, m, v\\right)\\): Eq. \\(\\eqref{eq:eccentricity_epskin_psi}\\) with \\(\\epsilon_{kin}=\\epsilon_{kin}\\left(v_{esc}(r,m),v\\right)\\) from Eqs. \\(\\eqref{eq:escape_velocity_r_m}\\) and \\(\\eqref{eq:relative_Ekin_v_vesc}\\), and with \\(v=v(\\psi)\\) from Eq. \\(\\eqref{eq:zenith_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-escape-velocity",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-escape-velocity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Escape Velocity – \\(v_{esc}\\)",
    "text": "Escape Velocity – \\(v_{esc}\\)\n\\[\\begin{equation}\n    v_{esc}\\left(r, m\\right) = \\sqrt{\\frac{2 Gm}{r}} \\label{eq:escape_velocity_r_m}\n\\end{equation}\\]\n\n\n escape_velocity_r_m: \\(v_{esc}\\left(r, m\\right)\\): Eq. \\(\\eqref{eq:escape_velocity_r_m}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-ground-track-distance",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-ground-track-distance",
    "title": "5.1 Ballistic Trajectories",
    "section": "Ground Track Distance – \\(d\\)",
    "text": "Ground Track Distance – \\(d\\)\n\\[\\begin{equation}\n    d\\left(r, \\Delta\\theta\\right) = r\\cdot \\Delta\\theta\\label{eq:ground_track_distance_r_dtheta}\n\\end{equation}\\]\n\n\n ground_distance_R_dtheta: \\(d\\left(r, \\theta\\right)\\): Eq. \\(\\eqref{eq:ground_track_distance_r_dtheta}\\)\n ground_distance_R_a_e: \\(d\\left(r, a, e\\right)\\): Eq. \\(\\eqref{eq:ground_track_distance_r_dtheta}\\) with \\(\\Delta\\theta= 2\\pi - 2\\theta\\) and \\(\\theta= \\theta\\left(r, a, e\\right)\\) of Eq. \\(\\eqref{eq:true_anomaly_r_a_e}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-mean-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-mean-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "Mean Anomaly – \\(M\\)",
    "text": "Mean Anomaly – \\(M\\)\n\\[\\begin{equation}\n    M\\left(e, E\\right) = E- e\\sin E\\label{eq:mean_anomaly_e_E}\n\\end{equation}\\]\n\n\n mean_anomaly_e_E: \\(M\\left(e, E\\right)\\): Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\)\n mean_anomaly_e_theta: \\(M\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\) with \\(E=E(e, \\theta)\\) from Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-period",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-period",
    "title": "5.1 Ballistic Trajectories",
    "section": "Orbit Period – \\(P\\)",
    "text": "Orbit Period – \\(P\\)\n\\[\\begin{equation}\n    P\\left(a, m\\right) = 2\\pi\\sqrt{\\frac{a^3}{Gm}}  \\label{eq:orbit_period_a_m}\n\\end{equation}\\]\n\n\n orbit_period_a_m: \\(P\\left(a, m\\right)\\): Eq. \\(\\eqref{eq:orbit_period_a_m}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-time",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-orbit-time",
    "title": "5.1 Ballistic Trajectories",
    "section": "Orbit Time – \\(t\\)",
    "text": "Orbit Time – \\(t\\)\n\\[\\begin{equation}\n    t\\left(M, P\\right) = \\frac{M}{2\\pi} \\cdot P\\label{eq:orbit_time_M_P}\n\\end{equation}\\]\n\n\n orbit_time_M_P: \\(t\\left(M, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\)\n orbit_time_e_E_P: \\(t\\left(e, E, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\) with \\(M= M(e, E)\\) of Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\)\n orbit_time_e_theta_P: \\(t\\left(e, \\theta, P\\right)\\): Eq. \\(\\eqref{eq:orbit_time_M_P}\\) with \\(M= M(e, E)\\) of Eq. \\(\\eqref{eq:mean_anomaly_e_E}\\) and \\(E= E\\left(e, \\theta\\right)\\) of Eq. \\(\\eqref{eq:eccentric_anomaly_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-relative-kinetic-energy",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-relative-kinetic-energy",
    "title": "5.1 Ballistic Trajectories",
    "section": "Relative Kinetic Energy – \\(\\epsilon_{kin}\\)",
    "text": "Relative Kinetic Energy – \\(\\epsilon_{kin}\\)\n\\[\\begin{align}\n    \\epsilon_{kin}\\left(\\boldsymbol{\\mathbf{v}}, v_{esc}\\right) &= \\left(\\frac{|\\boldsymbol{\\mathbf{v}}|}{v_{esc}}\\right)^2  \\label{eq:relative_Ekin_v_vesc} \\\\\n    \\epsilon_{kin}\\left(r, a\\right) &= 1 - \\frac{r}{2a}  \\label{eq:relative_Ekin_r_a} \\\\\n    \\epsilon_{kin}\\left(e, \\theta\\right) &= 1 - \\frac{1 - e^2}{2 + 2e\\cos\\left(\\theta\\right)}  \\label{eq:relative_Ekin_e_theta}\n\\end{align}\\]\n\n\n epskin_vesc_v: \\(\\epsilon_{kin}\\left(\\boldsymbol{\\mathbf{v}}, v_{esc}\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_v_vesc}\\)\n epskin_r_m_v: \\(\\epsilon_{kin}\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_v_vesc}\\) with \\(v_{esc} = v_{esc}\\left(r, m\\right)\\) of Eq. \\(\\eqref{eq:escape_velocity_r_m}\\)\n epskin_r_a: \\(\\epsilon_{kin}\\left(r, a\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_r_a}\\)\n epskin_e_theta: \\(\\epsilon_{kin}\\left(e, \\theta\\right)\\): Eq. \\(\\eqref{eq:relative_Ekin_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-semi-latus-rectum",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-semi-latus-rectum",
    "title": "5.1 Ballistic Trajectories",
    "section": "Semi-Latus Rectum – \\(p\\)",
    "text": "Semi-Latus Rectum – \\(p\\)\n\\[\\begin{align}\n    p\\left(a, e\\right) &= a\\cdot (1 - e^2)  \\label{eq:semi_latus_rectum_a_e} \\\\\n    p\\left(r, e, \\theta\\right) &= r\\cdot \\left(1 + e\\cdot \\cos \\theta\\right)  \\label{eq:semi_latus_rectum_r_e_theta}\n\\end{align}\\]\n\n\n semi_latus_rectum_a_e: \\(p\\left(a, e\\right)\\): Eq. \\(\\eqref{eq:semi_latus_rectum_a_e}\\)\n semi_latus_rectum_r_e_theta: \\(p\\left(r, e, \\theta\\right)\\): Eq. \\(\\eqref{eq:semi_latus_rectum_r_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-semi-major-axis",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-semi-major-axis",
    "title": "5.1 Ballistic Trajectories",
    "section": "Semi-Major Axis – \\(a\\)",
    "text": "Semi-Major Axis – \\(a\\)\n\\[\\begin{align}\n    a\\left(r, \\epsilon_{kin}\\right) &= \\frac{r}{2 \\cdot \\left(1 - \\epsilon_{kin}\\right)}  \\label{eq:semi_major_axis_r_epskin} \\\\\n    a\\left(p, e\\right) &= \\frac{p}{1 - e^2}  \\label{eq:semi_major_axis_p_e}\n\\end{align}\\]\n\n\n semi_major_axis_r_epskin: \\(a\\left(r, \\epsilon_{kin}\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_r_epskin}\\)\n semi_major_axis_r_m_v: \\(a\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_r_epskin}\\) with \\(\\epsilon_{kin}=\\epsilon_{kin}\\left(r, m, \\boldsymbol{\\mathbf{v}}\\right)\\) and \\(v_{esc}=v_{esc}\\left(r, m\\right)\\) of Eqs. \\(\\eqref{eq:relative_Ekin_v_vesc}\\) and \\(\\eqref{eq:escape_velocity_r_m}\\)\n semi_major_axis_p_e: \\(a\\left(p, e\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_p_e}\\)\n semi_major_axis_r_e_theta: \\(a\\left(r, e, \\theta\\right)\\): Eq. \\(\\eqref{eq:semi_major_axis_p_e}\\) with \\(p=p\\left(r, e, \\theta\\right)\\) of Eq. \\(\\eqref{eq:semi_latus_rectum_r_e_theta}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-true-anomaly",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-true-anomaly",
    "title": "5.1 Ballistic Trajectories",
    "section": "True Anomaly – \\(\\theta\\)",
    "text": "True Anomaly – \\(\\theta\\)\n\\[\\begin{align}\n    \\theta\\left(r, a, e\\right) &= \\cos^{-1}\\left(\\frac{1}{e} \\cdot \\left(\\frac{a}{r} \\left( 1 - e^2 \\right) -1 \\right)\\right)  \\label{eq:true_anomaly_r_a_e} \\\\\n    \\theta\\left(e, \\epsilon_{kin}\\right) &= \\cos^{-1}\\left(\\frac{1}{e} \\cdot \\left(\\frac{1 - e^2}{2-2 \\epsilon_{kin}} -1 \\right)\\right)  \\label{eq:true_anomaly_e_epskin}\n\\end{align}\\]\n\n\n true_anomaly_r_a_e: \\(\\theta\\left(r, a, e\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_r_a_e}\\)\n true_anomaly_e_epskin: \\(\\theta\\left(e, \\epsilon_{kin}\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_e_epskin}\\)\n true_anomaly_epskin_v: \\(\\theta\\left(\\epsilon_{kin}, \\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:true_anomaly_epskin_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#sec-zenith-angle",
    "href": "documentation/trajectories/ballistic_trajectories.html#sec-zenith-angle",
    "title": "5.1 Ballistic Trajectories",
    "section": "Zenith Angle – \\(\\psi\\)",
    "text": "Zenith Angle – \\(\\psi\\)\n\\[\\begin{equation}\n    \\psi\\left(\\boldsymbol{\\mathbf{v}}\\right) = \\tan^{-1}\\left(\\frac{\\sqrt{v_1^2 + v_2^2}}{v_3}\\right)  \\label{eq:zenith_angle_v}\n\\end{equation}\\]\n\n\n zenith_angle_v: \\(\\psi\\left(\\boldsymbol{\\mathbf{v}}\\right)\\): Eq. \\(\\eqref{eq:zenith_angle_v}\\)"
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "href": "documentation/trajectories/ballistic_trajectories.html#general-solution",
    "title": "5.1 Ballistic Trajectories",
    "section": "General Solution",
    "text": "General Solution\nThe following calculations are based on the orbital mechanics functions introduced above to calculate the landing position \\(\\left(\\Theta_1, \\Phi_1\\right)\\). Note that this approach is quasi-two-dimensional as the radial dimension of the spherical three-dimensional coordinate system is neglected, assuming a perfectly spherical central body. The trajectory starts and the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\) and, as mentioned above, requires knowledge about the mass and radius of the planetary body, \\(m\\) and \\(r\\), as well as the launch, or initial, velocity vector \\(\\boldsymbol{\\mathbf{v}}\\).\nBased on the escape velocity \\(v_{esc}(r, m)\\), the relative kinetic energy fraction \\(\\epsilon_{kin}(\\boldsymbol{\\mathbf{v}}, v_{esc})\\), can be determined, which in turn is used to calculate the semi-major axis of the trajectory, \\(a(r, \\epsilon_{kin})\\). Since the launch velocity vector is given in local cartesian coordinates, both its zenith angle \\(\\psi(\\boldsymbol{\\mathbf{v}})\\) and its azimuth angle \\(\\vartheta\\left(\\boldsymbol{\\mathbf{v}}\\right)\\) can be directly extracted. The former is subsequently used for the determination of the eccentricity \\(e\\left(\\epsilon_{kin}, \\psi\\right)\\). With both \\(a\\) and \\(e\\) known, the true anomaly at launch \\(\\theta_0(r, a, e)\\), and due to symmetry conditions, also the landing position \\(\\theta_1 = 2\\pi - \\theta_0\\), can be calculated. The angular difference between the landing and launch true anomaly \\(\\theta_1 - \\theta_0 = 2\\pi - 2\\theta= \\Delta\\theta\\) can then easily be converted into the ground track distance of the projected trajectory \\(d(r, \\Delta\\theta)\\).\nBased on Schoerghofer (2022), the landing position \\(\\left(\\Theta_1, \\Phi_1\\right)\\) can now be calculated using the launch position \\(\\left(\\Theta_0, \\Phi_0\\right)\\), the ground track distance \\(d\\), and the azimuth angle \\(\\vartheta\\) as \\[\\begin{align}\n    \\sin\\Phi_1 &= \\sin\\left(\\frac{d}{r}\\right) \\cdot \\cos\\Phi_0 \\cdot \\cos\\vartheta+ \\cos\\left(\\frac{d}{r}\\right) \\cdot \\sin\\Phi_0 \\\\\n    \\cos\\Delta\\Theta&= \\cos\\left(\\frac{d}{r}\\right) \\cdot \\cos\\Phi_0 - \\sin\\left(\\frac{d}{r}\\right) \\cdot \\sin\\Phi_0 \\cdot \\cos\\vartheta\\cdot \\cos^{-1}\\Phi_1 \\\\\n    \\Rightarrow \\Theta_1 &= \\Theta_0 + \\mathop{\\mathrm{sgn}}\\left(v_1\\right)\\cdot\\Delta\\Theta,\n\\end{align}\\] with the signum function \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = 1\\) for \\(v_1\\geq0\\) and \\(\\mathop{\\mathrm{sgn}}\\left(v_1\\right) = -1\\) for \\(v_1&lt;0\\).\nCalculating the time of flight \\(t_{flight}= t_1 - t_0 = P- 2t_0\\) requires the orbital period \\(P\\left(a, m\\right)\\) as well as the orbit time \\(t(M, P)\\), where \\(t_0\\) and \\(t_1\\) are the orbit times at the launch and landing, respectively, with \\(t_1 = P-t_0\\) for symmetry reasons. The mean anomaly \\(M_0\\) at launch can be calculated using the eccentric anomaly \\(E_0\\) and the eccentricity \\(e\\)."
  },
  {
    "objectID": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "href": "documentation/trajectories/ballistic_trajectories.html#simplification-for-uniform-gravity",
    "title": "5.1 Ballistic Trajectories",
    "section": "Simplification for Uniform Gravity",
    "text": "Simplification for Uniform Gravity\nParticles launched with small velocities are not reaching altitudes at which the gravitational acceleration changes significantly."
  },
  {
    "objectID": "documentation/acronyms.html#latex---glossary-acronyms-definition",
    "href": "documentation/acronyms.html#latex---glossary-acronyms-definition",
    "title": "Acronyms",
    "section": "LaTeX - Glossary Acronyms Definition",
    "text": "LaTeX - Glossary Acronyms Definition\n\\newacronym{ALSEP}{ALSEP}{Apollo Lunar Surface Experiments Package}\n\n\\newacronym{cdf}{cdf}{cumulative distribution function}\n\n\\newacronym{DLRE}{DLRE}{Diviner Lunar Radiometer Experiment}\n\n\\newacronym{ESA}{ESA}{European Space Agency}\n\n\\newacronym{LACE}{LACE}{Lunar Atmospheric Composition Experiment}\n\\newacronym{LADEE}{LADEE}{Lunar Atmosphere and Dust Environment Explorer}\n\\newacronym{LRO}{LRO}{Lunar Reconnaissance Orbiter}\n\n\\newacronym{HEALPix}{HEALPix}{Hierarchical Equal Area iso-Latitude Pixelization}\n\n\\newacronym{MBD}{MBD}{Maxwell-Boltzmann Distribution}\n\\newacronym{MBFD}{MBFD}{Maxwell-Boltzmann Flux Distribution}\n\n\\newacronym{NASA}{NASA}{National Aeronautis and Space Administration}\n\\newacronym{NMS}{NMS}{Neutral Mass Spectrometer}\n\n\\newacronym{pdf}{pdf}{probability density function}\n\\newacronym{PDS}{PDS}{Planetary Data System}\n\n\\newacronym{rms}{rms}{root mean squared}\n\n\\newacronym{SSE}{SSE}{Selenocentric Solar Ecliptic}\n\n\\newacronym{TUM}{TUM}{Technical University of Munich}"
  },
  {
    "objectID": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "href": "documentation/fundamentals/stats_mc.html#ensemble-averages",
    "title": "2.4 Statistics and Monte-Carlo",
    "section": "Ensemble Averages",
    "text": "Ensemble Averages\nThe analyses of this work will regularly include statements about a statistical ensemble of samples, i.e. of thermodynamic particles in equilibrium. Following Schörghofer (2022) derivation and notation, given any , \\(f(x)\\), the ensemble average of a quantity \\(Y\\) is \\[\\begin{equation}\n    \\langle Y \\rangle = \\int Yf(x)dx. \\label{eq:ensemble_average}\n\\end{equation}\\]"
  },
  {
    "objectID": "documentation/fundamentals/moon.html",
    "href": "documentation/fundamentals/moon.html",
    "title": "2.5 The Moon",
    "section": "",
    "text": "Some intro text…\n\nLunar Orbit Orientation\n\n\n Figure LaTeX Download\n\n\n\n\n\n\n\n\n\nFigure 1: Lunar orbit orientation sketch with the Earth as well as the ecliptic plane as a reference.\n\n\n\n\n\\begin{tikzpicture}\n\n    % ecliptic plane\n    \\draw (0,0) -- (8,0) \n        node[midway, below, xshift=20pt, yshift=2pt] {\\footnotesize Ecliptic Plane};\n\n    % earth\n    \\draw (2,0) circle (1);\n    \\draw[dotted] (2,-1.5) -- (2,1.5);\n    \\draw[rotate around={-23.44:(2,0)}] (2,-1.5) -- (2,1.5)\n        node[at end, right, xshift=-3pt, rotate=-23.44]{\\tiny{N}}\n        node[at start, left, xshift=3pt, rotate=-23.44]{\\tiny{S}};\n    \\draw[rotate around={-113.44:(2,0)}, dashed] (2,-1.5) -- (2,1.5);\n\n    % moon\n    \\begin{scope}[rotate around={5.14:(2,0)}]\n        % lunar orbit plane\n        \\draw (0,0) -- (8,0) \n            node[midway, above, rotate around={5.14:(2,0)}, xshift=20pt, yshift=4pt] {\\footnotesize Lunar Orbit Plane};\n        \n        %\n        \\draw (7.5,0) circle (0.25);\n        \\draw[dotted] (7.5,-0.4) -- (7.5,0.5);\n        \\draw[rotate around={-6.68:(7.5,0)}] \n            (7.5,-0.4) -- (7.5,0.5)\n            node[at end, right, xshift=-3pt]{\\tiny{N}}\n            node[at start, left, xshift=3pt]{\\tiny{S}};\n        \\draw[rotate around={-96.68:(7.5,0)}, dashed] (7.5,-0.5) -- (7.5,0.5);\n    \\end{scope}\n\n    % angles / arcs\n    \\draw[latex-latex] (2,0) ++(90:1.4) arc (90:66.56:1.4) \n        node[midway, above] {\\footnotesize \\begin{tabular}{c} Earth \\\\  Obliquity \\\\ \\SI{23.44}{\\degree} \\end{tabular}};\n\n    \\draw[latex-latex] (2,0) ++(0:4.5) arc (0:5.14:4.5);\n    \\draw[thin] (2,0) ++(5.14:4.5) arc (5.14:12:4.5) \n        node[at end, above, xshift=-10pt] {\\footnotesize \\begin{tabular}{c}Lunar Orbital \\\\ Inclination \\\\ \\SI{5.14}{\\degree}\\end{tabular}};\n\n    \\draw[latex-latex] (2,0) ++(5:5.9) arc (5:0:5.9);\n    \\draw[thin] (2,0) ++(0:5.9) arc (0:-3:9) \n        node[at end, below] {\\footnotesize \\begin{tabular}{c}\\SI{1.54}{\\degree} \\\\ Lunar Obliquity \\\\ to Ecliptic \\end{tabular}};\n\n\\end{tikzpicture}\n\n\n\n lunar_orbit_orientation.svg \n\n\n\n\n\nFigure 1 shows the Moon’s orientation in its orbit around its host planet, Earth. While the Sun has been removed from the sketch, the ecliptic plane, i.e., the plane in which the Earth is orbiting the Sun, is still shown to illustrate the Moon’s tilt towards it. Its orbit plane is inclined by with respect to the ecliptic plane; however, the Moon’s rotational axis itself is tilted in the opposite direction, resulting in an overall obliquity to the ecliptic of .\n\n\nLunar Surface Temperatures\nAboard the LRO the DLRE gathered infrared data of the lunar surface to create temperatures maps of the Moon.\n\n\n Figure Julia Downloads\n\n\n\n\n\n\n\n\n(a) Based on a Diviner measurement snapshot.\n\n\n\n\n\n(b) Based on the average Diviner measurements.\n\n\n\n\n\n\n\n(c) Based on the analytic function of Butler (1997).\n\n\n\n\n\n(d) Based on the analytic function of Hurley et al. (2015)\n\n\n\nFigure 2: Global, stationary lunar surface temperature maps. Coordinates given with respect to the subsolar point at \\((\\Theta_{ss}, \\Phi_{ss}) = (0,0)\\), presented in local time and subsolar latitude.\n\n\n\n\nusing .ExESS\nusing CairoMakie, ColorSchemes\n    \ncmap = ColorSchemes.lipari\n\n#::. functions\nfunction _default_(N=240, M=120)\n    fig     = Figure(;resolution=(600,285))\n    ga      = MyLTGeoAxis(fig[1,1];)\n    xlims!(ga, -180, 180); ylims!(ga, -90, 90)\n    theta   = range(-1,1,N) .* pi .* 0.995\n    phi     = range(-1,1,M) .* pi/2 .* 0.96\n    return fig, ga, theta, phi\nend\n\nfunction lunarSurfaceTemperaturesDivinerAverage(name=\"lunarSurfaceTemperatureDivinerAverage\")\n    fig, ga, theta, phi = _default_()\n    \n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner_avg(theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\")\n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesDiviner(name=\"lunarSurfaceTemperatureDiviner\")\n    fig, ga, theta, phi = _default_(720, 360)\n\n    N, M = length(theta), length(phi)\n    T = lunar_surface_temperatures_diviner(0, theta, phi)\n    T = reshape(T,N,M)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesBUTLER(name=\"lunarSurfaceTemperatureBUTLER\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_BUTLER1997(theta, phi)\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.svg\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\nfunction lunarSurfaceTemperaturesHURLEY(name=\"lunarSurfaceTemperatureHURLEY\")\n    fig, ga, theta, phi = _default_()\n    T = lunar_surface_temperatures_HURLEY2015(theta, phi)\n\n    s = heatmap!(ga, -179..179, -89..89, T; colormap=cmap, colorrange=(50,400))\n    c = contour!(ga, -179..179, -89..89, T; color=:white, levels=[100], linewidth=0.7)\n    t = text!(ga, -138, 0; text=\"100K\", align=(:center,:center), color=:white)\n\n    Colorbar(fig[:,2], s, label=\"Temperature [K]\") \n\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\n\n diviner.png \n diviner_average.png \n butler.png \n hurley.png \n\n\n\n\n\nButler (1997) proposed an analytical surface temperature distribution based on the solar zenith angle \\(\\psi_s\\) with regard to the local surface normal, assuming a perfectly spherical Moon, see Figure 2. Given the subsolar position \\(\\left(\\Theta_{ss}, \\Phi_{ss}\\right)\\), longitude and latitude respectively, the cosine of the zenith angle can be calculate as \\(\\cos\\psi_s = \\cos\\Theta_{ss} \\cdot \\cos\\Phi_{ss}\\). All measurements of the lunar surface temperatures on the dayside suggest a \\(\\cos^{1/4}\\) shape with regard to the solar zenith angle (Hurley et al., 2015; Vasavada et al., 2012), though such models break down on the nightside. By introducing a cutoff at the terminators alongside a defined nightside temperature shifting the distribution up, Butler (1997) arrived at \\[\\begin{equation}\n    T(\\psi_s) = \\begin{cases}\n        250\\,\\mathrm{K} \\cdot \\cos^{1/4} (\\psi_s) + 100\\,\\mathrm{K}, \\qquad & \\text{ if } \\psi_s \\leq 90\\,\\mathrm{\\degree}, \\\\\n        100\\,\\mathrm{K}, & \\text{ if } \\psi_s &gt; 90\\,\\mathrm{\\degree}.\n    \\end{cases} \\label{eq:lunar_surface_temperatures_BUTLER}\n\\end{equation}\\]\n\n\n lunar_surface_temperatures_BUTLER1997\nHurley et al. (2015) proposed another model to further improve the analytical description of the lunar surface temperatures, which included a combination of a cosine-law dependence on the dayside and a 6-term polynomial fitted cooling function for the nightside: \\[\\begin{equation}\n    T(\\Theta_{ss}, \\Phi_{ss}) = \\begin{cases}\n        262\\,\\mathrm{K} \\cdot \\cos^{1/2} \\left( \\psi_s \\right) + 130\\,\\mathrm{K}, \\qquad & \\text{ if } \\left|\\Theta_{ss}\\right| &lt; 90\\,\\mathrm{\\degree}, \\\\\n        \\left( \\sum_{i=0}^5 a_i \\Theta_{ss}^i \\right) + 35\\,\\mathrm{K} \\left( \\sin \\overline{\\Phi_{ss}} - 1\\right), \\qquad & \\text{ else.}\n    \\end{cases} \\label{eq:lunar_surface_temperatures_HURLEY}\n\\end{equation}\\] with the longitude \\(\\Theta_{ss}\\) and the subsolar co-latitude \\(\\overline{\\Phi_{ss}} = \\pi/2 - \\Phi_{ss}\\). The coefficients of the polynomial fit are \\(a = \\left[444.738,\\; -448.937,\\; 239.668,\\; -63.8844,\\; 8.34064,\\; -0.423502 \\right]\\) in kelvin. Note that the longitude has to be used in radians and must be positively defined on the range of \\(\\Theta_{ss} \\in \\left(\\pi/2, 3\\pi/2\\right)\\) for the nightside.\n\n\n lunar_surface_temperatures_HURLEY2015\n\n\n Figure Julia - Mean Julia - RMS Downloads\n\n\n\n\n\n\n\n\n(a) Statistical temperature difference mean.\n\n\n\n\n\n(b) Root mean squared error of temperature differences.\n\n\n\nFigure 3: Statistical comparison of the lunar surface temperatures models with Diviner measurements. Temperature difference based on analytical functions by Butler (1997), Eq. \\(\\eqref{eq:lunar_surface_temperatures_BUTLER}\\), and Hurley et al. (2015), Eq. \\(\\eqref{eq:lunar_surface_temperatures_HURLEY}\\), compared to the averaged Diviner measurements and evaluated on grid points, equally distributed and weighted with their respective surface area. Comparisons are represented by their statistical mean (a) and their root mean squared error (b), applied globally (circles), on the dayside (squares), and on the nightside (diamonds).\n\n\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_rms(N=18, name=\"temperature_comparison_rms\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, sqrt(mean(dTBlat.^2)))  \n        push!(eBd, sqrt(mean(dTBlatd.^2)))\n        push!(eBn, sqrt(mean(dTBlatn.^2)))\n        push!(eH, sqrt(mean(dTHlat.^2)))  \n        push!(eHd, sqrt(mean(dTHlatd.^2)))\n        push!(eHn, sqrt(mean(dTHlatn.^2)))\n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"RMS Temperature Differences [K]\",\n        yticks=0:20:70,)\n    ylims!(0, 70)\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash)\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n        [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false,\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\nusing .ExESS\nusing Statistics, StatsBase\nusing CairoMakie\n\n#::. functions\nfunction comparison_mean(N=18, name=\"temperature_comparison_mean\")\n    grid = ExESS.GlobalHEALPix2DGrid(1.0,150)\n\n    #::. temperatures\n    T_diviner = lunar_surface_temperatures_diviner_avg(grid)\n    T_B = lunar_surface_temperatures_BUTLER1997(grid)\n    T_H = lunar_surface_temperatures_HURLEY2015(grid)\n\n    #::. calculate absoluate temperature differences\n    dTB = T_B .- T_diviner\n    dTH = T_H .- T_diviner\n\n    #::. error calculation\n    eB, eH = Float32[], Float32[]\n    eBd, eHd = Float32[], Float32[]\n    eBn, eHn = Float32[], Float32[]\n    for i in 1:N\n        dTBlat, dTHlat = Float32[], Float32[]\n        dTBlatd, dTHlatd = Float32[], Float32[]\n        dTBlatn, dTHlatn = Float32[], Float32[]\n        for j in eachindex(dTB)\n            if (i-1)*pi/2/N &lt; abs(grid.coords[j].phi) &lt; i*pi/2/N; push!(dTBlat, dTB[j]) \n                push!(dTHlat, dTH[j]) \n                if -pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1; push!(dTBlatd, dTB[j]); push!(dTHlatd, dTH[j]); end # day\n                if !(-pi/2 + 0.1 &lt; grid.coords[j].theta &lt; pi/2 - 0.1); push!(dTBlatn, dTB[j]); push!(dTHlatn, dTH[j]); end # night\n            end\n        end\n        push!(eB, mean(dTBlat))   \n        push!(eBd, mean(dTBlatd)) \n        push!(eBn, mean(dTBlatn)) \n        push!(eH, mean(dTHlat))   \n        push!(eHd, mean(dTHlatd)) \n        push!(eHn, mean(dTHlatn)) \n    end\n\n    #::. prep figures\n    fig = Figure(;)\n    ax = Axis(fig[1,1];\n        xlabel=\"Latitude [°]\",\n        xticks=0:20:90,\n        ylabel=\"Mean Temperature Differences [K]\")\n\n    #::. plots\n    lines!(ax, range(0,80,N), eB;  color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBd; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eBn; color=TUMBlack, linestyle=:dash, )\n    lines!(ax, range(0,80,N), eH;  color=TUMBlack)\n    lines!(ax, range(0,80,N), eHd; color=TUMBlack)\n    lines!(ax, range(0,80,N), eHn; color=TUMBlack)\n\n    scatter!(ax, range(0,80,N), eB;  color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eBd; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eBn; color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond)\n    scatter!(ax, range(0,80,N), eH;  color=TUMBlack, strokewidth=0.7)\n    scatter!(ax, range(0,80,N), eHd; color=:white, strokewidth=0.7, marker=:rect)\n    scatter!(ax, range(0,80,N), eHn; color=:white, strokewidth=0.7, marker=:diamond)\n\n    #::. legend\n    l1 = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    l2 = LineElement(color=TUMBlack, linestyle=:solid, linewidth=2)\n    m1 = MarkerElement(color=TUMBlack, strokecolor=TUMBlack, strokewidth=0.7, marker=:circle,)\n    m2 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:rect,)\n    m3 = MarkerElement(color=:white, strokecolor=TUMBlack, strokewidth=0.7, marker=:diamond,)\n    axislegend(ax,  \n    [ m1, l2, m2, l1, m3],\n        [ \"Global\", \"Hurley et al. 2015\", \"Dayside\", \"Butler et al. 1997\", \"Nightside\", ];\n        position=:lt,\n        nbanks=2,\n        framevisible=false\n    )\n\n    #::. save figure\n    save(joinpath(@__DIR__, \"$(name).pdf\"), fig)\n    save(joinpath(@__DIR__, \"$(name).svg\"), fig)\n    save(joinpath(@__DIR__, \"$(name).png\"), fig, px_per_unit=4)\n\n    return nothing\nend\n\n\n\n mean.pdf   mean.svg   mean.png \n rms.pdf   rms.svg   rms.png \n\n\n\n\n\nThe two presented analytical models of the lunar surface temperatures have been compared with the averaged DLRE measurements. Figure 3 shows this statistical analysis of the temperatures difference of the Butler (1997) and Hurley et al. (2015) calculated as \\(\\Delta T_i = T_i - T_\\text{Diviner}\\) for each analytical model \\(i\\), evaluated on surface points, globally distributed using the HEALPix method.\nThe left side shows the statistical mean of said temperature differences as a function of subsolar latitude for both models, both globally as well as exclusively on the dayside and nightside of the Moon. Up to \\(\\Phi_{ss}=60\\,\\mathrm{\\degree}\\), the Hurley et al. (2015) model has global means very close to zero, with slight deviations for the exclusive day- and nightside. Closer to the poles, the model tends towards positive temperature differences, peaking at around above the Diviner model on the sunlit side. Using the model by Butler (1997) this effect is even more pronounced with the means starting below zero at the equator and continuously increasing with higher latitudes. Final values close to the poles reach temperature differences of more than on the dayside.\nTo further investigate the two models, the [rms}$ value of the temperature differences \\[\\begin{equation}\n    \\Delta T_{\\text{rms}, i} = \\sqrt{\\frac{1}{N_j} \\cdot \\sum_j^{N_j} \\left(\\Delta T_{i,j}\\right)^2},\n\\end{equation}\\] for \\(N_j\\) applicable positions \\(j\\) is shown on the right side of Figure 3. In comparison with the previously shown statistical mean, the rms shows the spread of the temperatures around the mean. For all cases, globally, dayside, and nightside, the Hurley et al. (2015) model has lower rms values, which are less than for latitude uo to . Closer to the poles and similar to the mean value, the dayside temperatures tend to deviate the most, peaking at at . Generally, a steadily increasing behaviour with higher latitudes can be observed. For the Butler (1997) model, the rms values start out considerably higher with the worst deviations on the dayside of the Moon. For roughly from the equator, the values are decreasing to a lowest value of before sharply increasing polewards of it.\n\n\n\n\n\nReferences\n\nButler, B. J. (1997). The migration of volatiles on the surfaces of Mercury and the Moon. Journal of Geophysical Research, 102(E8), 19, 283–219, 291. https://doi.org/10.1029/97JE01347\n\n\nHurley, D. M., Sarantos, M., Grava, C., Williams, J.-P., Retherford, K. D., Siegler, M., Greenhagen, B., & Paige, D. (2015). An analytic function of lunar surface temperature for exospheric modeling. Icarus, 255, 159–163. https://doi.org/10.1016/j.icarus.2014.08.043\n\n\nVasavada, A. R., Bandfield, J. L., Greenhagen, B. T., Hayne, P. O., Siegler, M. A., Williams, J.-P., & Paige, D. A. (2012). Lunar equatorial surface temperatures and regolith properties from the Diviner lunar radiometer experiment. https://doi.org/10.1029/2011JE003987\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/documentation.html",
    "href": "documentation/documentation.html",
    "title": "Preface",
    "section": "",
    "text": "Authors\nAlexander Smolka\n\n\nLicense\nLicense\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/planetary_measurements/density_projections.html",
    "href": "documentation/planetary_measurements/density_projections.html",
    "title": "3.1 Exospheric Density Projections",
    "section": "",
    "text": "Due to the scarcity of ground-based data, satellite measurements at varying altitudes are often used in the investigation of planetary exospheres. In order to compare measurements at different altitudes, the data must be projected into a common altitude, which usually is the exobase altitude, which is the surface of the planetary body given surface-bounded exospheres.\nChamberlain (1963) derived a model for the exospheric particle number density \\(n\\left(r\\right)\\) as a function of the radial distance from the center of the planetary body, based on the assumption of a hydrostatic equilibrium and a Maxwellian velocity distribution, see section Velocity Distributions: \\[\\begin{equation}\n    % \\numberDensity(\\radius) = \\numberDensity(\\radius+\\height) \\cdot \\partitionFunction \\cdot \\exp \\left(\\relativeEnergy\\left(\\radius\\right) - \\relativeEnergy\\left(\\radius+\\height\\right) \\right)\n    n= \\tilde n\\cdot \\zeta\\cdot \\exp \\left(\\epsilon- \\tilde\\epsilon\\right)\n    \\label{eq:chamberlain_projection}\n\\end{equation}\\] with the known number density \\(\\tilde n= n(\\tilde r)\\) at some known radial distance \\(\\tilde r= r+ h\\) with \\(r, h\\in\\mathbb{R}^+\\), relative potential energies \\(\\epsilon\\), and a partition function \\(\\zeta\\). If the radial distance is equal to the radius of the planetary body, the number density is equal to the surface number density \\(n_0\\). Equation \\(\\eqref{eq:chamberlain_projection}\\) is the general form of the isothermal barometric law (Chamberlain, 1963).\nThe relative energy of the projection function is given as absolute potential energy in units of thermal energy \\(k_BT\\): \\[\\begin{equation}\n    \\epsilon\\left(r\\right) = \\left| - \\frac{m\\hat mG}{k_BTr} \\right|\n    \\label{eq:relative_potential_energy}\n\\end{equation}\\] with the mass \\(m\\) of the particle, the mass \\(\\hat m\\) of the planetary body, and the gravitational constant \\(G\\) (Chamberlain, 1963). Both, \\(\\epsilon= \\epsilon\\left(r\\right)\\) and \\(\\tilde\\epsilon= \\epsilon\\left(r+h\\right)\\), are required for the partition function \\(\\zeta\\), which is the linear combination of three individual partition functions which are describing particles in ballistic orbits, \\(\\zeta_{bal}\\), particles in satellite orbits, \\(\\zeta_{sat}\\), and particles that are on escape trajectories, \\(\\zeta_{esc}\\): \\[\\begin{align}\n    \\zeta_{bal} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{sat} &= \\frac{2}{\\sqrt{\\pi}} \\left( \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right), \\\\\n    \\zeta_{esc} &= \\frac{1}{\\sqrt{\\pi}} \\left( \\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon\\right) - \\frac{\\sqrt{\\tilde\\epsilon^2 - \\epsilon^2}}{\\tilde\\epsilon} \\cdot \\exp\\left(-\\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right) \\cdot \\left(\\Gamma\\left(\\frac{3}{2}\\right) - \\gamma\\left(\\frac{3}{2}, \\epsilon- \\frac{\\epsilon^2}{\\epsilon+ \\tilde\\epsilon}\\right)\\right) \\right) \\\\\n    &\\quad\\Rightarrow \\zeta= \\zeta_{bal} + \\zeta_{sat} + \\zeta_{esc}\n\\end{align}\\] with the gamma and lower incomplete gamma function, \\(\\Gamma\\) and \\(\\gamma\\), respectively Cook et al. (2013).\n\n\n\n\nReferences\n\nChamberlain, J. (1963). Planetary coronae and atmospheric evaporation. Planetary and Space Science, 11, 901–960.\n\n\nCook, J. C., Stern, S. A., Feldman, P. D., Gladstone, G. R., Retherford, K. D., & Tsang, C. C. C. (2013). New upper limits on numerous atmospheric species in the native lunar atmosphere. Icarus. https://doi.org/10.1016/j.icarus.2013.04.010\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "documentation/sources_sinks/photoionization_dissociation.html",
    "href": "documentation/sources_sinks/photoionization_dissociation.html",
    "title": "4.3 Photoionization & -dissociation",
    "section": "",
    "text": "Some Intro"
  },
  {
    "objectID": "documentation/sources_sinks/photoionization_dissociation.html#photoionization-rates",
    "href": "documentation/sources_sinks/photoionization_dissociation.html#photoionization-rates",
    "title": "4.3 Photoionization & -dissociation",
    "section": "Photoionization Rates",
    "text": "Photoionization Rates\n\n\n Figure Julia Download\n\n\n\n\n\n\n\n\n\nFigure 1: Photoionization rates for Hydrogen, Helium, Oxygen, and Neon during the period between 1978 and 2012, derived by a multilinear model of Bochsler et al. (2013). The data is displayed as daily and yearly averages, with the extreme values of the yearly averages highlighted by dashed horizontal lines.\n\n\n\n\nusing DelimitedFiles, Statistics\n\n#::. utility functions\nfunction read_table(path::String=joinpath(@__DIR__, \"photoionization_rates_BOCHSLER2013.csv\"))\n    table = readdlm(path, ',', Float64, '\\n', header=true)\n    return table[1], table[2]\nend\n\nfunction photoionization_rates_BOCHSLER2013(N::Integer)\n    tab, _ = read_table()\n    t, k = tab[:,3], tab[:,N]\n    return t, k\nend\n \nfunction photoionization_rates_BOCHSLER2013(elem::Symbol)\n    N = elem == :H ? 4 :\n        elem == :He ? 5 :\n        elem == :O ? 6 :\n        elem == :Ne ? 7 : error(\"Element not supported\")\n    return photoionization_rates_BOCHSLER2013(N)\nend\n\nH_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(4)\nHe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(5)\nO_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(6)\nNe_photoionization_rates_BOCHSLER2013() = photoionization_rates_BOCHSLER2013(7)\n\n\n#::. postprocessing functions\nfunction smoothing(k::AbstractVector; n=5)\n    return [mean(k[max(1,i-n):min(length(k),i+n)]) for i in 1+n:length(k)-n]\nend\n\n\n#::. plotting functions\nfunction plot_k_all(name::String=\"photoionization_rates_BOCHSLER2013\"; n=5)\n    t, kH  = photoionization_rates_BOCHSLER2013(:H)\n    _, kHe = photoionization_rates_BOCHSLER2013(:He)\n    _, kO  = photoionization_rates_BOCHSLER2013(:O)\n    _, kNe = photoionization_rates_BOCHSLER2013(:Ne)\n\n    t_smooth = t[1+n:end-n]\n    kH_smooth = smoothing(kH; n=n)\n    kHe_smooth = smoothing(kHe; n=n)\n    kO_smooth = smoothing(kO; n=n)\n    kNe_smooth = smoothing(kNe; n=n)\n\n    kH_smooth_max = findmax(kH_smooth)\n    kHe_smooth_max = findmax(kHe_smooth)\n    kO_smooth_max = findmax(kO_smooth)\n    kNe_smooth_max = findmax(kNe_smooth)\n\n    kH_smooth_min = findmin(kH_smooth)\n    kHe_smooth_min = findmin(kHe_smooth)\n    kO_smooth_min = findmin(kO_smooth)\n    kNe_smooth_min = findmin(kNe_smooth)\n\n    #\n    fig = Figure(resolution=(1200,600), fontsize=16)\n\n    ax1 = Axis(fig[1,1]; yticks=[1.0, 1.3, 1.6]); hidexdecorations!(ax1; grid=false);\n    scatter!(ax1, t, kH; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax1, t_smooth, kH_smooth; color=TUMBlack)\n    scatter!(ax1, t_smooth[kH_smooth_max[2]], kH_smooth_max[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax1, t_smooth[kH_smooth_min[2]], kH_smooth_min[1]; color=TUMBlack)\n    hlines!(ax1, kH_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,1], \"Hydrogen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax2 = Axis(fig[2,1]; xlabel=\"Year\", yticks=[1.0, 1.5, 2.0])\n    scatter!(ax2, t, kHe; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax2, t_smooth, kHe_smooth; color=TUMBlack)\n    scatter!(ax2, t_smooth[kHe_smooth_max[2]], kHe_smooth_max[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax2, t_smooth[kHe_smooth_min[2]], kHe_smooth_min[1]; color=TUMBlack)\n    hlines!(ax2, kHe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,1], \"Helium\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax3 = Axis(fig[1,2]; yticks=([3, 5, 7], [\"3.0\",\"5.0\",\"7.0\"])); hidexdecorations!(ax3; grid=false);\n    scatter!(ax3, t, kO; color=TUMBlueLighter, markersize=2.5)\n    lines!(ax3, t_smooth, kO_smooth; color=TUMBlack)\n    scatter!(ax3, t_smooth[kO_smooth_max[2]], kO_smooth_max[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax3, t_smooth[kO_smooth_min[2]], kO_smooth_min[1]; color=TUMBlack)\n    hlines!(ax3, kO_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[1,2], \"Oxygen\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    ax4 = Axis(fig[2,2]; xlabel=\"Year\", yticks=([2.0, 4.0, 6.0],[\"2.0\",\"4.0\",\"6.0\"]))\n    ld = scatter!(ax4, t, kNe; color=TUMBlueLighter, markersize=2.5)\n    ly = lines!(ax4, t_smooth, kNe_smooth; color=TUMBlack)\n    scatter!(ax4, t_smooth[kNe_smooth_max[2]], kNe_smooth_max[1]; color=TUMBlack)\n    lmax = hlines!(ax4, kNe_smooth_max[1]; xmax=13/40, color=TUMBlack, linestyle=:dash)\n    scatter!(ax4, t_smooth[kNe_smooth_min[2]], kNe_smooth_min[1]; color=TUMBlack)\n    lmin = hlines!(ax4, kNe_smooth_min[1]; xmax=0.83, color=TUMBlack, linestyle=:dash)\n    Label(fig[2,2], \"Neon\", justification=:right, tellheight=false, tellwidth=false, halign=:right, valign=:top, padding=(10,10,10,5), fontsize=FONTSIZE_BIG)\n\n    Label(fig[:,0], \"Photoionization Rate [10⁻⁷ s⁻¹]\", rotation=pi/2)\n\n\n    da = MarkerElement(color=TUMBlueLighter, marker=:circle, markersize=12)\n    ya = LineElement(color=TUMBlack, linestyle=:solid, linewidth=3)\n    mm = LineElement(color=TUMBlack, linestyle=:dash, linewidth=2)\n    Legend(fig[0,:], [da,ya,mm], [\"day average\", \"year average\", \"maximum/minimum year averages\"]; orientation=:horizontal)\n\n    save(joinpath(@__DIR__, \"$name.pdf\"), fig)\n    save(joinpath(@__DIR__, \"$name.png\"), fig, px_per_unit=4)\nend\n\n\n\n photoionization_rates_BOCHSLER.png   photoionization_rates_BOCHSLER.pdf \n data.csv"
  },
  {
    "objectID": "documentation/sources_sinks/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "href": "documentation/sources_sinks/thermal_sorption/tables/mbd_typical_speeds/raw_mbd_typical_speeds.html",
    "title": "ExESS",
    "section": "",
    "text": "\\(\\velocity\\)\n\\(\\int_0^\\velocity f(\\velocity)d\\velocity\\)\n\\(\\velocity / \\sqrt{\\frac{\\BoltzmannConstant\\temperature}{\\mass}}\\)\n\\(\\velocity / \\velocity_p\\)\n\n\\(\\velocity / \\meanof{\\velocity}\\)\n\n\\(\\velocity / \\velocity_\\text{rms}\\)\n\n\n\n\n\n\\(\\velocity_{25}\\)\n\\(0.25\\)\n\\(1.101\\)\n\\(0.779\\)\n\n\\(0.69\\)\n\n\\(0.636\\)\n\n\n\n\\(\\velocity_p\\)\n\\(0.428\\)\n\\(1.414\\)\n\\(1.0\\)\n\n\\(0.886\\)\n\\(\\approx\\sqrt{\\pi/4}\\)\n\\(0.816\\)\n\\(\\approx\\sqrt{2/3}\\)\n\n\n\\(\\velocity_{50}\\)\n\\(0.5\\)\n\\(1.538\\)\n\\(1.088\\)\n\n\\(0.964\\)\n\n\\(0.888\\)\n\n\n\n\\(\\meanof{\\velocity}\\)\n\\(0.533\\)\n\\(1.596\\)\n\\(1.128\\)\n\\(\\approx\\sqrt{4/\\pi}\\)\n\\(1.0\\)\n\n\\(0.921\\)\n\\(\\approx\\sqrt{8/3\\pi}\\)\n\n\n\\(\\velocity_\\text{rms}\\)\n\\(0.608\\)\n\\(1.732\\)\n\\(1.225\\)\n\\(\\approx\\sqrt{3/2}\\)\n\\(1.085\\)\n\\(\\approx\\sqrt{3\\pi/8}\\)\n\\(1.0\\)\n\n\n\n\\(\\velocity_{75}\\)\n\\(0.75\\)\n\\(2.027\\)\n\\(1.433\\)\n\n\\(1.27\\)\n\n\\(1.17\\)\n\n\n\n\\(\\velocity_{90}\\)\n\\(0.9\\)\n\\(2.5\\)\n\\(1.768\\)\n\n\\(1.567\\)\n\n\\(1.444\\)\n\n\n\n\\(\\velocity_{95}\\)\n\\(0.95\\)\n\\(2.796\\)\n\\(1.977\\)\n\n\\(1.752\\)\n\n\\(1.614\\)\n\n\n\n\\(\\velocity_{99}\\)\n\\(0.99\\)\n\\(3.368\\)\n\\(2.382\\)\n\n\\(2.111\\)\n\n\\(1.945\\)\n\n\n\n\\(\\velocity_{99.9}\\)\n\\(0.999\\)\n\\(4.033\\)\n\\(2.852\\)\n\n\\(2.527\\)\n\n\\(2.329\\)\n\n\n\n\n\n\n\nCitationBibTeX citation:@online{smolka2023,\n  author = {Smolka, Alexander},\n  title = {ExESS - {Extraterrestrial} {Exosphere} and {Surface}\n    {Simulations}},\n  date = {2023},\n  url = {https://smolkaa.github.io},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nSmolka, A. (2023). ExESS - Extraterrestrial Exosphere and Surface\nSimulations. https://smolkaa.github.io"
  },
  {
    "objectID": "api/base/cs.html",
    "href": "api/base/cs.html",
    "title": "Coordinate Systems",
    "section": "",
    "text": "Coordinates in ExESS are implemented as their custom, three-dimensional vectors, which are based on their scope, the coordinate system, and their physical type. The scope can either be Global[...] or Local[...], which is referring to a fixed planetary system or a local reference frame, respectively. The coordinate system is either [...]Cartesian[...] or [...]Spherical[...], which is referring to a Cartesian or spherical coordinate system, respectively. The physical type is either [...]Position or [...]Velocity, which is referring to a position or velocity vector, respectively."
  },
  {
    "objectID": "api/base/cs.html#type-structure",
    "href": "api/base/cs.html#type-structure",
    "title": "Coordinate Systems",
    "section": "Type Structure",
    "text": "Type Structure\nThe following structure shows all currently implemented coordinates in ExESS:\nExESS\n└─ AbstractCoordinates\n    │\n    ├─ AbstractPosition\n    │  ├─ GlobalCartesianPosition{T&lt;:Real}\n    │  └─ GlobalSphericalPosition{T&lt;:Real}\n    │\n    └─ AbstractVelocity\n       ├─ GlobalCartesianVelocity{T&lt;:Real}\n       ├─ LocalCartesianVelocity{T&lt;:Real}\n       └─ GlobalSphericalVelocity{T&lt;:Real}\nMore information on the mathematical description of the different coordinate vectors and the mathematical foundation for the conversion functions are presented in Cartesian and Spherical Coordinates."
  },
  {
    "objectID": "api/base/cs.html#usage",
    "href": "api/base/cs.html#usage",
    "title": "Coordinate Systems",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/cs.html#api",
    "href": "api/base/cs.html#api",
    "title": "Coordinate Systems",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalCartesianPosition – Struct\n\n\n\n\n\n[1] GlobalCartesianPosition(x::Real, y::Real, z::Real)\n[2] GlobalCartesianPosition(X::AbstractVector)\n[3] GlobalCartesianPosition(x::AbstractPosition)\nThree dimensional, global, cartesian position vector [1]. Converts vector or other position type into GlobalCartesianPosition [2,3].\n[1] GlobalCartesianPosition(sol::ODESolution, [idx::Integer])\n[2] GlobalCartesianPosition(sol::ODESolution, t::Real)\n[3] GlobalCartesianPosition(sol::ODESolution, t::AbstractVector)\nExtracts GlobalCartesianPosition from ODESolution at given index, all indexes, time or times. Note that this constructor assumes the solution object to be from a SecondOrderODEProblem, where the components of the solution vector are ordered as [vx, vy, vz, x, y, z].\n\n\n\n\n\n\n\n\n\n\nGlobalSphericalPosition – Struct\n\n\n\n\n\n[1] GlobalSphericalPosition(r::Real, theta::Real, phi::Real)\n[2] GlobalSphericalPosition(X::AbstractVector)\n[3] GlobalSphericalPosition(x::AbstractPosition)"
  },
  {
    "objectID": "api/base/utility.html#usage",
    "href": "api/base/utility.html#usage",
    "title": "Utility",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/base/utility.html#api",
    "href": "api/base/utility.html#api",
    "title": "Utility",
    "section": "API",
    "text": "API\n\n\n\n\n\n\namu2kg – Function\n\n\n\n\n\n[1] amu2kg([T::Type,] amu::Real)\nConverts atomic mass unit amu into kilo gram.\n\n\n\n\n\n\n\n\n\n\nlimit_acos – Function\n\n\n\n\n\n[1] limit_acos(x::Real)\nExtends the acos function for input outside of [-1,1] through clipping.\n\n\n\n\n\n\n\n\n\n\nsgn – Function\n\n\n\n\n\n[1] sgn(x::Real)\nReturns the sign of x with the custom definition sgn(0) = 1."
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html",
    "href": "api/exospheres/orbital_mechanics.html",
    "title": "Orbital Mechanics",
    "section": "",
    "text": "The mathematical definition of the implemented functions is presented in the documentation, in the section Ballistic Trajectories."
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html#usage",
    "href": "api/exospheres/orbital_mechanics.html#usage",
    "title": "Orbital Mechanics",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/exospheres/orbital_mechanics.html#api",
    "href": "api/exospheres/orbital_mechanics.html#api",
    "title": "Orbital Mechanics",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nazimuth_angle_v – Function\n\n\n\n\n\n[1] azimuth_angle_v(v::AbstractVector)\n[2] azimuth_angle_v(v::LocalCartesianVelocity)\nCalculates the azimuth angle of the launch velocity vector v. Resulting angle is given in radians, [-π, π).\nReturns NaN if v1=v2=0, i.e., for no planar velocities.\n\n\n\n\n\n\n\n\n\n\neccentric_anomaly_e_M – Function\n\n\n\n\n\n[1] eccentric_anomaly_e_M(e::Real, M::Real, N=10)\nCalculates the eccentric anomaly given the orbit’s eccentricity e and the mean anomaly M, which triggers a numerical approximation with N steps. The result is given in radians [0, 2π).\n\nAlternative Functions\neccentric_anomaly_e_theta\n\n\n\n\n\n\n\n\n\n\n\neccentric_anomaly_e_theta – Function\n\n\n\n\n\n[1] eccentric_anomaly_e_theta(e::Real, theta::Real)\nCalculates the eccentric anomaly given the orbit’s eccentricity e and the true anomaly theta. The result is given in radians [0, 2π).\n\nAlternative Functions\neccentric_anomaly_e_M\n\n\n\n\n\n\n\n\n\n\n\neccentricity_epskin_psi – Function\n\n\n\n\n\n[1] eccentricity_epskin_psi(epskin::Real, psi::Real)\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction epskin, and the zenith launch angle psi.\n\nAlternative Functions\neccentricity_epskin_v, eccentricity_r_m_v\n\n\n\n\n\n\n\n\n\n\n\neccentricity_epskin_v – Function\n\n\n\n\n\n[1] eccentricity_epskin_v(epskin::Real, v::AbstractVector)\n[2] eccentricity_epskin_v(epskin::Real, v::LocalCartesianVelocity)\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction epskin, and the velocity vector v.\n\nAlternative Functions\neccentricity_epskin_psi, eccentricity_r_m_v\n\n\n\n\n\n\n\n\n\n\n\neccentricity_r_m_v – Function\n\n\n\n\n\n[1] eccentricity_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] eccentricity_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the eccentricity of an elliptical trajetory based on the orbital radius r, the body’s mass m, and the velocity vector v.\n\nAlternative Functions\neccentricity_epskin_psi, eccentricity_epskin_v\n\n\n\n\n\n\n\n\n\n\n\nescape_velocity_r_m – Function\n\n\n\n\n\n[1] escape_velocity_r_m(r::Real, m::Real)\nCalculates the magnitude of the escape velocity for an orbital radius r and body mass m.\n\n\n\n\n\n\n\n\n\n\nflight_time_t0_t1 – Function\n\n\n\n\n\n[1] flight_time_t0_t1(t0::Real, t1::Real)\nCalculates the time of flight between the two orbital times t0 and t1.\n\nAlternative Functions\nflight_time_t0_P, flight_time_e_theta0_theta1_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_t0_P – Function\n\n\n\n\n\n[1] flight_time_t0_P(t0::Real, P::Real)\nCalculates the time of flight, given a symmetrical trajectory with a starting orbital time of t0 and a landing orbital time of P-t0, with the orbital period P.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_e_theta0_theta1_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_e_theta0_theta1_P – Function\n\n\n\n\n\n[1] flight_time_e_theta0_theta1_P(e::Real, theta0::Real, theta1::Real, P::Real)\nCalculates the time of flight between the two orbital positions theta0 and theta1, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_t0_P, flight_time_e_theta0_P\n\n\n\n\n\n\n\n\n\n\n\nflight_time_e_theta0_P – Function\n\n\n\n\n\n[1] flight_time_e_theta0_P(e::Real, theta0::Real, P::Real)\nCalculates the time of flight, given a symmetrical trajectory between the two orbital positions theta0 and 2π - theta0, given the eccentricity e and period P of the orbit.\n\nAlternative Functions\nflight_time_t0_t1, flight_time_t0_P, flight_time_e_theta0_theta1_P\n\n\n\n\n\n\n\n\n\n\n\nepskin_vesc_v – Function\n\n\n\n\n\n[1] epskin_vesc_v(vesc::Real, v::AbstractVector)\n[2] epskin_vesc_v(vesc::Real, v::LocalCartesianVelocity)\nCalculates the squared fraction of the velocity vector v with respect to the escape velocity vesc.\n\nAlternative Functions\nepskin_r_m_v, epskin_r_a, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_r_m_v – Function\n\n\n\n\n\n[1] epskin_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] epskin_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the squared fraction of the velocity vector v, based on the orbital radius r and the body’s mass m.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_a, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_r_a – Function\n\n\n\n\n\n[1] epskin_r_a(r::Real, a::Real)\nCalculates the squared fraction of the velocity at the radial position r on an orbit defined through the semi-major axis a.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_m_v, epskin_e_theta\n\n\n\n\n\n\n\n\n\n\n\nepskin_e_theta – Function\n\n\n\n\n\n[1] epskin_e_theta(e::Real, theta::Real)\nCalculates the squared fraction of the velocity at the angular position theta on an orbit defined through the eccentricity e.\n\nAlternative Functions\nepskin_vesc_v, epskin_r_m_v, epskin_r_a\n\n\n\n\n\n\n\n\n\n\n\nground_distance_R_dtheta – Function\n\n\n\n\n\n[1] ground_distance_R_dtheta(R::Real, dtheta::Real)\nCalculates the ground flight distance covered by an angle dtheta of an elliptical orbit, which intersects with a body of radius R.\n\nAlternative Functions\nground_distance_R_a_e\n\n\n\n\n\n\n\n\n\n\n\nground_distance_R_a_e – Function\n\n\n\n\n\n[1] ground_distance_R_a_e(R::Real, a::Real, e::Real)\nCalculates the ground flight distance covered based on the radius of the body R, the orbit’s semi-major axis a, and the eccentricity e.\n\nAlternative Functions\nground_distance_R_dtheta\n\n\n\n\n\n\n\n\n\n\n\nmean_anomaly_e_E – Function\n\n\n\n\n\n[1] mean_anomaly_e_E(e::Real, E::Real)\nCalculates the mean anomaly, given the orbit’s eccentricity e and the eccentric anomaly E.\n\nAlternative Functions\nmean_anomaly_e_theta\n\n\n\n\n\n\n\n\n\n\n\nmean_anomaly_e_theta – Function\n\n\n\n\n\n[1] mean_anomaly_e_theta(e::Real, theta::Real)\nCalculates the mean anomaly, given the orbit’s eccentricity e and the true anomaly theta.\n\nAlternative Functions\nmean_anomaly_e_E\n\n\n\n\n\n\n\n\n\n\n\norbit_period_a_m – Function\n\n\n\n\n\n[1] orbit_period_a_m(a::Real, m::Real)\nCalculates the period of an elliptical orbit, based on the semi-major axis a, and the body’s mass m.\n\n\n\n\n\n\n\n\n\n\norbit_time_M_P – Function\n\n\n\n\n\n[1] orbit_time_M_P(M::Real, P::Real)\nCalculates the time at the position of an orbit defined through the mean anomaly M, as well as the orbital period P.\n\nAlternative Functions\norbit_time_e_E_P, orbit_time_e_theta_P\n\n\n\n\n\n\n\n\n\n\n\norbit_time_e_E_P – Function\n\n\n\n\n\n[1] orbit_time_e_E_P(e::Real, E::Real, P::Real)\nCalculates the time at the position of an orbit defined through the eccentric anomaly E, the eccentricity e, and the orbital period P.\n\nAlternative Functions\norbit_time_M_P, orbit_time_e_theta_P\n\n\n\n\n\n\n\n\n\n\n\norbit_time_e_theta_P – Function\n\n\n\n\n\n[1] orbit_time_e_theta_P(e::Real, theta::Real, P::Real)\nCalculates the time at the position of an orbit defined through the true anomaly theta, the eccentricity e, and the orbital period P.\n\nAlternative Functions\norbit_time_M_P, orbit_time_e_E_P\n\n\n\n\n\n\n\n\n\n\n\nsemi_latus_rectum_a_e – Function\n\n\n\n\n\n[1] semi_latus_rectum_a_e(a::Real, e::Real)\nCalculates the semi-latus-rectum of the elliptical trajetory defined through the semi-major axis a and the eccentricity e.\n\nAlternative Functions\nsemi_latus_rectum_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_latus_rectum_r_e_theta – Function\n\n\n\n\n\n[1] semi_latus_rectum_r_e_theta(r::Real, e::Real, theta::Real)\nCalculates the semi-latus-rectum of the elliptical trajetory based on the orbital radius r, the eccentricity e, and the true anomaly theta\n\nAlternative Functions\nsemi_latus_rectum_a_e\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_epskin – Function\n\n\n\n\n\n[1] semi_major_axis_r_epskin(r::Real, epskin::Real)\nCalculates the semi-major axis of an elliptical orbit with the current orbital radius r and the trajectory’s squared escape velocity fraction epskin.\n\nAlternative Functions\nsemi_major_axis_r_m_v, semi_major_axis_p_e, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_m_v – Function\n\n\n\n\n\n[1] semi_major_axis_r_m_v(r::Real, m::Real, v::AbstractVector)\n[2] semi_major_axis_r_m_v(r::Real, m::Real, v::LocalCartesianVelocity)\nCalculates the semi-major axis of an elliptical orbit with the current orbital radius r, the body’s mass m, and the velocity vector v.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_p_e, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_p_e – Function\n\n\n\n\n\n[1] semi_major_axis_p_e(p::Real, e::Real)\nCalculates the semi-major axis of an elliptical orbit with the semi-latus rectum p and eccentricity e.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_r_m_v, semi_major_axis_r_e_theta\n\n\n\n\n\n\n\n\n\n\n\nsemi_major_axis_r_e_theta – Function\n\n\n\n\n\n[1] semi_major_axis_r_e_theta(r::Real, e::Real, theta::Real)\nCalculates the semi-major axis of an elliptical orbit with the oribital radius r, the eccentricity e, and the true anomaly theta.\n\nAlternative Functions\nsemi_major_axis_r_epskin, semi_major_axis_r_m_v, semi_major_axis_p_e\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_r_a_e – Function\n\n\n\n\n\n[1] true_anomaly_r_a_e(r::Real, a::Real, e::Real)\nCalculates the true anomaly at the radial position r based on the semi-major axis a, and the eccentricity of the orbit e.\n\nAlternative Functions\ntrue_anomaly_e_epskin, true_anomaly_epskin_v\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_e_epskin – Function\n\n\n\n\n\n[1] true_anomaly_e_epskin(e::Real, epskin::Real)\nCalculates the true anomaly based on the eccentricity of the orbit e and the current squared escape velocity fraction epskin.\n\nAlternative Functions\ntrue_anomaly_r_a_e, true_anomaly_epskin_v\n\n\n\n\n\n\n\n\n\n\n\ntrue_anomaly_epskin_v – Function\n\n\n\n\n\n[1] true_anomaly_epskin_v(epskin::Real, v::AbstractVector)\n[2] true_anomaly_epskin_v(epskin::Real, v::LocalCartesianVelocity)\nCalculates the true anomaly based on the current velocity vector v and the current squared escape velocity fraction epskin.\n\nAlternative Functions\ntrue_anomaly_r_a_e, true_anomaly_e_epskin\n\n\n\n\n\n\n\n\n\n\n\nzenith_angle_v – Function\n\n\n\n\n\n[1] zenith_angle_v(v::AbstractVector)\n[2] zenith_angle_v(v::LocalCartesianVelocity)\nCalculates the zenith launch angle based on the launch velocity vector v."
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#type-structure",
    "href": "api/grids/global_structured_2d_grids.html#type-structure",
    "title": "Global, Structured, Two-Dimensional Grids",
    "section": "Type Structure",
    "text": "Type Structure"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#usage",
    "href": "api/grids/global_structured_2d_grids.html#usage",
    "title": "Global, Structured, Two-Dimensional Grids",
    "section": "Usage",
    "text": "Usage"
  },
  {
    "objectID": "api/grids/global_structured_2d_grids.html#api",
    "href": "api/grids/global_structured_2d_grids.html#api",
    "title": "Global, Structured, Two-Dimensional Grids",
    "section": "API",
    "text": "API\n\n\n\n\n\n\nGlobalStructured2DGrid – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over a sphere of radius r.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2].\n\n\n\n\n\n\n\n\n\n\nGlobalStructured2DGrid_EqSim – Struct\n\n\n\n\n\n[1] struct GlobalStructured2DGrid_EqSim{T&lt;:Real} &lt;: AbstractGlobalStructured2DGrid end\n[2] GlobalStructured2DGrid_EqSim([T::Type,] r::Real, N_theta::Int64, N_phi::Int64)\nGlobal structured grid of surface coordinates (2D) of type GlobalSphericalPosition{T} over the upper hemisphere with radius r, assuming equatorial symmetry.\n\n\n\n\n\n\n\n\nField\nType\nDescription\n\n\n\n\nr\nT\nradius of global body (sphere)\n\n\nN_theta\nInt64\nnumber of elements in azimuth direction\n\n\nN_phi\nInt64\nnumber of elements in elevation direction\n\n\ncoords\nVector{GlobalSphericalPosition{T}}\ncoordinates\n\n\nareas\nVector{T}\nsurface area\n\n\n\nTo ensure expected behavior, the grid object should generally be created with the outer constructor [2]."
  },
  {
    "objectID": "api/api.html",
    "href": "api/api.html",
    "title": "Code",
    "section": "",
    "text": "The ExESS package is structured into four main parts, which are the four main folders in the /src directory:"
  },
  {
    "objectID": "api/api.html#repository-structure",
    "href": "api/api.html#repository-structure",
    "title": "Code",
    "section": "Repository Structure",
    "text": "Repository Structure\nExESS/  \n├─ data/  \n├─ res/  \n├─ src/  \n│  ├─ base/  \n│  ├─ exospheres/  \n│  ├─ grids/  \n│  ├─ surfaces/  \n│  └─ ExESS.jl  \n├─ test/  \n├─ . . .  \n└─ README.md"
  },
  {
    "objectID": "api/api.html#source-files",
    "href": "api/api.html#source-files",
    "title": "Code",
    "section": "Source Files",
    "text": "Source Files\n\nBase Functionalities – base/\nExESS/src/base/ contains basic functionality that is used at multiple places in the code, e.g., physical constants, coordinate system definitions, utility functions, and some probability distributions.\n\nconstants.jl\n\ncs.jl\ndistributions.jl\nutils.jl\n\n\n\nExospheres – exospheres/\nExESS/src/exospheres/ contains all scripts that define functions that have something to do with simulating the exosphere. Due to the assumption of surface-bounded exospheres, Monte-Carlo methods are the preferred simulation tool as each individual particle of the exosphere can be simulated independently. Implemented functionalities are mostly based on ballistic trajectory calculations.\n\norbital_mechanics.jl\ntrajectories.jl\nutils.jl\n\n\n\nNumerical Grids – grids/\nExESS/src/grids/ contains all numerical discretization methods used in this package. While most functions can be called with AbstractVector inputs, their main use is meant to be in conjunction with the previously defined custom coordinate systems.\n\nglobal_healpix_2d_grids.jl\n\nglobal_spiral_2d_grids.jl\n\nglobal_structured_2d_grids.jl\n\nglobal_structured_3d_grids.jl\n\ntypes.jl\n\nutils.jl\n\n\n\nSurfaces – surfaces/\nExESS/src/surfaces/ contains all functions that are used to calculate surface properties, e.g., surface temperatures, reaction kinetics, thermal conductivities, and diffusion coefficients.\n\ndensity.jl\n\nporosity.jl\n\nreaction_rates.jl\n\nregolith.jl\n\ntemperature.jl\n\nthermal_conductivity_parzinger2014.jl\n\nutils.jl"
  },
  {
    "objectID": "manuals/exercise_fibonacci/index.html#problem",
    "href": "manuals/exercise_fibonacci/index.html#problem",
    "title": "Fibonnacci Sequence",
    "section": "Problem",
    "text": "Problem\nWrite a Julia function that computes the last digit of the n-th Fibonacci number, and compute the last digit of the 10th, 100th, 1000th, and 10000th Fibonacci number.\nAdditional Requirements:\n\nThe function’s name shall be fib_last_digit.\nThe Fibonacci sequence starts with 0 and 1.\nThe function should take only one argument called n of type Integer.\nThe function should return an Integer between 0 and 9 (inclusive).\nThe function should depend on no additional packages.\nThe function shall be fast!"
  },
  {
    "objectID": "manuals/exercise_fibonacci/index.html#hints",
    "href": "manuals/exercise_fibonacci/index.html#hints",
    "title": "Fibonnacci Sequence",
    "section": "Hints",
    "text": "Hints\n\n\n\n\n\n\nHow to get the last digit of a number?\n\n\n\n\n\nYou can use the mod function to compute the remainder of the division of two integers. For example, mod(5, 2) returns 1. What would happend if you take the remainder of a number divided by 10?"
  },
  {
    "objectID": "manuals/exercise_fibonacci/index.html#solution",
    "href": "manuals/exercise_fibonacci/index.html#solution",
    "title": "Fibonnacci Sequence",
    "section": "Solution",
    "text": "Solution\n\n\n\n\n\n\nValues\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nn\nfib_last_digit(n)\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n1\n\n\n4\n2\n\n\n5\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\nn\nfib_last_digit(n)\n\n\n\n\n6\n5\n\n\n7\n8\n\n\n8\n3\n\n\n9\n1\n\n\n10\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\nn\nfib_last_digit(n)\n\n\n\n\n100\n6\n\n\n1,000\n6\n\n\n10,000\n6\n\n\n100,000\n6\n\n\n1,000,000\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFolllow-Up Question\n\n\n\n\n\nWhy are the last couple of entries all 6? Is this pure coincidence or do the last digits of the Fibonacci sequence repeat? Use your function to find out!"
  },
  {
    "objectID": "manuals/example_trajectory_01/index.html",
    "href": "manuals/example_trajectory_01/index.html",
    "title": "Trajectory Calculation",
    "section": "",
    "text": "Trajectory Calculation\n\n\nFirst, the locally available ExESS package has to be loaded:\ninclude(joinpath(@__DIR__, \"..\", \"..\", \"src\", \"ExESS.jl\"))\nusing .ExESS\nNext, all required inputs for the trajectory calculation are defined. If you are unsure about how the function works, you can type julia&gt; ?trajectory in the REPL to get a description of the function and its arguments.\nApart from the key-word arguments, the function requires the following inputs:\n\nx0: Initial position vector in Cartesian coordinates (m)\nv0: Initial velocity vector in Cartesian coordinates (m/s)\nddx: Acceleration function (m/s2)\n\nThe docstring (see ?trajectory) shows that these input can be of different types, either vectors (AbstractVector) or positions (AbstractPosition). The latter are custom types defined in the ExESS package to distinguish one three-dimensional in a certain coordinate space from another. The following example shows how to use the GlobalCartesianPosition.\nWe create a GlobalCartesianPosition object with the initial position vector, locate at [LUNAR_RADIUS, 0, 0], in other words: on the surface of a sphere with radius LUNAR_RADIUS.\nx0 = GlobalCartesianPosition(LUNAR_RADIUS, 0, 0)\nNext, the initial velocity vector is defined. We use the GlobalCartesianVelocity type to define a velocity vector in the same coordinate system as the position vector. Here, we only use a velocity in the x-direction, with a magnitude of 100 m/s.\nv0 = GlobalCartesianVelocity(100, 0, 0)\nWithout letting the trajectory calculation run, we can review the initial conditions set. Both the position and the velocity vector are set in the same coordinate system and have non-zero components only in the x-direction. For purely gravitational accelerations, the trajectory should therefore be a straight line in the x-direction.\nWe can test this assumptions by using the ddx_lunar_gravity function, which is a predefined acceleration function for the gravitational acceleration of the Moon. It already has the Moon’s mass and radius defined, so we can use it directly as is. Note that it assumes that every other acceleration is negligible, which might not be true for charged particles in electro-magnetic fields.\nddx = ddx_lunar_gravity\nFinally, we have all the required inputs to calculate the trajectory. Let’s call the function and save the solution in a variable called traj.\ntraj = trajectory(x0, v0, ddx)"
  },
  {
    "objectID": "manuals/julia_links/index.html",
    "href": "manuals/julia_links/index.html",
    "title": "Julia Programming Language: Links & Resources",
    "section": "",
    "text": "Julia is a cutting-edge, high-level programming language designed to address the unique challenges of scientific computing and data analytics. Born in 2012, Julia has quickly gained popularity among researchers, data scientists, and developers due to its remarkable performance and ease of use. The language’s key strength lies in its ability to handle complex mathematical computations and large datasets seamlessly. Julia boasts an intuitive syntax and rich mathematical library, making it particularly well-suited for numerical simulations, machine learning, and advanced statistical analysis. With its open-source nature and active community, Julia continues to evolve, receiving regular updates and enhancements that cater to its users’ diverse needs."
  },
  {
    "objectID": "manuals/julia_links/index.html#learning-julia",
    "href": "manuals/julia_links/index.html#learning-julia",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Learning Julia",
    "text": "Learning Julia\n\nMIT’s Introduction to Computational Thinking\n\nThis free online course held by the creators of the Julia Programming Language offers you a good overview of numerical methods and scientific computing in Julia. The course is held in Julia and is a great way to get started with the language.\n\nTUM-Dynamics-Lecture, 1 and TUM-Dynamics-Lecture, 2\n\nCreated by some colleagues of mine, these two lectures offer a great introduction to Julia and its applications in the field of dynamical systems. The lectures are held in Julia and are a great way to get started with the language."
  },
  {
    "objectID": "manuals/julia_links/index.html#resources",
    "href": "manuals/julia_links/index.html#resources",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Resources",
    "text": "Resources\n\nJulia Homepage (last visited: 31/07/2023)\nJulia Documentation (last visited: 31/07/2023)\n\nOnce you are familiar with the basics of Julia, the documentation is the best place to look up specific functions and syntax. Especially helpful are the following manuals: Performance Tips, Workflow Tips, and the Style Guide.\n\nSciML Style Guide for Julia, by Chris Rackauckas (last visited: 31/07/2023)\n\nA style guide for scientific machine learning in Julia. This guide is a work in progress and is updated regularly."
  },
  {
    "objectID": "manuals/julia_links/index.html#packages",
    "href": "manuals/julia_links/index.html#packages",
    "title": "Julia Programming Language: Links & Resources",
    "section": "Packages",
    "text": "Packages\n\nDataFrames.jl\n\nA package for working with tabular data in Julia. The package is part of the Julia Data Ecosystem and offers a wide range of tools for data manipulation and analysis.\n\nDifferentialEquations.jl\n\nOne of the most popular packages for solving differential equations in Julia. The package is part of the SciML ecosystem and offers a wide range of solvers for ordinary and partial differential equations.\n\nJLD2.jl\n\nA package for saving and loading Julia data structures. Can also used for compressions (see CodecZlib.jl for more information).\n\nMakie.jl and its Documentation\n\nA high-performance plotting library for Julia. It features multiple backends and is highly customizable.\nAlso check out\n\nGeoMakie.jl for plotting geospatial data.\nColors.jl and ColorSchemes.jl for improved color handling.\n\n\nMeasurements.jl\n\nA physics package that handles uncertainty propagations coming from any kind of physical measuements.\n\nProgressMeter.jl\n\nProgress meter for long-running operations in Julia\n\nRevise.jl\n\nA package that allows you to modify your code without having to restart the Julia session. This is especially useful when working with large projects.\n\nUnitful.jl\n\nA package that allows you to work with physical units in Julia."
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "ExESS",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 Alexander Smolka\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  }
]