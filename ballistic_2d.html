<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ballistic Flight - 2D · ExosphereSimulations.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ExosphereSimulations.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Base</span><ul><li class="is-active"><a class="tocitem" href="ballistic_2d.html"><strong>B</strong>allistic Flight - 2D</a></li><li><a class="tocitem" href="residence_time.html"><strong>R</strong>esidence Time</a></li><li><a class="tocitem" href="solar_angle.html"><strong>S</strong>olar Angle</a></li><li><a class="tocitem" href="spherical_grids.html"><strong>S</strong>pherical Grids</a></li><li><a class="tocitem" href="temperatures.html"><strong>T</strong>emperatures</a></li><li><a class="tocitem" href="utils.html"><strong>U</strong>tility</a></li><li><a class="tocitem" href="velocity_distribution.html"><strong>V</strong>elocity Distributions</a></li></ul></li><li><span class="tocitem">Lunar Surface Density Simulation</span><ul><li><a class="tocitem" href="LunarSurfaceDensity/main.html">Main</a></li><li><a class="tocitem" href="LunarSurfaceDensity/input.html">Input</a></li><li><a class="tocitem" href="LunarSurfaceDensity/example.html">Example</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="ballistic_2d.html"><strong>B</strong>allistic Flight - 2D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ballistic_2d.html"><strong>B</strong>allistic Flight - 2D</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/ballistic_2d.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ballistic-Flight-2D"><a class="docs-heading-anchor" href="#Ballistic-Flight-2D">Ballistic Flight - 2D</a><a id="Ballistic-Flight-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Ballistic-Flight-2D" title="Permalink"></a></h1><p>The <strong>Ballistic Flight - 2D</strong> function library offers algorithms to calculate the orbit parameters of a particle inside of a <em>surface-bounded exosphere</em>, which is solely affected by gravity. An exception are the <a href="https://en.wikipedia.org/wiki/Coriolis_force">coriolis forces</a>, which are applied both before and after the trajectory calculations.</p><p>The main functionality of this library is to offer the user a way to calculate the landing  coordinates of a particle after completing a ballistic flight, which is usually defined  through a launch longitude and latitude, as well as a launch velocity vector.</p><hr/><h3 id="Physical-Background-and-Implementation"><a class="docs-heading-anchor" href="#Physical-Background-and-Implementation">Physical Background &amp; Implementation</a><a id="Physical-Background-and-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Background-and-Implementation" title="Permalink"></a></h3><p>The intended use features the custom struct <a href="ballistic_2d.html#ExosphereSimulations.BallisticTrajectory2D"><code>BallisticTrajectory2D</code></a>, which is usually created based on the body&#39;s radius <code>R</code>, its mass <code>m</code>, the launch coordinates <code>launch_coords</code> as a <code>Tuple{Float64, Float64}</code> holding the SSE longitude and SSE latitude in radians, as well as the launch velocity vector <code>v</code>.</p><pre><code class="language-julia hljs">bt = BallisticTrajectory2D(R, m, launch_coords, v)</code></pre><p>Alternatively, a specialized constructor method can be used, which is numerically optimized to incorporate the constants for the radius and mass. A ballistic trajectory of a particle in the <em>lunar</em> exosphere is based on <code>MOON_RADIUS</code>, and <code>MOON_MASS</code>.</p><pre><code class="language-julia hljs">bt_moon = BallisticTrajectory2DMoon(launch_coords, v)</code></pre><div class="admonition is-info"><header class="admonition-header">Performance</header><div class="admonition-body"><p>While <code>BallisticTrajectory2D(MOON_RADIUS, MOON_MASS, launch_coords, v) == BallisticTrajectory2DMoon(launch_coords, v)</code> a benchmark performance test using the <code>BenchmarkTools</code> package indicates that the  specialized function runs roughly 1.5 times quicker.</p></div></div><p>Should the coriolis effect be included in the calculations, another specialized constructor can be used, which further requires input of the length of a day for the respective rotating body <code>day</code> in seconds.</p><pre><code class="language-julia hljs">btc = BallisticTrajectory2DCoriolis(R, m, day, launch_coords, v)</code></pre><p>Similarly, a body-specific constructor also exists.</p><pre><code class="language-julia hljs">btc_moon = BallisticTrajectory2DCoriolisMoon(launch_coords, v)</code></pre><hr/><p>These constructors combine the implemented functions in a numerically efficient way, though all functions and calculations can also be called and performed separately. The main workflow includes calculations of:</p><ul><li>escape velocity of the respective body <code>vesc</code> – <a href="ballistic_2d.html#ExosphereSimulations.escape_velocity"><code>escape_velocity</code></a></li><li>semi-major axis or the elliptical trajectory <code>a</code> – <a href="ballistic_2d.html#ExosphereSimulations.semi_major_axis"><code>semi_major_axis</code></a></li><li>eccentricity of the elliptical trajectory <code>e</code> – <a href="ballistic_2d.html#ExosphereSimulations.eccentricity"><code>eccentricity</code></a></li><li>true anomaly at launch <code>theta0</code> – <a href="ballistic_2d.html#ExosphereSimulations.true_anomaly"><code>true_anomaly</code></a></li><li>time of flight <code>t</code> – <a href="ballistic_2d.html#ExosphereSimulations.time_flight"><code>time_flight</code></a></li><li>ground flight distance <code>d</code> – <a href="ballistic_2d.html#ExosphereSimulations.ground_distance"><code>ground_distance</code></a></li><li>landing coordinates in SSE coordinate system <code>land_coords</code> – <a href="ballistic_2d.html#ExosphereSimulations.landing_coords"><code>landing_coords</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Velocity Vector Format</header><div class="admonition-body"><p>All subsequent functions assume the following format for the velocity vector <code>v</code>:</p><ul><li><code>v[1]</code>: positive longitudinal direction</li><li><code>v[2]</code>: positive latitudinal direction (pointing towards the north-pole)</li><li><code>v[3]</code>: normal &amp; pointing away from the surface (in radial direction)</li></ul></div></div><hr/><h4 id="Escape-Velocity-[escape_velocity](@ref)"><a class="docs-heading-anchor" href="#Escape-Velocity-[escape_velocity](@ref)">Escape Velocity &gt; <a href="ballistic_2d.html#ExosphereSimulations.escape_velocity"><code>escape_velocity</code></a></a><a id="Escape-Velocity-[escape_velocity](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Escape-Velocity-[escape_velocity](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">vesc = escape_velocity(R, m)
vesc = escape_velocity(MOON_RADIUS, MOON_MASS) # vesc == MOON_vesc</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Escape_velocity">escape velocity</a> can be calculated using the body&#39;s radius <span>$R$</span> and its mass <span>$m$</span>:</p><p class="math-container">\[v_{esc} = \sqrt{\frac{2 G m}{R}}\]</p><p>with the gravitational constant <span>$G$</span>, which is implemented in the package as the constant <code>GRAVITATIONAL_CONSTANT</code>.</p><hr/><h4 id="Semi-Major-Axis-[semi_major_axis](@ref)"><a class="docs-heading-anchor" href="#Semi-Major-Axis-[semi_major_axis](@ref)">Semi-Major Axis &gt; <a href="ballistic_2d.html#ExosphereSimulations.semi_major_axis"><code>semi_major_axis</code></a></a><a id="Semi-Major-Axis-[semi_major_axis](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-Major-Axis-[semi_major_axis](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">a = semi_major_axis(R, f2)
a = semi_major_axis(R, m, v) # calculates f2 = fvesc2(R, m, v)
a = semi_major_axis_moon(f2) # a == semi_major_axis(MOON_RADIUS, f2)
a = semi_major_axis_moon(v)  # a == semi_major_axis(MOON_RADIUS, MOON_MASS, v)</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Semi-major_and_semi-minor_axes">semi-major axis</a> of the elliptical trajectory is calculated using the body&#39;s radius <span>$R$</span>, which is equal to the radius of the elliptical orbit at launch from the surface, as well as the auxiliary variable <span>$f_2$</span>. <sup class="footnote-reference"><a id="citeref-Schorghofer2021" href="#footnote-Schorghofer2021">[Schorghofer2021]</a></sup></p><p class="math-container">\[a = \frac{R}{2 \cdot \left(1 - f_2 \right)}\]</p><p>with</p><p class="math-container">\[f_2 = \left( \frac{|\vec{v}|}{v_{esc}} \right)^2.\]</p><p>The squared fraction of the escape velocity can be access through the <a href="ballistic_2d.html#ExosphereSimulations.fvesc2"><code>fvesc2</code></a> function.</p><pre><code class="language-julia hljs">f2 = fvesc2(vesc, v)
f2 = fvesc2(R, m, v)    # calculates vesc = escape_velocity(R, m)
f2 = fvesc2_moon(v)     # vesc = MOON_vesc</code></pre><hr/><h4 id="Eccentricity-[eccentricity](@ref)"><a class="docs-heading-anchor" href="#Eccentricity-[eccentricity](@ref)">Eccentricity &gt; <a href="ballistic_2d.html#ExosphereSimulations.eccentricity"><code>eccentricity</code></a></a><a id="Eccentricity-[eccentricity](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Eccentricity-[eccentricity](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">e = eccentricity(f2, alpha)
e = eccentricity(f2, v)     # calculates alpha = zenith_angle(v)
e = eccentricity(R, m, v)   # calculates f2 = fvesc2(R, m, v) &amp; alpha = zenith_anlge(v)
e = eccentricity_moon(v)    # e == eccentricity(MOON_RADIUS, MOON_MASS, v)</code></pre><p>One of the most important properties of a elliptical trajectory is the  <a href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a>, which is calculated based on the squared fraction of the escape velocity <span>$f_2$</span> and the zenith angle <span>$\alpha$</span>. <sup class="footnote-reference"><a id="citeref-Schorghofer2021" href="#footnote-Schorghofer2021">[Schorghofer2021]</a></sup></p><p class="math-container">\[e = \sqrt{1 - 4 f_2 \cdot (1 - f_2) \cdot \sin^2 \alpha)} \]</p><p>with</p><p class="math-container">\[\alpha = \tan^{-1} \left( \frac{\sqrt{v_1^2 + v_2^2}}{v_3} \right)\]</p><p>The zenith angle can be access through the <a href="ballistic_2d.html#ExosphereSimulations.zenith_angle"><code>zenith_angle</code></a> function:</p><pre><code class="language-julia hljs">alpha = zenith_angle(v)
alpha = zenith_angle(traj)</code></pre><hr/><h4 id="True-Anomaly-[true_anomaly](@ref)"><a class="docs-heading-anchor" href="#True-Anomaly-[true_anomaly](@ref)">True Anomaly &gt; <a href="ballistic_2d.html#ExosphereSimulations.true_anomaly"><code>true_anomaly</code></a></a><a id="True-Anomaly-[true_anomaly](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#True-Anomaly-[true_anomaly](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">theta  = true_anomaly(r, a, e)
theta0 = true_anomaly_0_moon(a, e) # theta0 == true_anomaly(MOON_RADIUS, a, e)
theta0 = true_anomaly_0_moon(v)    # calculates a = semi_major_axis(v) &amp; e = eccentricity(v)</code></pre><p>The <a href="https://en.wikipedia.org/wiki/True_anomaly">true anomaly</a> is the angular parameter which describes the position of a body moving along the elliptical orbit. While its  time-dependent calculation is numerically expensive to find for all non-circular orbits, its value at a given radial position <span>$r$</span> can be analytically calculated based on the semi-major  axis <span>$a$</span> and the eccentricity <span>$e$</span> of the elliptical orbit. <sup class="footnote-reference"><a id="citeref-Walter2018" href="#footnote-Walter2018">[Walter2018]</a></sup></p><p class="math-container">\[\theta = \cos^{-1} \left( \frac{1}{e} \cdot \left( \frac{a}{r} \cdot (1 - e^2) - 1\right) \right)\]</p><p>which follows from the definitions of the radial position <span>$r$</span></p><p class="math-container">\[r = \frac{p}{1 + e \cdot \cos \theta}\]</p><p>and the <a href="https://en.wikipedia.org/wiki/Semi-major_and_semi-minor_axes">semi-latus rectum</a> <span>$p$</span></p><p class="math-container">\[p = a \cdot (1 - e^2).\]</p><div class="admonition is-info"><header class="admonition-header">True Anomaly at Launch Position</header><div class="admonition-body"><p>This function is usually used to calculate the true anomaly <span>$\theta$</span> at the launch position <span>$\theta_0$</span> where the radial position of the elliptical orbit <span>$r$</span> is equal to the radius of the body from which the particle is launched <span>$R$</span>. This case can be handled with the body-specific versions of the function, e.g. <code>true_anomaly_0_moon</code>.</p></div></div><hr/><h4 id="Time-of-Flight-[time_flight](@ref)"><a class="docs-heading-anchor" href="#Time-of-Flight-[time_flight](@ref)">Time of Flight &gt; <a href="ballistic_2d.html#ExosphereSimulations.time_flight"><code>time_flight</code></a></a><a id="Time-of-Flight-[time_flight](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-of-Flight-[time_flight](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">time_flight(t0, P)
time_flight(e, theta0, P) # calculates t0 = time_theta(e, theta0, P)</code></pre><p>The total time of flight <span>$t_f$</span> </p><p class="math-container">\[t_f = P - 2 \cdot t_0\]</p><p>is equal to the total orbital period <span>$P$</span></p><p class="math-container">\[P = 2 \pi \cdot \sqrt{ \frac{a^3}{m \cdot G} }\]</p><p>minus twice the orbit time at the true anomaly of the launch position <span>$\theta_0$</span></p><p class="math-container">\[t_0 = P \cdot \frac{M_0}{2 \pi} \\[3mm]
M_0 = E_0 - e \cdot \sin E_0 \\[3mm]
E_0 = 2 \cdot \tan^{-1} \left( \sqrt{\frac{1-e}{1+e}} \cdot \tan \left( \frac{\theta_0}{2} \right) \right)\]</p><p>with the <a href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly</a> <span>$M_0$</span>, and  <a href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a> <span>$E_0$</span> at the launch position <span>$\theta_0$</span>, which is reached at the orbit time <span>$t_0$</span>. <sup class="footnote-reference"><a id="citeref-Walter2018" href="#footnote-Walter2018">[Walter2018]</a></sup></p><p>All intermediate steps and variables can also be calculated using the functions <a href="ballistic_2d.html#ExosphereSimulations.orbit_period"><code>orbit_period</code></a>, <a href="ballistic_2d.html#ExosphereSimulations.mean_anomaly"><code>mean_anomaly</code></a>, <a href="ballistic_2d.html#ExosphereSimulations.eccentric_anomaly"><code>eccentric_anomaly</code></a>, as well as the different time calculation functions <a href="ballistic_2d.html#ExosphereSimulations.time_theta"><code>time_theta</code></a>, <a href="ballistic_2d.html#ExosphereSimulations.time_E"><code>time_E</code></a>, and <a href="ballistic_2d.html#ExosphereSimulations.time_M"><code>time_M</code></a>.</p><pre><code class="language-julia hljs">P = orbit_period(a)
P = orbit_period(v) # calculates a = semi_major_axis(v)

# calculates anomalies at launch
theta0 = true_anomaly(R, a, e)
E0     = eccentric_anomaly(e, theta0)
M0     = mean_anomaly(e, E0)

# all equal, calculates time at launch for different input arguments
t0 = time_theta(e, theta0, P)
t0 = time_E(e, E0, P)
t0 = time_M(M0, P)</code></pre><hr/><h4 id="Ground-Flight-Distance-[ground_distance](@ref)"><a class="docs-heading-anchor" href="#Ground-Flight-Distance-[ground_distance](@ref)">Ground Flight Distance &gt; <a href="ballistic_2d.html#ExosphereSimulations.ground_distance"><code>ground_distance</code></a></a><a id="Ground-Flight-Distance-[ground_distance](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Ground-Flight-Distance-[ground_distance](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">ground_distance(R, dtheta)
ground_distance(R, a, e)     # calculates dtheta based on a and e
ground_distance_moon(dtheta) # R = MOON_RADIUS
ground_distance_moon(a, e)   # R = MOON_RADIUS</code></pre><p>The projected ground flight distance is equal to the body&#39;s radius <span>$R$</span> times the covered flight angle, which is equal to the passed true anomaly from launch to landing <span>$\Delta \theta$</span>.</p><p class="math-container">\[d = \Delta \theta \cdot R.\]</p><p>Due to the symmetry of the ballistic flight problem, it follows</p><p class="math-container">\[\Delta \theta = 2 \pi - 2 \theta_0\]</p><p>with the true anomaly at the launch position <span>$\theta_0$</span>, see <a href="ballistic_2d.html#ExosphereSimulations.true_anomaly"><code>true_anomaly</code></a>.</p><hr/><h4 id="Landing-Coordinates-[landing_coords](@ref)"><a class="docs-heading-anchor" href="#Landing-Coordinates-[landing_coords](@ref)">Landing Coordinates &gt; <a href="ballistic_2d.html#ExosphereSimulations.landing_coords"><code>landing_coords</code></a></a><a id="Landing-Coordinates-[landing_coords](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Landing-Coordinates-[landing_coords](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">landing_coords(R, d, coords, v)
landing_coords(R, a, e, coords, v) # calculates d = ground_distance(R, a, e)</code></pre><p>Finding the landing SSE coordinates <span>$(\theta_1, \phi_1)$</span> based on the launch coordinates <span>$(\theta_0, \phi_0)$</span> as well as the body&#39;s radius <span>$R$</span>, which is equal to the radial position at launch, the ground distance traveled <span>$d$</span>, and the launch velocity vector <span>$\vec{v}$</span>. <sup class="footnote-reference"><a id="citeref-Schorghofer2021" href="#footnote-Schorghofer2021">[Schorghofer2021]</a></sup></p><p class="math-container">\[\cos \varphi = \frac{v_2}{\sqrt{v_1^2 +  v_2^2}} \\[3mm]
\sin \phi_1 = \sin \left( \frac{d}{R} \right) \cdot \cos \phi_0 \cdot \cos \varphi + \cos \left( \frac{d}{R} \right) \cdot \sin \phi_0 \\[3mm]
\cos \Delta \theta = \cos \left( \frac{d}{R} \right) \cdot \cos \phi_0 - \sin \left( \frac{d}{R} \right) \cdot \sin \phi_0 \cdot \cos \varphi \cdot \cos^{-1} \phi_1 \\[3mm]
\theta_1 = \theta_0 + \text{sign} \left( v_1 \right) \cdot \Delta \theta \]</p><p>with the azimuth angle <span>$\varphi$</span>, which can be computed via <a href="ballistic_2d.html#ExosphereSimulations.azimuth_angle"><code>azimuth_angle</code></a>. Note that due to round-off issues, <span>$\cos^{-1} \Delta \theta$</span> might be numerically unstable.  The package uses its custom utility function <a href="utils.html#ExosphereSimulations.limit_acos"><code>limit_acos</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Variable Symbol</header><div class="admonition-body"><p>Note that both the true anomaly <strong>AND</strong> the SSE longitude share the symbol <span>$\theta$</span>. While the index <span>$_0$</span> always indicates the launch position, the true anomaly <span>$\theta_0$</span> gives the angular position with respect to the elliptical orbit, while the SSE longitude <span>$\theta_0$</span> gives the angular position with respect to the body&#39;s reference system.</p></div></div><hr/><h4 id="Calculation-of-the-Photo-Time-[photo_time](@ref)"><a class="docs-heading-anchor" href="#Calculation-of-the-Photo-Time-[photo_time](@ref)">Calculation of the Photo Time &gt; <a href="ballistic_2d.html#ExosphereSimulations.photo_time"><code>photo_time</code></a></a><a id="Calculation-of-the-Photo-Time-[photo_time](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-of-the-Photo-Time-[photo_time](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">photo_time(traj::BallisticTrajectory2D; N=5)</code></pre><p>The calculation of the photo-time, namely the time a particle spends in direct line of  sight of the Sun and is, thus, susceptible to photo-destruction, is based on a <a href="https://en.wikipedia.org/wiki/Bisection_method">bi-section method</a> to find the point of the particle&#39;s orbit, where it emerges from the shadow. The general approach differentiates between four different cases, for which the figure below shows a two-dimensional sketch  of the procedure:</p><ol><li>both the launch and the landing position are on the day-side <strong>(a)</strong>,</li><li>both the launch and the landing position are on the night-side <strong>(b)</strong>,</li><li>the launch position is on the day-side, the landing position is on the night-side <strong>(c)</strong>, and</li><li>the launch position is on the night-side, the landing position is on the day-side <strong>(d)</strong>.</li></ol><p><img src="../img/phototime.png" alt/></p><p>All four sub-figures show the first four steps of the bi-section method, which is iteratively closing in on the transition true anomaly <span>$\theta_s$</span>, where the shadow ends. It starts of with the launch angular position <span>$\theta_0$</span> and the landing angular position <span>$\theta_1$</span>. For the first case, shown in <strong>(a)</strong>, it is assumed that the entire particles path is in direct sunlight, so no bi-section is necessary. For all the other three cases, the midway angular position is calculated and determined, whether it is Sun-lit. Based on this information, the new lower and upper limit, <span>$\theta_{lower}$</span> and <span>$\theta_{upper}$</span>, is set  and the next step of the bi-section method is conducted:</p><p class="math-container">\[\theta_{new} = \frac{\theta_{lower} + \theta_{upper}}{2}.\]</p><p>While this procedure is fairly straightforward for the third and fourth case, <strong>(c)</strong> and <strong>(d)</strong>, if both launch and landing positions are already in the shadowed region two transitions occur, thus two bi-section methods have to be used to find <span>$\theta_{S,1}$</span> and <span>$\theta_{S,2}$</span>. One special case is where the entire ellipse is in the shadows, so not even one intersection point can be found. The implemented code checks whether the <a href="https://en.wikipedia.org/wiki/Apsis">apogee</a> is in sun-lit, and if not the entire path is assumed to be shadowed.</p><p>The code only requires the particles trajectory <code>traj</code> and, optionally, the number of bi-section steps <code>N</code>, which defaults to <code>N=5</code>. While more steps lead to more accurate time calculations, they also greatly increase the numerical effort.</p><div class="admonition is-info"><header class="admonition-header">Approximations</header><div class="admonition-body"><p>Note that there are certain ellipses for the first case, where the particle&#39;s path can  intersect the shadowed region, though it is assumed that these paths never occur. This approximation becomes more and more valid for heavier particles, which cannot perform global jumps anymore.</p><p>Additionally, the approximation for the entirely shadowed case can have some exemptions where the apogee is shadowed, but still some part of the ellipse is sun-lit. This case  is excluded for numerical performance reasons.</p></div></div><hr/><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.BallisticTrajectory2D" href="#ExosphereSimulations.BallisticTrajectory2D"><code>ExosphereSimulations.BallisticTrajectory2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BallisticTrajectory2D(
    launch_coords   ::  Tuple{Float64, Float64},
    land_coords     ::  Tuple{Float64, Float64},
    v               ::  Vector{Float64},
    a               ::  Float64,
    e               ::  Float64,
    theta0          ::  Float64,
    t               ::  Float64,
    P               ::  Float64,
    d               ::  Float64,
    R               ::  Float64)
BallisticTrajectory2D(R::Real, m::Real, launch_coords::Tuple, v::AbstractVector) -&gt; BallisticTrajectory2D
BallisticTrajectory2DCoriolis(R::Real, m::Real, day::Real, launch_coords::Tuple, v::AbstractVector) -&gt; BallisticTrajectory2D</code></pre><p>Custom struct holding all relevant data about a ballistic trajectory. Note that the direct use of the main constructor method is not advised; using the outer constructor methods  calculates all missing data from the input variables.</p><p><strong>Fields</strong></p><table><tr><th style="text-align: center">Variable</th><th style="text-align: center">Description</th><th style="text-align: center">Unit</th></tr><tr><td style="text-align: center"><code>launch_coords</code></td><td style="text-align: center">launch SSE coordinates</td><td style="text-align: center">([rad], [rad])</td></tr><tr><td style="text-align: center"><code>land_coords</code></td><td style="text-align: center">landing SSE coordinates</td><td style="text-align: center">([rad], [rad])</td></tr><tr><td style="text-align: center"><code>v</code></td><td style="text-align: center">launch velocity vector</td><td style="text-align: center">[m s-1]</td></tr><tr><td style="text-align: center"><code>a</code></td><td style="text-align: center">semi-major axis</td><td style="text-align: center">[m]</td></tr><tr><td style="text-align: center"><code>e</code></td><td style="text-align: center">eccentricity</td><td style="text-align: center">[-]</td></tr><tr><td style="text-align: center"><code>theta0</code></td><td style="text-align: center">true anomaly at launch</td><td style="text-align: center">[rad]</td></tr><tr><td style="text-align: center"><code>t</code></td><td style="text-align: center">time of flight</td><td style="text-align: center">[s]</td></tr><tr><td style="text-align: center"><code>P</code></td><td style="text-align: center">period of elliptical orbit</td><td style="text-align: center">[s]</td></tr><tr><td style="text-align: center"><code>d</code></td><td style="text-align: center">ground flight distance</td><td style="text-align: center">[m]</td></tr><tr><td style="text-align: center"><code>R</code></td><td style="text-align: center">radius at launch</td><td style="text-align: center">[m]</td></tr></table><p><strong>Specialized Constructors</strong></p><ul><li><code>BallisticTrajectory2DMoon(launch_coords::Tuple, v::AbstractVector)</code></li><li><code>BallisticTrajectory2DCoriolisMoon(launch_coords::Tuple, v::AbstractVector)</code></li></ul><p>Note that the constructors generally perform better than their equivalent <code>BallisticTrajectory2D(MOON_RADIUS, MOON_MASS, launch_coords, v)</code> and  <code>BallisticTrajectory2DCoriolis(MOON_RADIUS, MOON_MASS, MOON_DAY, land_coords, v)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.add_coriolis_effect" href="#ExosphereSimulations.add_coriolis_effect"><code>ExosphereSimulations.add_coriolis_effect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_coriolis_effect(R::Real, day::Real, coords::Tuple, v::AbstractVector) -&gt; Vector{Float64}
add_coriolis_effect(day::Real, coords::Tuple) -&gt; Float64</code></pre><p>Adds the effects of the coriolis effect based on the body&#39;s radius <code>R</code>, its length of day  <code>day</code>, and the position coordinates <code>coords</code>, either onto the given velocity vector <code>v</code>, or onto the current longitudinal position. The choice depends on the input variables.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>add_coriolis_effect_moon(coords::Tuple, v::AbstractVector)</code></li><li><code>add_coriolis_effect_moon(coords::Tuple)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.azimuth_angle" href="#ExosphereSimulations.azimuth_angle"><code>ExosphereSimulations.azimuth_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">azimuth_angle(v::AbstractVector) -&gt; Float64
cos_azimuth_angle(v::AbstractVector) -&gt; Float64</code></pre><p>Calculates the azimuth angle of the launch velocity vector <code>v</code>, or similarly its cosine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.eccentric_anomaly" href="#ExosphereSimulations.eccentric_anomaly"><code>ExosphereSimulations.eccentric_anomaly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eccentric_anomaly(e::Real, theta::Real) -&gt; Float64</code></pre><p>Calculates the eccentric anomaly, given the orbit&#39;s eccentricity <code>e</code> and the true anomaly <code>theta</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.eccentricity" href="#ExosphereSimulations.eccentricity"><code>ExosphereSimulations.eccentricity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eccentricity(f2::Real, alpha::Real) -&gt; Float64
eccentricity(f2::Real, v::AbstractVector) -&gt; Float64 
eccentricity(R::Real, m::Real, v::AbstractVector) -&gt; Float64</code></pre><p>Calculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction <code>f2</code>, and the zenith launch angle <code>alpha</code>. Can also be called using the launch velocity vector <code>v</code> directly, or using the radius <code>R</code> and mass <code>m</code> of the respective body from which the particle is launched.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>eccentricity_moon(v::AbstractVector)</code></li></ul><p><strong>Notes</strong></p><ul><li><code>e = 0</code>: circular orbit</li><li><code>0 &lt; e &lt; 1</code>: elliptical orbit</li><li><code>e = 1</code>: parabolic trjectory</li><li><code>e &gt; 1</code>: hyperbolic trajectory</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.escape_velocity" href="#ExosphereSimulations.escape_velocity"><code>ExosphereSimulations.escape_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escape_velocity(R::Real, m::Real) -&gt; Float64</code></pre><p>Calculates the magnitude of the escape velocity for a body of radius <code>R</code> and mass <code>m</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.fvesc2" href="#ExosphereSimulations.fvesc2"><code>ExosphereSimulations.fvesc2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fvesc2(v_esc::Real, v::AbstractVector) -&gt; Float64
fvesc2(R::Real, m::Real, v::AbstractVector) -&gt; Float64</code></pre><p>Calculates the squared fraction of the velocity vector <code>v</code> with respect to the escape velocity <code>v_esc</code>. Can also be called based on the respective body&#39;s radius <code>R</code> and mass <code>m</code>.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>fvesc2_moon(v::AbstractVector)</code></li></ul><p><strong>Notes</strong></p><ul><li><code>&gt;= 1</code>: no orbit, particle escape gravitational field</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.ground_distance" href="#ExosphereSimulations.ground_distance"><code>ExosphereSimulations.ground_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ground_distance(R::Real, dTheta::Real) -&gt; Float64
ground_distance(R::Real, a::Real, e::Real) -&gt; Float64</code></pre><p>Calculates the ground flight distance covered by an angle <code>dtheta</code> of an elliptical orbit,  which intersects with a body of radius <code>R</code>. Can be called using the orbit&#39;s semi-major axis <code>a</code>, and its eccentricity <code>e</code>.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>ground_distance_moon(dtheta::Real)</code></li><li><code>ground_distance_moon(a::Real, e::Real)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.landing_coords" href="#ExosphereSimulations.landing_coords"><code>ExosphereSimulations.landing_coords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">landing_coords(R::Real, d::Real, coords::Tuple, v::AbstractVector) -&gt; Tuple{Float64, Float64}
landing_coords(R::Real, a::Real, e::Real, coords::Tuple, v::AbstractVector) -&gt; Tuple{Float64, Float64}</code></pre><p>Calculates the landing coordinates in SSE degree. Input variables are:</p><table><tr><th style="text-align: right">Variable</th><th style="text-align: right">Description</th><th style="text-align: right">Unit</th></tr><tr><td style="text-align: right"><code>R</code></td><td style="text-align: right">body&#39;s radius and radial launch distance</td><td style="text-align: right">[m]</td></tr><tr><td style="text-align: right"><code>d</code></td><td style="text-align: right">ground flight distance</td><td style="text-align: right">[m]</td></tr><tr><td style="text-align: right"><code>a</code></td><td style="text-align: right">semi-major axis of elliptical trajectory</td><td style="text-align: right">[m]</td></tr><tr><td style="text-align: right"><code>e</code></td><td style="text-align: right">eccentricity of elliptical trajectors</td><td style="text-align: right">[-]</td></tr><tr><td style="text-align: right"><code>coords</code></td><td style="text-align: right">launch coordinates</td><td style="text-align: right">([rad], [rad])</td></tr><tr><td style="text-align: right"><code>v</code></td><td style="text-align: right">launch velocity vector</td><td style="text-align: right">[m s-1]</td></tr></table></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.mean_anomaly" href="#ExosphereSimulations.mean_anomaly"><code>ExosphereSimulations.mean_anomaly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean_anomaly(e::Real, E::Real) -&gt; Float64</code></pre><p>Calculates the mean anomaly, given the orbit&#39;s eccentricity <code>e</code> and the eccentric anomaly <code>E</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.orbit_period" href="#ExosphereSimulations.orbit_period"><code>ExosphereSimulations.orbit_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orbit_period(a::Real, m::Real) -&gt; Float64</code></pre><p>Calculates the period of an elliptical orbit, based on the semi-major axis <code>a</code>, and the body&#39;s mass <code>u</code>.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>orbit_period_moon(a::Real)</code></li><li><code>orbit_period_moon(v::AbstractVector)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.photo_time" href="#ExosphereSimulations.photo_time"><code>ExosphereSimulations.photo_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">photo_time(traj::BallisticTrajectory2D; N=5) -&gt; Float64</code></pre><p>Calculates the time a particle spends in direct line of sight of the Sun, during its  trajectory <code>traj</code>. The optional input <code>N</code> controls the number of iteration steps during  the calculations.</p><p>The algorithm differntiates between four different szenarios:</p><ol><li>launch and landing position are on the day-side,</li><li>launch and landing position are on the night-side,</li><li>launch position is on the day-side, landing position is on the night-side, and</li><li>launch position is on the night-side, landing position is on the day-side.</li></ol><p>Each one of these szenarios is handled differently, with increasing numerical effort. Generally, the last three szenarios&#39; calculation is based upon a bi-section method to find the true anomaly at which the particles enters the shadow.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.semi_latus_rectum" href="#ExosphereSimulations.semi_latus_rectum"><code>ExosphereSimulations.semi_latus_rectum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">semi_latus_rectum(a::Real, e::Real) -&gt; Float64</code></pre><p>Calculates the semi-latus-rectum of the elliptical trajetory defined through the semi-major axis <code>a</code> and the eccentricity <code>e</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.semi_major_axis" href="#ExosphereSimulations.semi_major_axis"><code>ExosphereSimulations.semi_major_axis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">semi_major_axis(R::Real, f2::Real) -&gt; Float64
semi_major_axis(R::Real, m::Real, v::AbstractVector) -&gt; Float64</code></pre><p>Calculates the semi-major axis of an elliptical orbit, which starts on the surface of a body with radius <code>R</code>, based on the trajectory&#39;s squared escape velocity fraction <code>f2</code>. Can also be called using the mass of the body <code>m</code> and the launch velocity vector <code>v</code>.</p><p><strong>Specialized Function Calls</strong></p><ul><li><code>semi_major_axis_moon(f2::Real)</code></li><li><code>semi_major_axis_moon(v::AbstractVector)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.time_E" href="#ExosphereSimulations.time_E"><code>ExosphereSimulations.time_E</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_E(e::Real, E::Real, P::Real) -&gt; Float64</code></pre><p>Calculates the time at the position of an orbit defined through the eccentric anomaly <code>E</code>, as  well as the orbit&#39;s eccentricity <code>e</code>, and the orbital period <code>P</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.time_flight" href="#ExosphereSimulations.time_flight"><code>ExosphereSimulations.time_flight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_flight(t0::Real, P::Real) -&gt; Float64
time_flight(e::Real, theta0::Real, P::Real) -&gt; Float64</code></pre><p>Calculates the time of flight of a particle on an elliptical trajectory with eccentricity <code>e</code>, symmetrically intersecting a body at the true anomaly <code>theta0</code>. Additionally requires the orbital period <code>P</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.time_M" href="#ExosphereSimulations.time_M"><code>ExosphereSimulations.time_M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_M(M::Real, P::Real) -&gt; Float64</code></pre><p>Calculates the time at the position of an orbit defined through the mean anomaly <code>M</code>, as  well as the orbital period <code>P</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.time_theta" href="#ExosphereSimulations.time_theta"><code>ExosphereSimulations.time_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">time_theta(e::Real, theta::Real, P::Real) -&gt; Float64</code></pre><p>Calculates the time at the position of an orbit defined through the true anomaly <code>theta</code>, as  well as the orbit&#39;s eccentricity <code>e</code>, and the orbital period <code>P</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.true_anomaly" href="#ExosphereSimulations.true_anomaly"><code>ExosphereSimulations.true_anomaly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">true_anomaly(r::Real, a::Real, e::Real) -&gt; Float64</code></pre><p>Calculates the true anomaly at the radial position <code>r</code> based on the semi-major axis <code>a</code>, and the eccentricity of the orbit <code>e</code>. </p><p><strong>Specialized Function Calls</strong></p><ul><li><code>true_anomaly_0_moon(a::Real, e::Real)</code></li><li><code>true_anomaly_0_moon(v::AbstractVector)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.zenith_angle" href="#ExosphereSimulations.zenith_angle"><code>ExosphereSimulations.zenith_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zenith_angle(v::AbstractVector) -&gt; Float64
zenith_angle(traj::BallisticTrajectory2D) -&gt; Float64</code></pre><p>Calculates the zenith launch angle based on the launch velocity vector <code>v</code>.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Schorghofer2021"><a class="tag is-link" href="#citeref-Schorghofer2021">Schorghofer2021</a><a href="https://github.com/nschorgh/Planetary-Code-Collection"><em>N. Schorghofer, 2021</em></a> &quot;Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces&quot; DOI: 10.5281/zenodo.594268, <em>Last Accessed: 2022/04/01</em></li><li class="footnote" id="footnote-Walter2018"><a class="tag is-link" href="#citeref-Walter2018">Walter2018</a><a href="https://doi.org/10.1007/978-3-319-74373-8"><em>U. Walter, 2018</em></a> &quot;Astronautics&quot;, 3rd Edition, DOI: 10.1007/978-3-319-74373-8 </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="residence_time.html"><strong>R</strong>esidence Time »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 27 April 2022 11:13">Wednesday 27 April 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
