<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spherical Grids · ExosphereSimulations.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ExosphereSimulations.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Base</span><ul><li><a class="tocitem" href="ballistic_2d.html"><strong>B</strong>allistic Flight - 2D</a></li><li><a class="tocitem" href="residence_time.html"><strong>R</strong>esidence Time</a></li><li><a class="tocitem" href="solar_angle.html"><strong>S</strong>olar Angle</a></li><li class="is-active"><a class="tocitem" href="spherical_grids.html"><strong>S</strong>pherical Grids</a></li><li><a class="tocitem" href="temperatures.html"><strong>T</strong>emperatures</a></li><li><a class="tocitem" href="utils.html"><strong>U</strong>tility</a></li><li><a class="tocitem" href="velocity_distribution.html"><strong>V</strong>elocity Distributions</a></li></ul></li><li><span class="tocitem">Lunar Surface Density Simulation</span><ul><li><a class="tocitem" href="LunarSurfaceDensity/main.html">Main</a></li><li><a class="tocitem" href="LunarSurfaceDensity/input.html">Input</a></li><li><a class="tocitem" href="LunarSurfaceDensity/example.html">Example</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="spherical_grids.html"><strong>S</strong>pherical Grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="spherical_grids.html"><strong>S</strong>pherical Grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/spherical_grids.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Spherical-Grids"><a class="docs-heading-anchor" href="#Spherical-Grids">Spherical Grids</a><a id="Spherical-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-Grids" title="Permalink"></a></h1><p>For many functionalities of the <code>ExosphereSimulations</code> package, an underlying numerical grid is necessary. Such a grid discretizes the spherical body which hosts the surface-bounded exosphere into <code>N</code> grid elements, which are then used for all calculations.</p><p>The current hierarchically structure of numerical spherical grids features the following grids:</p><pre><code class="nohighlight hljs">SGrid
├── SGrid2D
│   ├── StructuredFullSGrid
│   ├── StructuredHalfSGrid
│   ├── FSpiralFullSGrid
│   ├── FSpiralHalfSGrid
│   └── HEALPixFullSGrid
└── SGrid3D</code></pre><hr/><h3 id="Physical-Background-and-Implementation"><a class="docs-heading-anchor" href="#Physical-Background-and-Implementation">Physical Background &amp; Implementation</a><a id="Physical-Background-and-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Background-and-Implementation" title="Permalink"></a></h3><p>The main task of the grid creation is the construction of the grid points on the surface of the sphere. These points can be expressed in spherical coordinates <span>$(R, \theta, \phi)$</span>, which are the radial distance from the sphere&#39;s center, and the two angular variables, the longitude and the latitude. For the two-dimensional grids, only the two angular positions are necessary. In the code implementation, all grid types have fields for the radius at <code>grid.R</code>, as well as the longitudes <code>grid.lngs</code> and the latitudes <code>grid.lats</code>.</p><hr/><h3 id="Two-Dimensional-Spherical-Grids"><a class="docs-heading-anchor" href="#Two-Dimensional-Spherical-Grids">Two-Dimensional Spherical Grids</a><a id="Two-Dimensional-Spherical-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Dimensional-Spherical-Grids" title="Permalink"></a></h3><h4 id="Structured-Grid-[StructuredFullSGrid](@ref)-and-[StructuredHalfSGrid](@ref)"><a class="docs-heading-anchor" href="#Structured-Grid-[StructuredFullSGrid](@ref)-and-[StructuredHalfSGrid](@ref)">Structured Grid &gt; <a href="spherical_grids.html#ExosphereSimulations.StructuredFullSGrid"><code>StructuredFullSGrid</code></a> &amp; <a href="spherical_grids.html#ExosphereSimulations.StructuredHalfSGrid"><code>StructuredHalfSGrid</code></a></a><a id="Structured-Grid-[StructuredFullSGrid](@ref)-and-[StructuredHalfSGrid](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-Grid-[StructuredFullSGrid](@ref)-and-[StructuredHalfSGrid](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">grid = StructuredFullSGrid(R, N_lng, N_lat)
grid = StructuredHalfSGrid(R, N_lng, N_lat)</code></pre><p>These grids construct a structured numerical grid, either on the entire sphere (<em>full</em>), or on just the upper hemisphere (<em>half</em>), thus assuming equatorial symmetry. Both constructors require three inputs, the radius <code>R</code> <span>$(R)$</span>, as well as the number of  structured elements in longitudinal direction <code>N_lng</code> <span>$(N_{lng})$</span> as well as in latitudinal direction <code>N_lat</code> <span>$(N_{lat})$</span>. Thus, the total number of grid elements is equal to</p><p class="math-container">\[N = N_{lng} \cdot N_{lat}.\]</p><p>Due to the structure of the grid, the creation of the grid points is fairly straightforward:</p><p class="math-container">\[\theta_i = \pi \cdot \left( \frac{2i-1}{N_{lng}} - 1 \right), \qquad \phi_j = \frac{\pi}{2} \cdot \left( \frac{2j-1}{N_{lat}} - 1 \right)\]</p><p>for <span>$1 \leq i \leq N_{lng}$</span> longitudes <span>$\theta_i$</span>, and <span>$1 \leq j \leq N_{lat}$</span> latitudes <span>$\phi_j$</span>.</p><div class="admonition is-info"><header class="admonition-header">Vectorization</header><div class="admonition-body"><p>The package <code>ExosphereSimulations</code> works exclusively with vectorized quantities for the grid elements. Thus, the created <code>lngs</code> (see <span>$\theta_i$</span>) and <code>lats</code> (see <span>$\phi_j$</span>) have to be properly repeated, using the <code>repeat</code> command in Julia:</p><pre><code class="language-julia hljs">lngs = repeat(lngs, inner=N_lat)
lats = repeat(lats, outer=N_lng)</code></pre></div></div><p>Another field of any <code>grid</code> is containing information about the surface area of each grid element, here saved as a vector of size <code>(N,)</code> in <code>grid.areas</code>. For every grid element with coordinates <span>$(\theta, \phi)$</span> the angular element sizes</p><p class="math-container">\[\Delta\theta = \frac{2\pi}{N_{lng}}, \qquad \Delta\phi = \frac{\pi}{N_{lat}}\]</p><p>can be used to calculate the respective size <span>$A$</span></p><p class="math-container">\[A = \int_\theta^{\theta+\Delta\theta} \int_\phi^{\phi+\Delta\phi} R^2 \cos \left( \theta \right) d\theta d\phi \\[3mm]
\Rightarrow A = \Delta\theta \cdot R^2 \cdot \left( \sin(\phi + \Delta\phi) - \sin(\phi) \right).\]</p><p><img src="../img/structuredgrid.png" alt="quadgrid"/></p><hr/><h4 id="Fibonnaci-Based-Spiral-Grid-[FSpiralFullSGrid](@ref)-and-[FSpiralHalfSGrid](@ref)"><a class="docs-heading-anchor" href="#Fibonnaci-Based-Spiral-Grid-[FSpiralFullSGrid](@ref)-and-[FSpiralHalfSGrid](@ref)">Fibonnaci-Based Spiral Grid &gt; <a href="spherical_grids.html#ExosphereSimulations.FSpiralFullSGrid"><code>FSpiralFullSGrid</code></a> &amp; <a href="spherical_grids.html#ExosphereSimulations.FSpiralHalfSGrid"><code>FSpiralHalfSGrid</code></a></a><a id="Fibonnaci-Based-Spiral-Grid-[FSpiralFullSGrid](@ref)-and-[FSpiralHalfSGrid](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Fibonnaci-Based-Spiral-Grid-[FSpiralFullSGrid](@ref)-and-[FSpiralHalfSGrid](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">grid = FSpiralFullSGrid(R, N)
grid = FSpiralHalfSGrid(R, N)</code></pre><p>Points on a spherical surface <span>$\mathcal{S}^2 := \left\{ x \in \mathcal{R}^3: |x| = 1 \right\}$</span>  which form a path in form of a spiral can be expressed in spherical coordinates of the form</p><p class="math-container">\[\theta=L\phi, \qquad 0 \leq \phi \leq \pi\]</p><p>for a unit sphere <span>$(R=1)$</span>, with the polar angle <span>$\phi$</span> and the azimuth <span>$\theta$</span>, or the  latitude and longitude, respectively. The factor <span>$L$</span> gives the slope of the spiral. One  generation method of <code>N</code> <span>$(N)$</span> points defines the two spherical coordinates as</p><p class="math-container">\[L = \sqrt{N\pi}, \qquad h_k = 1 -\frac{2k-1}{N}, \qquad \phi_k = \cos^{-1}(h_k), \qquad \theta_k = L\phi_k, \qquad k = 1,\dots, N\]</p><p>where the slope <span>$L$</span> is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by <span>$2\pi$</span> in <span>$\theta$</span>. <sup class="footnote-reference"><a id="citeref-Hardin2016" href="#footnote-Hardin2016">[Hardin2016]</a></sup></p><p>A specialized method of creating a set of spiral points implements the <a href="https://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci</a> sequence</p><p class="math-container">\[\left\{ F_k \right\} = \left\{1, 1, 2, 3, 5, 8, 13, \dots \right\}\]</p><p>and the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>  <span>$\varphi = \frac{1 + \sqrt{5}}{2}.$</span> The general algorithm defines a lattice of points on  the square <span>$\left[ 0,1 \right)^2$</span>, which is subsequently mapped to a unit sphere using  the Lambert cylindrical equal area projection <span>$\Lambda$</span>:</p><p class="math-container">\[\Lambda(x,y) = \left( \sqrt{1-(2y-1)^2}\cdot\cos\left(2\pi x\right), \sqrt{1-(2y-1)^2}\cdot\sin\left(2\pi x\right), 2y-1 \right)\]</p><p>in Cartesian coordinates, and</p><p class="math-container">\[\Lambda(x,y) = \left(\cos^{-1}(2y-1), 2\pi x \right) = \left( \phi, \theta \right)\]</p><p>in spherical coordinates. The points <span>$(x, y)$</span> on the square <span>$\left[ 0,1 \right)^2$</span> are created through</p><p class="math-container">\[(\tilde x, y)_{F_k} = \left( \frac{iF_{k-1}}{F_k} , \frac{i}{F_k} \right), \qquad 0 \leq i \leq F_k\]</p><p>where <span>$x = \tilde x - \lfloor \tilde x \rfloor$</span> as just the fractional part of <span>$\tilde x$</span>. <sup class="footnote-reference"><a id="citeref-Hardin2016" href="#footnote-Hardin2016">[Hardin2016]</a></sup></p><p>While this implementation can only be applied for <span>$N+1$</span> elements, where <span>$N \in \{ F_k \}$</span>, a more general approach involves the golden ratio <span>$\varphi$</span>. Based on <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Binet&#39;s_formula">Binet&#39;s formula</a>, the calculation of <span>$(x, y)$</span> can be changed to</p><p class="math-container">\[(\tilde x, y)_{N} = \left( \frac{i}{\varphi}, \frac{i}{N} \right), \qquad 0 \leq i \leq N\]</p><p><img src="../img/fspiralgrid.png" alt="fspiralgrid"/></p><div class="admonition is-info"><header class="admonition-header">$N+1 \rightarrow N$</header><div class="admonition-body"><p>Since the implementation always indexes <span>$i$</span> from <span>$0$</span> to <span>$N$</span>, a total of <span>$N+1$</span> points are created. In order to equalize the users input in the constructor methods with the actually created number of grid points, the code iterates from <code>0:N-1</code>.</p></div></div><hr/><h4 id="HEALPix-Grid-[HEALPixFullSGrid](@ref)"><a class="docs-heading-anchor" href="#HEALPix-Grid-[HEALPixFullSGrid](@ref)">HEALPix Grid &gt; <a href="spherical_grids.html#ExosphereSimulations.HEALPixFullSGrid"><code>HEALPixFullSGrid</code></a></a><a id="HEALPix-Grid-[HEALPixFullSGrid](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#HEALPix-Grid-[HEALPixFullSGrid](@ref)" title="Permalink"></a></h4><pre><code class="language-julia hljs">grid = HEALPixFullSGrid(R, k)</code></pre><p>HEALPix, Hierarchical Equal Area iso-Latitude Pixelization, was developed by NASA to have  three distinct properties, which are that</p><ol><li>the sphere is hierarchically tessellated into curvilinear quadrilaterals,</li><li>the pixelization is an equal area partition of <span>$\mathcal{S}^2$</span>, and</li><li>the point sets are distributed along fixed lines of latitude.</li></ol><p>The generation of such points firstly requires a division of the sphere into twelve equal area, four sided pixels defined by:</p><p class="math-container">\[|\cos\phi|&gt;\frac{2}{3}, \qquad \theta=m\frac{\pi}{2}, \qquad m = 0,1,2,3 \\[3mm]
\cos\phi = \frac{-2-4m}{3} + \frac{8\theta}{3\pi}, \qquad \frac{m\pi}{2} \leq \theta \leq \frac{(m+1)\pi}{2}, \qquad m=0,1,2,3 \\[3mm]
\cos\phi=\frac{2-4m}{3}-\frac{8\theta}{3\pi}, \qquad \frac{-(m+1)\pi}{2} \leq \theta \leq \frac{-m\pi}{2}, \qquad m=0,1,2,3.\]</p><p>These pixels can be further partitioned into a <span>$k \times k$</span> grid of sub-pixels of the same  shape and area. The points of the set are located in the centers of each pixel. The subdivision  leads to <span>$k$</span> iso-latitudinal rings at the polar region <span>$|\cos\phi|&gt;2/3$</span>, with</p><p class="math-container">\[|\cos\phi_i|=1-\frac{i^2}{3k^2}, \qquad \theta_j=\frac{\pi}{2i} \left( j - \frac{1}{2} \right),\]</p><p>thus, every <span>$i$</span>-th ring has <span>$4i$</span> equally spaced points. Closer to the equatorial region,  <span>$2k-1$</span> iso-latitudinal rings with <span>$4k$</span> points each emerge. These points are indexed by  <span>$k \leq |i| \leq 2k$</span> and <span>$1 \leq j \leq 4k$</span>:</p><p class="math-container">\[|\cos\phi_i| = \frac{4}{3} - \frac{2i}{3k}, \qquad \theta_j = \frac{\pi}{2k} \left( j - \frac{s}{2} \right), \qquad s = (i-k+1) \mod 2.\]</p><p>The last index, <span>$s$</span>, describes the phase shift between the rings. Finally, this configuration  produces a set of <span>$N=12k^2$</span> points. <sup class="footnote-reference"><a id="citeref-Hardin2016" href="#footnote-Hardin2016">[Hardin2016]</a></sup></p><p><img src="../img/healpixgrid.png" alt="healpixgrid"/></p><hr/><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.StructuredFullSGrid" href="#ExosphereSimulations.StructuredFullSGrid"><code>ExosphereSimulations.StructuredFullSGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StructuredFullSGrid(R::Real, N_lng::Int64, N_lat::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, areas::Vector{Float64})
StructuredFullSGrid(R::Real, N_lng::Int64, N_lat::Int64)</code></pre><p>Creates a container object referring to a regular, cell-centered, structured  numerical grid projected onto a sphere. The number of equally sized  cells in longitudinal direction <code>N_lng</code> is saved alongside <code>N_lat</code>, which gives the number of latitudinal cells with same angular height. The resulting vectors  <code>lngs</code> and <code>lats</code> hold the respective SSE coordinates. The passed radius <code>R</code> is  used to compute the surface area of the grid elements, which are stored in <code>areas</code>.</p><p>It is not recommended to create a <code>StructuredFullSGrid</code> directly but use the alternative constructor, which subsequently handles the calculation of <code>lngs</code>, <code>lats</code>, and <code>areas</code>.</p><p><strong>Specialized Constructors</strong></p><ul><li><code>StructuredFullSGridMoon(N_lng::Int64, N_lat::Int64)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.StructuredHalfSGrid" href="#ExosphereSimulations.StructuredHalfSGrid"><code>ExosphereSimulations.StructuredHalfSGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StructuredHalfSGrid(R::Real, N_lng::Int64, N_lat::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, areas::Vector{Float64})
StructuredHalfSGrid(R::Real, N_lng::Int64, N_lat::Int64)</code></pre><p>Creates a container object referring to a cell-centered, structured  numerical grid projected onto a hemisphere. The number of equally sized  cells in longitudinal direction <code>N_lng</code> is saved alongside <code>N_lat</code>, which gives the number of latitudinal cells with same angular height. The resulting vectors  <code>lngs</code> and <code>lats</code> hold the respective SSE coordinates. The passed radius <code>R</code> is  used to compute the surface area of the grid elements, which are stored in <code>areas</code>.</p><p>It is not recommended to create a <code>StructuredFullSGrid</code> directly but use the alternative constructor, which subsequently handles the calculation of <code>lngs</code>, <code>lats</code>, and <code>areas</code>.</p><p><strong>Specialized Constructors</strong></p><ul><li><code>StructuredHalfSGridMoon(N_lng::Int64, N_lat::Int64)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.FSpiralFullSGrid" href="#ExosphereSimulations.FSpiralFullSGrid"><code>ExosphereSimulations.FSpiralFullSGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FSprialFullSGrid(R::Real, N::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)
FSpiralFullSGrid(R::Real, N::Int64)</code></pre><p>Container object containing a spherical grid of <code>N</code> tri-elements of both hemisphere  of a perfect sphere of radius <code>R</code>. Field <code>lngs</code>, and <code>lats</code> hold the angular SSE  coordinates of each element in a vector of size <code>(N, )</code>. Note that this corresponds to the cell-center and not one of the verticies. The surface area of each element <code>area</code> is approximated to be equal for all elements as one N-th of the entire surface area.  For numerically efficient look-ups of this grid, a <code>KDTree</code> in cartesian coordinates is saved in <code>tree</code>.</p><p>It is not advised to use the base-constructor directly, but the secondary, outer constructor, which builds all inferred field directly.</p><p><strong>Specialized Constructors</strong></p><ul><li><code>FSpiralFullSGridMoon(N::Int64)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.FSpiralHalfSGrid" href="#ExosphereSimulations.FSpiralHalfSGrid"><code>ExosphereSimulations.FSpiralHalfSGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FSpiralHalfSGrid(R::Real, N::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)
FSpiralHalfSGrid(R::Real, N::Int64)</code></pre><p>Container object containing a spherical grid of <code>N</code> tri-elements of the upper hemisphere  of a perfect sphere of radius <code>R</code>. Field <code>lngs</code>, and <code>lats</code> hold the angular SSE  coordinates of each element in a vector of size <code>(N, )</code>. Note that this corresponds to the cell-center and not one of the verticies. The surface area of each element <code>area</code> is approximated to be equal for all elements as one N-th of the entire surface area of one hemisphere. For numerically efficient look-ups of this grid, a <code>KDTree</code> in cartesian coordinates is saved in <code>tree</code>.</p><p>It is not advised to use the base-constructor directly, but the secondary, outer constructor, which builds all inferred field directly.</p><p><strong>Specialized Constructors</strong></p><ul><li><code>FSpiralHalfSGridMoon(N::Int64)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.HEALPixFullSGrid" href="#ExosphereSimulations.HEALPixFullSGrid"><code>ExosphereSimulations.HEALPixFullSGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HEALPixFullSGrid(R::Float64, k::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)
HEALPixFullSGrid(R::Real, k::Int64)</code></pre><p>Container struct describing a spherical grid of equally distributed points based on the HEALPix algorithm. It holds the radius of the sphere <code>R</code>, the subdivisions of the twelve main pixels <code>k</code>, the resulting longitudinal and latitudinal coordinates <code>lngs</code> and <code>lats</code>, the area which is associated to each grid element <code>area</code>, and a <code>KDTree</code> structure for fast lookup of the grids coordinates <code>tree</code>.</p><p>The total number of grid elements is mainly based on the number of sub-pixels <code>k</code>, which further refines the twelve main HEALPix pixels: <code>N=12*k^2</code>.</p><p>It is not recommended to use the constructor directly but to build the grid using the outer constructor method, which correctly builds up all field information based purely on the sphere&#39;s radius and the number of subdivisions.</p><p><strong>Specialized Constructors</strong></p><ul><li><code>HEALPixFullSGridMoon(k::Int64)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.areas" href="#ExosphereSimulations.areas"><code>ExosphereSimulations.areas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">areas(grid::StructuredFullSGrid) -&gt; Vector{Float64}
areas(grid::StructuredHalfSGrid) -&gt; Vector{Float64}
areas(grid::FSpiralFullSGrid) -&gt; Vector{Float64}
areas(grid::FSpiralHalfSGrid) -&gt; Vector{Float64}
areas(grid::HEALPixFullSGrid) -&gt; Vector{Float64}
areas(grid::HEALPixHalfSGrid) -&gt; Vector{Float64}</code></pre><p>Returns the surface areas of each grid element as a vector in [m2].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ExosphereSimulations.coord2idx" href="#ExosphereSimulations.coord2idx"><code>ExosphereSimulations.coord2idx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coord2idx(grid::StructuredFullSGrid, lng::Real, lat::Real) -&gt; Int64
coord2idx(grid::StructuredHalfSGrid, lng::Real, lat::Real) -&gt; Int64
coord2idx(grid::FSpiralFullSGrid, lng::Real, lat::Real) -&gt; Int64
coord2idx(grid::FSpiralHalfSGrid, lng::Real, lat::Real) -&gt; Int64
coord2idx(grid::HEALPixFullSGrid, lng::Real, lat::Real) -&gt; Int64
coord2idx(grid::SGrid2D, coords::Tuple) -&gt; Int64</code></pre><p>Returns the index of the grid element of <code>grid</code> that contains the point defined by the coordinates <code>lng</code> and <code>lat</code>.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Hardin2016"><a class="tag is-link" href="#citeref-Hardin2016">Hardin2016</a><a href="https://arxiv.org/pdf/1607.04590.pdf"><em>Hardin et al., 2016</em></a>, &quot;A Comparison of Popular Point Configurations on S2&quot;, <a href="mailto:doug.hardin@vanderbilt.edu">doug.hardin@vanderbilt.edu</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="solar_angle.html">« <strong>S</strong>olar Angle</a><a class="docs-footer-nextpage" href="temperatures.html"><strong>T</strong>emperatures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 27 April 2022 11:13">Wednesday 27 April 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
