---
title: "Comparison of Landing Position Calculations: 2D vs. 3D"
# image: orbit.png
author: Alexander Smolka
date: 25 08 23
categories:
  - Julia
  - Example

---

```{julia}
#| echo: false
#| output: false
path_to_exess = joinpath(@__DIR__, "..", "..", "..", "exess.jl", "src", "ExESS.jl")
```
---

In this example, the landing position of a particle is calculated in two different ways: a two-dimensional approach based on spherical trigonometry proposed by @Butler1997 and refined by @Schoerghofer2022a, and a three-dimensional approach which solves the ODE of the trajectory numerically. The two approaches are compared in terms of accuracy and computational efficiency.

# Preparation

Firstly, the following examples were executed using the following Julia version:
```{julia}
versioninfo()
```

Next, the locally available ExESS package has to be loaded to access the two-dimensional `landing_position` and three-dimensional `trajectory` functions (see the [API](/api/exospheres/trajectory.qmd) page for details):
```{julia}
#| output: false
include(path_to_exess)
using .ExESS
using LinearAlgebra
```

Note that the additional package `LinearAlgebra` is loaded to access the `norm` function, which will be used later in the example. 

Before diving into the comparison and analysis, let us first test the two functions on a simple example. For this, we define the starting position and launch velocity of an arbitrary particle:

```{julia}
#| output: false
x0 = GlobalSphericalPosition(LUNAR_RADIUS, 0, 0)
v0 = LocalCartesianVelocity(250.0, 100.0, 100.0)
```

In the code above, the starting position is defined as a `GlobalSphericalPosition` with a radius of `LUNAR_RADIUS` and zero longitude and latitude. The launch velocity is defined as a `LocalCartesianVelocity` with a velocity of 250 m/s in the x-direction and 100 m/s in the y- and z-directions. Note the use of the different [coordinate systems](/documentation/fundamentals/coordinate_systems.qmd). Some of the functions require the two vectors in different kinds of coordinate systems, though the `ExESS` code is able to take care of all the conversions automatically. 

## 2D Landing Position

We can now calculate the landing position of the particle using the two-dimensional approach (for a detailed description of the algorithm, see the [documentation](/documentation/trajectories/ballistic_trajectories.qmd#sec-analytic_landing_position)):

```{julia}
x_landing_2d = landing_position(x0, v0)
```

Since we gave the function `landing_position` inputs in the format of the `ExESS`-defined coordinates, the output is also in the same format, i.e., a `GlobalSphericalPosition`. We can immediately check that the landing position is indeed on the surface of the Moon by looking at the first component of the output: `1.7374e6`, which is the radius of the Moon in meters.


## 3D Landing Position

We can do the same calculation using the three-dimensional approach. For this, we are using the predefined acceleration function `ddx_lunar_gravity` which calculates the acceleration due to the lunar gravity at a given position, plugging it into the `trajectory` function, together with our previously defined starting position and launch velocity vector. Since we are interested in the landing location, we are just extracting the last step of the trajectory object `traj,` where positions `[4:6]` are giving the x-, y-, and z-coordinates of the particle in cartesian coordinates. In order to compare the results with the two-dimensional approach, we are converting the cartesian coordinates into spherical coordinates using the `GlobalSphericalPosition` constructor:

```{julia}
traj = trajectory(x0, v0, ddx_lunar_gravity)
x_landing_3d = GlobalSphericalPosition(GlobalCartesianPosition(traj[end][4:6]))
```

Again, we can check that the landing position is on the surface of the Moon by looking at the first component of the output: `1.7374e6`, which is the radius of the Moon in meters. Without any complicated methods, we can already see that the two results are very similar, up to about the fifth decimal place for the angular arguments.

# Comparison

For an effective comparison, a single test of **one** starting position with **one** launch velocity is simply not enough. Since the algorithms assume that the Moon is a perfect sphere, the actual position of the launch should not have any influence on the landing position and can, therefore, be neglected in the comparison. A similar argument can be made for the azimuth angle of the launch velocity, leaving only two parameters to systematically analyze: the launch speed and the elevation angle.

In order to not fall prey to systematic errors due to specific starting locations or azimuth angles (i.e., influences of the numerical handling of the polar region in spherical coordinates), a Monte-Carlo-like comparison function is proposed:

```{julia}
#| output: false
function compare_2d_3d(vel, elev; N=10)
    Nv, Ne = length(vel), length(elev)
    e = zeros(Nv, Ne)
    for i in eachindex(vel), j in eachindex(elev)        
        for _ in 1:N
            lon, lat = rand(2) .* [2pi, pi] .- [pi, pi/2]
            x0 = GlobalCartesianPosition(LUNAR_RADIUS .* [
                    cos(lon)*cos(lat), 
                    sin(lon)*cos(lat), 
                    sin(lat)])

            az = rand()*2pi
            v0 = GlobalCartesianVelocity(x0, LocalCartesianVelocity(vel[i] .* [
                    cos(az) * cos(elev[j]), 
                    sin(az) * cos(elev[j]), 
                    sin(elev[j])]))

            x_landing_2d = GlobalCartesianPosition(landing_position(x0, v0))
            traj = trajectory(x0, v0, ddx_lunar_gravity; reltol=1e-6)
            x_landing_3d = GlobalCartesianPosition(traj[end][4:6])

            e[i,j] += norm(vec(x_landing_2d) - vec(x_landing_3d)) / N / LUNAR_RADIUS
        end
    end
    return e
end
```

The function `compare_2d_3d` takes in two vectors as inputs: the velocities and the elevation angles. The goal of the function is to calculate an error `e` for each combination of the two inputs. The Monte-Carlo approach is implemented in the line containing `for _ in 1:N`, which repeats the calculations `N`-times for each combination of the two inputs, subsequently averaging over all computed errors to get a better estimate of the actual error, independent of the starting position and azimuth angle. Inside of the loops, the starting position and azimuth angle are randomized and used to initialize `x0` and `v0`. Then, the landing positions are calculated based on both approaches (2D and 3D), saved as `x_landing_2d` and `x_landing_3d`, respectively. The error is then calculated as the norm of the difference between the two landing positions, normalized by the radius of the Moon. 

We can now define a velocity and elevation angle vector to test the function:

```{julia}
vel = 250:250:2000
elev = deg2rad.(10:10:80)
e = compare_2d_3d(vel, elev)
```

The 8-by-8 matrix shows the errors for each combination of `vel` and `elev`, with all values being below `1e-6`, thus only a couple of meters in physical units in the worst case. Running the `max` function over the matrix shows that the worst error is not that bad either. **Great!**

```{julia}
max(e...)
```

We can now visualize the results using a heatmap:

```{julia}
#| output: false
#| echo: false
using CairoMakie
include(joinpath(@__DIR__, "..", "..", "resources", "julia", "theme.jl"))

function plot_compare_2d_3d(v, elev, e)
    fig = Figure(; resolution=(600,400))
    ax = Axis(fig[1,1];
        xlabel="Velocity [m/s]",
        ylabel="Elevation Angle [rad]")

    hm = heatmap!(ax, v, rad2deg.(elev), e .* 1e5, colormap=lipari)
    Colorbar(fig[1,2], hm, label="Absolute Error, [10⁻⁵ Lunar Radius]")
    save(joinpath(@__DIR__, "compare_2d_3d.pdf"), fig, pt_per_unit=4)
    save(joinpath(@__DIR__, "compare_2d_3d.svg"), fig, pt_per_unit=4)
    save(joinpath(@__DIR__, "compare_2d_3d.png"), fig, px_per_unit=4)

    return nothing
end

vel = 50:50:2000
elev = deg2rad.(2.5:2.5:85)
e = compare_2d_3d(vel, elev; N=100)
plot_compare_2d_3d(vel, elev, e)
```

::: {.panel-tabset}

# {{< fa image >}} Figure
![Absolute error of landing position calculations based on two- and three-dimensional approaches, given varying speeds and elevation angles of the launch velocities.](./compare_2d_3d.svg){width="600px"}

# {{< fa code >}} Code
```julia
using CairoMakie
include(joinpath(@__DIR__, "..", "..", "resources", "julia", "theme.jl"))

function plot_compare_2d_3d(v, elev, e)
    fig = Figure(; resolution=(600,400))
    ax = Axis(fig[1,1];
        xlabel="Velocity [m/s]",
        ylabel="Elevation Angle [rad]")

    hm = heatmap!(ax, v, rad2deg.(elev), e .* 1e5, colormap=lipari)
    Colorbar(fig[1,2], hm, label="Absolute Error, [10⁻⁵ Lunar Radius]")
    save(joinpath(@__DIR__, "compare_2d_3d.png"), fig, px_per_unit=2)

    return nothing
end

vel = 50:50:2000
elev = deg2rad.(2.5:2.5:85)
e = compare_2d_3d(vel, elev; N=100)
plot_compare_2d_3d(vel, elev, e)
```

# {{< fa download >}} Downloads

* {{< downloadthis compare_2d_3d.pdf label="compare_2d_3d.pdf" type="light" dname="compare_2d_3d" >}} 
* {{< downloadthis compare_2d_3d.svg label="compare_2d_3d.svg" type="light" dname="compare_2d_3d" >}} 
* {{< downloadthis compare_2d_3d.png label="compare_2d_3d.png" type="light" dname="compare_2d_3d" >}} 

:::