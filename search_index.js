var documenterSearchIndex = {"docs":
[{"location":"LunarSurfaceDensity/main.html#Lunar-Surface-Density","page":"Main","title":"Lunar Surface Density","text":"","category":"section"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"Firstly, the ExosphereSimulations.jl package has to be loaded to be able to use its entire functionality:","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"include(joinpath(path, to, repository, \"src\", \"ExosphereSimulations.jl\"))\nusing .ExosphereSimulations","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"Now, both the base functions, as well as the sub-module LunarSurfaceDensity with all of its functionality are available. The usual workflow for setting up and running a simulation is based on first defining the problem using the LSDProblem constructor and then solving the problem using the solve function.","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"prob = LSDProblem(grid, physics, opt)\nsol = solve(prob)","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"While prob can also be created without passing the solver options opt to the constructor, both the numerical grid grid and the physical setup physics have to be known. The implemented numerical grids are:","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"StructuredFullSGrid,\nStructuredHalfSGrid,\nFSpiralFullSGrid,\nFSpiralHalfSGrid,\nHEALPixFullSGrid.","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"The physical parameters use a specific constructor called LSDPhysics, which holds the necessary physical description of the problem based on input parameters. A more detailed list can be found on the input page, which lists input parameters for various different species alongside a description and references. The general construction of the physics object is:","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"physics = LSDPhysics(amu, source_global, source_sunside, photorate, adheat, recycling, vdist)","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"note: Velocity Distribution\nIn the current version, the variable vdist has to be of type Symbol referring to one of the implemented velocity distributions. The allowed options are::Maxwell\n:MaxwellBoltzmannFlux","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"Finally, the solver options can be set manually, if the user should want to make changes to the default values. The constructor in question is LSDOptions and can be created empty","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"opt = LSDOptions()","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"to access all the default parameters, or using a keyword-value pair like","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"opt = LSDOptions(; N = 2_500)","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"which is adjusting the number of Monte-Carlo steps N. The available keywords can be found in the LSDOptions docstring.","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"Finally, now that the problem object prob has been created, we can pass it to the solver by","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"sol = solve(prob)","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"which creates a solution object of type LSDSolution, containing both the original problem prob, as well as the results of the simulation. Most importantly, it contains the predictions for the surface number densities n_0 in cm^-3 as sol.n0.","category":"page"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"","category":"page"},{"location":"LunarSurfaceDensity/main.html#API","page":"Main","title":"API","text":"","category":"section"},{"location":"LunarSurfaceDensity/main.html","page":"Main","title":"Main","text":"LunarSurfaceDensity\n\nLSDOptions\nLSDPhysics\nLSDProblem\nLSDSolution\n\nsavesol\ngridsavesol\nsolve\n\nLunarSurfaceDensity.path\nLunarSurfaceDensity._height_time\nLunarSurfaceDensity._particle_flight!\nLunarSurfaceDensity._surface_interaction","category":"page"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity","text":"Julia Package for simulating the surface number densities of the lunar surface-bounded exosphere.\n\n\n\n\n\n","category":"module"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.LSDOptions","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.LSDOptions","text":"LSDOptions(;\n    N           ::  Int64     = 1000,\n    vdist_N     ::  Int64     = 100_000,\n    vdist_atol  ::  Float64   = 1e-1,\n    photo_thr   ::  Float64   = 1e-3,\n    dt          ::  Float64   = MOON_DAY / 360,\n    ctrap_thr   ::  Float64   = 10.0,\n    h0          ::  Float64   = 1.0,\n    h0_N        ::  Int64     = 10,\n)\n\nCustom container for all required solver options for the lunar surface density study. The description of the solver options is shown below:\n\nOption Description Effect\nN Number of Monte-Carlo steps Simulation time, result accuracy\nvdist_N Number of sample points for MBF velocity distribution MBF velocity, MBF calc. time\nvdist_atol Absoltue tolerance of the MBF velocity calculation MBF calc. accuracy & time\nphoto_thr Threshold of photo-processes Simulation time, result accuracy\ndt Time step for surface interaction calculations Simulation time, ad-/desorption accuracy\nctrap_thr Cold-trap treshold \nh0 Surface height \nh0_N Number of surface height intervalls Simulation time, result accuracy\n\nNotes\n\nvdist_N & vdist_atol are only relevant if the used velocity distribution is a Maxwell-Boltzmann Flux distribution\nvdist_N increases the maximum possible velocity\nh0_N gets more relevant for heavier particles and bigger h0 values\n\n\n\n\n\n","category":"type"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.LSDPhysics","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.LSDPhysics","text":"LSDPhysics(\n    amu             ::  Float64, \n    source_global   ::  Float64, \n    source_sunside  ::  Float64, \n    photorate       ::  Float64, \n    adheat          ::  Float64\n    recycling       ::  Float64, \n    vdist           ::  Symbol)\n\nCustom container for all required physical input parameters for the lunar surface density study.\n\n\n\n\n\n","category":"type"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.LSDProblem","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.LSDProblem","text":"LSDProblem{T<:SGrid2D}(\n    grid    ::  T,\n    physics ::  LSDPhysics,\n    opt     ::  LSDOptions,\n    phi     ::  Vector{Float64},\n    T       ::  Vector{Float64},\n    tres    ::  Vector{Float64},\n    vdist   ::  VelocityDistribution,\n)\nLSDProblem(grid::SGrid2D, physics::LSDPhysics, opt::LSDOptions)\nLSDProblem(grid::SGrid2D, physics::LSDPhysics)\n\nCustom container of all necessary information to describe the lunar surface density simulation problem. It is not recommended to directly construct a LSDProblem, but  to use one of the additionally defined outer constructors.\n\nLSDProblem can be constructed without passing a opt to the constructor, at which the constructor will use the default LSDOptions values.\n\nField Description\ngrid Contains geometry and coordinates of the numerical grid\nphysics Contains physical input parameters for the simulation\nopt Contains solver options\nphi Solar incidence angles on the computational grid\nT Surface temperatures on the computational grid\ntres Residence time of the particle inside of the lunar regolith\nvdist ExosphereSimulations velocity distribution struct\n\n\n\n\n\n","category":"type"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.LSDSolution","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.LSDSolution","text":"LSDSolution(prob::LSDProblem, n0::Vector{FLoat64}, los::Vector{Float64})\n\nCustom solution struct for the solution of the lunar surface density simulation. It holds the initial problem definition prob, as well as the resulting surface density n0 over the defined numerical grid in [cm-3] and the fractions of lost particles lost in [s-1].\n\nDescription of lost vector\n\n Description\nlost[1] Fraction of particles lost through thermal escape\nlost[2] Fraction of particles lost through ionization processes\nlost[3] Fraction of particles lost in cold-traps\n\nThe surface density can be directly accessed by indexing the solution object with normal brackets:\n\njulia> sol = solve(prob);\n\njulia> sol(12)\n40231.123415\n\n\n\n\n\n","category":"type"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.savesol","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.savesol","text":"savesol(name::String, sol::LSDSolution)\n\nSaves the solutions sol longitudes, latitudes, and surface number densities in a .csv file specified in name. The coordinates are taken directly from the underlying numerical grid.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.gridsavesol","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.gridsavesol","text":"gridsavesol(name::String, sol::LSDSolution, glngs::Vector{T}, glats::Vector{S}) where {T <: Real, S <: Real})\n\nSaves the solutions sol longitudes, latitudes, and surface number densities in a .csv file specified in name. The coordinates are a grid created using the inputs glngs and  glats, which are the longitudinal and latitudinal sample points. \n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.solve","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.solve","text":"solve(prob::LSDProblem; logstep=10)\n\nMain simulation function of the lunar surface density simulation module. Requires prior definition of the module specific problem struct prob of type LSDProblem. The input logstep sets the intervall for logged information to be printed in the terminal during the simulation.\n\nThe function features a parallelized simulation call that splits the Monte-Carlo steps onto the available workers.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity.path","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity.path","text":"path(prob::LSDProblem, idx::Int64, w::Real)\n\nCalculate the path of a particle, initially launched from the grid element with index idx with a weight of w. Loops until the particle is lost. Returns particle density along the path and the lost fraction vector.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity._height_time","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity._height_time","text":"_height_time(v::Real, h=1e0; N=1)\n\nInternal function to compute the time a particle with vertical velocity v in  meters per second requires to reach h meter above ground. The additional variable N gives the number of parts the height is split into while calculating the  total travel time.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity._particle_flight!","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity._particle_flight!","text":"_particle_flight!(prob::LSDProblem, N0::AbstractVector, idx::Int64, coords::Tuple, w::Real, w0::Real)\n\nInternal function to handle the ballistic flight of the particle launched at coordinates given in coords, at the grid element of index idx, with a current weight of w and a initial weight of w0. Fills the entries of the resulting particle density vector N0  depending on the launch and landing position and velocity. Returns the landing grid element index, the exact landing coordinates, and the new, updated weight.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/main.html#ExosphereSimulations.LunarSurfaceDensity._surface_interaction","page":"Main","title":"ExosphereSimulations.LunarSurfaceDensity._surface_interaction","text":"_surface_interaction(prob::LSDProblem, idx::Int64, coords::Tuple)\n\nInternal function to handle the surface interaction. Dynamically adjusts the longitude with respect to the time the particle has spend inside of the surface. Returns the index of the element from where the particle is released, along side its exact coordinates.\n\n\n\n\n\n","category":"function"},{"location":"temperatures.html#Temperatures","page":"Temperatures","title":"Temperatures","text":"","category":"section"},{"location":"temperatures.html#Moon","page":"Temperatures","title":"Moon","text":"","category":"section"},{"location":"temperatures.html","page":"Temperatures","title":"Temperatures","text":"Diviner Averaged Diviner Snapshot\n(Image: ) (Image: )","category":"page"},{"location":"temperatures.html","page":"Temperatures","title":"Temperatures","text":"","category":"page"},{"location":"temperatures.html","page":"Temperatures","title":"Temperatures","text":"moon_surface_temperature","category":"page"},{"location":"temperatures.html#ExosphereSimulations.moon_surface_temperature","page":"Temperatures","title":"ExosphereSimulations.moon_surface_temperature","text":"moon_surface_temperature() -> Vector{Float64}, Vector{Float64}, Matrix{Float64}\nmoon_surface_temperature(grid::SGrid2D) -> Vector{Float64}\n\nReads averaged Diviner data to create and return temperature matrix at given longitudinal and latitudinal sample points.\n\nIf a grid is provide, the desired sample points for the lunar surface temperature are extracted from it and an interpolation object of the initial temperature matrix  is created and afterwards used to interpolate at the desired coordinates.\n\n\n\n\n\n","category":"function"},{"location":"velocity_distribution.html#Velocity-Distribution","page":"Velocity Distributions","title":"Velocity Distribution","text":"","category":"section"},{"location":"velocity_distribution.html#Maxwell-Velocity-Distribution","page":"Velocity Distributions","title":"Maxwell Velocity Distribution","text":"","category":"section"},{"location":"velocity_distribution.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"MaxwellVelocityDistribution","category":"page"},{"location":"velocity_distribution.html#ExosphereSimulations.MaxwellVelocityDistribution","page":"Velocity Distributions","title":"ExosphereSimulations.MaxwellVelocityDistribution","text":"MaxwellVelocityDistribution{T<:Real}(amu::T)\n\nStruct for the Maxwell velocity distribution holding the particle atomic mass unit amu.\n\nThe object itself can be used to draw a random sample vector from this velocity distribution. As input it requires only the temperature of the thermal equilibrium T:\n\njulia> max = MaxwellVelocityDistribution(4.0026);\n\njulia> max(250)\n3-element Vector{Float64}:\n -340.8406689399358\n -563.3849738101032\n  105.53990594265329\n\n\n\n\n\n","category":"type"},{"location":"velocity_distribution.html#Maxwell-Boltzmann-Flux-Velocity-Distribution","page":"Velocity Distributions","title":"Maxwell-Boltzmann Flux Velocity Distribution","text":"","category":"section"},{"location":"velocity_distribution.html","page":"Velocity Distributions","title":"Velocity Distributions","text":"MaxwellBoltzmannFluxVelocityDistribution","category":"page"},{"location":"velocity_distribution.html#ExosphereSimulations.MaxwellBoltzmannFluxVelocityDistribution","page":"Velocity Distributions","title":"ExosphereSimulations.MaxwellBoltzmannFluxVelocityDistribution","text":"MaxwellBoltzmannFluxVelocityDistribution{T<:Real}(itp::Interpolations.Extrapolation, amu::T)\nMaxwellBoltzmannFluxVelocityDistribution(amu::Real; N=10_000, atol=1e-1)\n\nCustom struct used to draw three-dimensional velocity vectors from a Maxwell-Boltzmann flux velocity distribution. Holds an interpolation object itp with precomputed values of the distribution, and the atomic weight amu of the respective particle for which the velocity is drawn.\n\nThe recommended use is to create the struct using the outer constructor, which creates the interpolation object. Afterwards, the struct can be used directly to sample the distribution requiring the temperature as its only input.\n\njulia> mbf = MaxwellBoltzmannFluxVelocityDistribution(4.0026);\n\njulia> mbf(250)\n3-element Vector{Float64}:\n -102.65571182106781\n  892.2770113419351\n  683.0078350151742\n\n\n\n\n\n","category":"type"},{"location":"solar_angle.html#Solar-Angle","page":"Solar Angle","title":"Solar Angle","text":"","category":"section"},{"location":"solar_angle.html","page":"Solar Angle","title":"Solar Angle","text":"solar_angle\r\nsolar_angle_deg","category":"page"},{"location":"solar_angle.html#ExosphereSimulations.solar_angle","page":"Solar Angle","title":"ExosphereSimulations.solar_angle","text":"solar_angle(lng::Real, lat::Real) -> Float64\nsolar_angle(grid::SGrid2D) -> Vector{Float64}\n\nCalculate the solar incidence angle based in selenocentric coordinates given as lng and lat in radians.\n\n\n\n\n\n","category":"function"},{"location":"solar_angle.html#ExosphereSimulations.solar_angle_deg","page":"Solar Angle","title":"ExosphereSimulations.solar_angle_deg","text":"solar_angle_deg(lng::Real, lat::Real) -> Float64\nsolar_angle_deg(grid::SGrid2D) -> Vector{Float64}\n\nSpecific version of solar_angle(lng, lat) for both the input and output angles given and returned in degree.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/example.html#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"LunarSurfaceDensity/example.html","page":"Example","title":"Example","text":"using Distributed   # enable parallelized computing\naddprocs(4)         # enable 4 workers to split the Monte-Carlo simulation onto\n\nusing DelimitedFiles    # for writing of results to disk\n\n@everywhere include(joinpath(\"..\",\"src\",\"ExosphereSimulations.jl\")) # load local package file\n@everywhere using .ExosphereSimulations                             # enable ExosphereSimulations\n\n# defines a grid with 32400 equally sized elements on half a sphere with radis `MOON_RADIUS`\ngrid = FSpiralHalfSGrid(MOON_RADIUS, 32400)\n\n# defines the physical input parameters for the helium simulation\nphysics = LSDPhysics(\n    4.0026,                 # atomic mass unit\n    1.5e6,                  # global source rate [cm-2 s-1]\n    8.0e6,                  # Sun-side source rate [cm-2 s-1]\n    5.25e-8,                # photo-destruction rate [s-1]\n    0.0,                    # heat of adsorption [J mol-1]\n    0.0,                    # ion recycling fraction [-]\n    :MaxwellBoltzmannFlux   # velocity distribution\n)\n\n# defines the solver options\nopt = LSDOptions(;  # uses default values\n    N=1000,         # adjusts the number Monte-Carlo steps\n)\n\n# defines the problem struct to pass to the solver function\nprob = LSDProblem(grid, physics, opt)\n\n# solve the problem\nsol = solve(prob)\n\n# save surface number densities n0 on the numerical grid, and on a structured grid.\nsavesol(joinpath(@__DIR__, \"csv\", \"He_n0\"), sol)\ngridsavesol(joinpath(@__DIR__, \"csv\", \"He_n0grid\"), sol, collect(range(-pi, pi, length=362))[2:end-1], collect(range(0, pi/2, length=182))[2:end-1])","category":"page"},{"location":"ballistic_2d.html#Ballistic-Flight-2D","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The Ballistic Flight - 2D function library offers algorithms to calculate the orbit parameters of a particle inside of a surface-bounded exosphere, which is solely affected by gravity. An exception are the coriolis forces, which are applied both before and after the trajectory calculations.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The main functionality of this library is to offer the user a way to calculate the landing  coordinates of a particle after completing a ballistic flight, which is usually defined  through a launch longitude and latitude, as well as a launch velocity vector.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Physical-Background-and-Implementation","page":"Ballistic Flight - 2D","title":"Physical Background & Implementation","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The intended use features the custom struct BallisticTrajectory2D, which is usually created based on the body's radius R, its mass m, the launch coordinates launch_coords as a Tuple{Float64, Float64} holding the SSE longitude and SSE latitude in radians, as well as the launch velocity vector v.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"bt = BallisticTrajectory2D(R, m, launch_coords, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Alternatively, a specialized constructor method can be used, which is numerically optimized to incorporate the constants for the radius and mass. A ballistic trajectory of a particle in the lunar exosphere is based on MOON_RADIUS, and MOON_MASS.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"bt_moon = BallisticTrajectory2DMoon(launch_coords, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"note: Performance\nWhile BallisticTrajectory2D(MOON_RADIUS, MOON_MASS, launch_coords, v) == BallisticTrajectory2DMoon(launch_coords, v) a benchmark performance test using the BenchmarkTools package indicates that the  specialized function runs roughly 1.5 times quicker.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Should the coriolis effect be included in the calculations, another specialized constructor can be used, which further requires input of the length of a day for the respective rotating body day in seconds.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"btc = BallisticTrajectory2DCoriolis(R, m, day, launch_coords, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Similarly, a body-specific constructor also exists.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"btc_moon = BallisticTrajectory2DCoriolisMoon(launch_coords, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"These constructors combine the implemented functions in a numerically efficient way, though all functions and calculations can also be called and performed separately. The main workflow includes calculations of:","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"escape velocity of the respective body vesc – escape_velocity\nsemi-major axis or the elliptical trajectory a – semi_major_axis\neccentricity of the elliptical trajectory e – eccentricity\ntrue anomaly at launch theta0 – true_anomaly\ntime of flight t – time_flight\nground flight distance d – ground_distance\nlanding coordinates in SSE coordinate system land_coords – landing_coords","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"note: Velocity Vector Format\nAll subsequent functions assume the following format for the velocity vector v:v[1]: positive longitudinal direction\nv[2]: positive latitudinal direction (pointing towards the north-pole)\nv[3]: normal & pointing away from the surface (in radial direction)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Escape-Velocity-[escape_velocity](@ref)","page":"Ballistic Flight - 2D","title":"Escape Velocity > escape_velocity","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"vesc = escape_velocity(R, m)\r\nvesc = escape_velocity(MOON_RADIUS, MOON_MASS) # vesc == MOON_vesc","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The escape velocity can be calculated using the body's radius R and its mass m:","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"v_esc = sqrtfrac2 G mR","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with the gravitational constant G, which is implemented in the package as the constant GRAVITATIONAL_CONSTANT.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Semi-Major-Axis-[semi_major_axis](@ref)","page":"Ballistic Flight - 2D","title":"Semi-Major Axis > semi_major_axis","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"a = semi_major_axis(R, f2)\r\na = semi_major_axis(R, m, v) # calculates f2 = fvesc2(R, m, v)\r\na = semi_major_axis_moon(f2) # a == semi_major_axis(MOON_RADIUS, f2)\r\na = semi_major_axis_moon(v)  # a == semi_major_axis(MOON_RADIUS, MOON_MASS, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The semi-major axis of the elliptical trajectory is calculated using the body's radius R, which is equal to the radius of the elliptical orbit at launch from the surface, as well as the auxiliary variable f_2. [Schorghofer2021]","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"a = fracR2 cdot left(1 - f_2 right)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"f_2 = left( fracvecvv_esc right)^2","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The squared fraction of the escape velocity can be access through the fvesc2 function.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"f2 = fvesc2(vesc, v)\r\nf2 = fvesc2(R, m, v)    # calculates vesc = escape_velocity(R, m)\r\nf2 = fvesc2_moon(v)     # vesc = MOON_vesc","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Eccentricity-[eccentricity](@ref)","page":"Ballistic Flight - 2D","title":"Eccentricity > eccentricity","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"e = eccentricity(f2, alpha)\r\ne = eccentricity(f2, v)     # calculates alpha = zenith_angle(v)\r\ne = eccentricity(R, m, v)   # calculates f2 = fvesc2(R, m, v) & alpha = zenith_anlge(v)\r\ne = eccentricity_moon(v)    # e == eccentricity(MOON_RADIUS, MOON_MASS, v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"One of the most important properties of a elliptical trajectory is the  eccentricity, which is calculated based on the squared fraction of the escape velocity f_2 and the zenith angle alpha. [Schorghofer2021]","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"e = sqrt1 - 4 f_2 cdot (1 - f_2) cdot sin^2 alpha) ","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"alpha = tan^-1 left( fracsqrtv_1^2 + v_2^2v_3 right)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The zenith angle can be access through the zenith_angle function:","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"alpha = zenith_angle(v)\r\nalpha = zenith_angle(traj)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#True-Anomaly-[true_anomaly](@ref)","page":"Ballistic Flight - 2D","title":"True Anomaly > true_anomaly","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"theta  = true_anomaly(r, a, e)\r\ntheta0 = true_anomaly_0_moon(a, e) # theta0 == true_anomaly(MOON_RADIUS, a, e)\r\ntheta0 = true_anomaly_0_moon(v)    # calculates a = semi_major_axis(v) & e = eccentricity(v)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The true anomaly is the angular parameter which describes the position of a body moving along the elliptical orbit. While its  time-dependent calculation is numerically expensive to find for all non-circular orbits, its value at a given radial position r can be analytically calculated based on the semi-major  axis a and the eccentricity e of the elliptical orbit. [Walter2018]","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"theta = cos^-1 left( frac1e cdot left( fracar cdot (1 - e^2) - 1right) right)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"which follows from the definitions of the radial position r","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"r = fracp1 + e cdot cos theta","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"and the semi-latus rectum p","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"p = a cdot (1 - e^2)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"note: True Anomaly at Launch Position\nThis function is usually used to calculate the true anomaly theta at the launch position theta_0 where the radial position of the elliptical orbit r is equal to the radius of the body from which the particle is launched R. This case can be handled with the body-specific versions of the function, e.g. true_anomaly_0_moon.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Time-of-Flight-[time_flight](@ref)","page":"Ballistic Flight - 2D","title":"Time of Flight > time_flight","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"time_flight(t0, P)\r\ntime_flight(e, theta0, P) # calculates t0 = time_theta(e, theta0, P)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The total time of flight t_f ","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"t_f = P - 2 cdot t_0","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"is equal to the total orbital period P","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"P = 2 pi cdot sqrt fraca^3m cdot G ","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"minus twice the orbit time at the true anomaly of the launch position theta_0","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"t_0 = P cdot fracM_02 pi 3mm\r\nM_0 = E_0 - e cdot sin E_0 3mm\r\nE_0 = 2 cdot tan^-1 left( sqrtfrac1-e1+e cdot tan left( fractheta_02 right) right)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with the mean anomaly M_0, and  eccentric anomaly E_0 at the launch position theta_0, which is reached at the orbit time t_0. [Walter2018]","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"All intermediate steps and variables can also be calculated using the functions orbit_period, mean_anomaly, eccentric_anomaly, as well as the different time calculation functions time_theta, time_E, and time_M.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"P = orbit_period(a)\r\nP = orbit_period(v) # calculates a = semi_major_axis(v)\r\n\r\n# calculates anomalies at launch\r\ntheta0 = true_anomaly(R, a, e)\r\nE0     = eccentric_anomaly(e, theta0)\r\nM0     = mean_anomaly(e, E0)\r\n\r\n# all equal, calculates time at launch for different input arguments\r\nt0 = time_theta(e, theta0, P)\r\nt0 = time_E(e, E0, P)\r\nt0 = time_M(M0, P)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Ground-Flight-Distance-[ground_distance](@ref)","page":"Ballistic Flight - 2D","title":"Ground Flight Distance > ground_distance","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"ground_distance(R, dtheta)\r\nground_distance(R, a, e)     # calculates dtheta based on a and e\r\nground_distance_moon(dtheta) # R = MOON_RADIUS\r\nground_distance_moon(a, e)   # R = MOON_RADIUS","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The projected ground flight distance is equal to the body's radius R times the covered flight angle, which is equal to the passed true anomaly from launch to landing Delta theta.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"d = Delta theta cdot R","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Due to the symmetry of the ballistic flight problem, it follows","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Delta theta = 2 pi - 2 theta_0","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with the true anomaly at the launch position theta_0, see true_anomaly.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Landing-Coordinates-[landing_coords](@ref)","page":"Ballistic Flight - 2D","title":"Landing Coordinates > landing_coords","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"landing_coords(R, d, coords, v)\r\nlanding_coords(R, a, e, coords, v) # calculates d = ground_distance(R, a, e)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"Finding the landing SSE coordinates (theta_1 phi_1) based on the launch coordinates (theta_0 phi_0) as well as the body's radius R, which is equal to the radial position at launch, the ground distance traveled d, and the launch velocity vector vecv. [Schorghofer2021]","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"cos varphi = fracv_2sqrtv_1^2 +  v_2^2 3mm\r\nsin phi_1 = sin left( fracdR right) cdot cos phi_0 cdot cos varphi + cos left( fracdR right) cdot sin phi_0 3mm\r\ncos Delta theta = cos left( fracdR right) cdot cos phi_0 - sin left( fracdR right) cdot sin phi_0 cdot cos varphi cdot cos^-1 phi_1 3mm\r\ntheta_1 = theta_0 + textsign left( v_1 right) cdot Delta theta ","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"with the azimuth angle varphi, which can be computed via azimuth_angle. Note that due to round-off issues, cos^-1 Delta theta might be numerically unstable.  The package uses its custom utility function limit_acos.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"note: Variable Symbol\nNote that both the true anomaly AND the SSE longitude share the symbol theta. While the index _0 always indicates the launch position, the true anomaly theta_0 gives the angular position with respect to the elliptical orbit, while the SSE longitude theta_0 gives the angular position with respect to the body's reference system.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#Calculation-of-the-Photo-Time-[photo_time](@ref)","page":"Ballistic Flight - 2D","title":"Calculation of the Photo Time > photo_time","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"photo_time(traj::BallisticTrajectory2D; N=5)","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The calculation of the photo-time, namely the time a particle spends in direct line of  sight of the Sun and is, thus, susceptible to photo-destruction, is based on a bi-section method to find the point of the particle's orbit, where it emerges from the shadow. The general approach differentiates between four different cases, for which the figure below shows a two-dimensional sketch  of the procedure:","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"both the launch and the landing position are on the day-side (a),\nboth the launch and the landing position are on the night-side (b),\nthe launch position is on the day-side, the landing position is on the night-side (c), and\nthe launch position is on the night-side, the landing position is on the day-side (d).","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"(Image: )","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"All four sub-figures show the first four steps of the bi-section method, which is iteratively closing in on the transition true anomaly theta_s, where the shadow ends. It starts of with the launch angular position theta_0 and the landing angular position theta_1. For the first case, shown in (a), it is assumed that the entire particles path is in direct sunlight, so no bi-section is necessary. For all the other three cases, the midway angular position is calculated and determined, whether it is Sun-lit. Based on this information, the new lower and upper limit, theta_lower and theta_upper, is set  and the next step of the bi-section method is conducted:","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"theta_new = fractheta_lower + theta_upper2","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"While this procedure is fairly straightforward for the third and fourth case, (c) and (d), if both launch and landing positions are already in the shadowed region two transitions occur, thus two bi-section methods have to be used to find theta_S1 and theta_S2. One special case is where the entire ellipse is in the shadows, so not even one intersection point can be found. The implemented code checks whether the apogee is in sun-lit, and if not the entire path is assumed to be shadowed.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"The code only requires the particles trajectory traj and, optionally, the number of bi-section steps N, which defaults to N=5. While more steps lead to more accurate time calculations, they also greatly increase the numerical effort.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"note: Approximations\nNote that there are certain ellipses for the first case, where the particle's path can  intersect the shadowed region, though it is assumed that these paths never occur. This approximation becomes more and more valid for heavier particles, which cannot perform global jumps anymore.Additionally, the approximation for the entirely shadowed case can have some exemptions where the apogee is shadowed, but still some part of the ellipse is sun-lit. This case  is excluded for numerical performance reasons.","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"","category":"page"},{"location":"ballistic_2d.html#API","page":"Ballistic Flight - 2D","title":"API","text":"","category":"section"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"BallisticTrajectory2D\r\nadd_coriolis_effect\r\nazimuth_angle\r\neccentric_anomaly\r\neccentricity\r\nescape_velocity\r\nfvesc2\r\nground_distance\r\nlanding_coords\r\nmean_anomaly\r\norbit_period\r\nphoto_time\r\nsemi_latus_rectum\r\nsemi_major_axis\r\ntime_E\r\ntime_flight\r\ntime_M\r\ntime_theta\r\ntrue_anomaly\r\nzenith_angle","category":"page"},{"location":"ballistic_2d.html#ExosphereSimulations.BallisticTrajectory2D","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.BallisticTrajectory2D","text":"BallisticTrajectory2D(\n    launch_coords   ::  Tuple{Float64, Float64},\n    land_coords     ::  Tuple{Float64, Float64},\n    v               ::  Vector{Float64},\n    a               ::  Float64,\n    e               ::  Float64,\n    theta0          ::  Float64,\n    t               ::  Float64,\n    P               ::  Float64,\n    d               ::  Float64,\n    R               ::  Float64)\nBallisticTrajectory2D(R::Real, m::Real, launch_coords::Tuple, v::AbstractVector) -> BallisticTrajectory2D\nBallisticTrajectory2DCoriolis(R::Real, m::Real, day::Real, launch_coords::Tuple, v::AbstractVector) -> BallisticTrajectory2D\n\nCustom struct holding all relevant data about a ballistic trajectory. Note that the direct use of the main constructor method is not advised; using the outer constructor methods  calculates all missing data from the input variables.\n\nFields\n\nVariable Description Unit\nlaunch_coords launch SSE coordinates ([rad], [rad])\nland_coords landing SSE coordinates ([rad], [rad])\nv launch velocity vector [m s-1]\na semi-major axis [m]\ne eccentricity [-]\ntheta0 true anomaly at launch [rad]\nt time of flight [s]\nP period of elliptical orbit [s]\nd ground flight distance [m]\nR radius at launch [m]\n\nSpecialized Constructors\n\nBallisticTrajectory2DMoon(launch_coords::Tuple, v::AbstractVector)\nBallisticTrajectory2DCoriolisMoon(launch_coords::Tuple, v::AbstractVector)\n\nNote that the constructors generally perform better than their equivalent BallisticTrajectory2D(MOON_RADIUS, MOON_MASS, launch_coords, v) and  BallisticTrajectory2DCoriolis(MOON_RADIUS, MOON_MASS, MOON_DAY, land_coords, v).\n\n\n\n\n\n","category":"type"},{"location":"ballistic_2d.html#ExosphereSimulations.add_coriolis_effect","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.add_coriolis_effect","text":"add_coriolis_effect(R::Real, day::Real, coords::Tuple, v::AbstractVector) -> Vector{Float64}\nadd_coriolis_effect(day::Real, coords::Tuple) -> Float64\n\nAdds the effects of the coriolis effect based on the body's radius R, its length of day  day, and the position coordinates coords, either onto the given velocity vector v, or onto the current longitudinal position. The choice depends on the input variables.\n\nSpecialized Function Calls\n\nadd_coriolis_effect_moon(coords::Tuple, v::AbstractVector)\nadd_coriolis_effect_moon(coords::Tuple)\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.azimuth_angle","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.azimuth_angle","text":"azimuth_angle(v::AbstractVector) -> Float64\ncos_azimuth_angle(v::AbstractVector) -> Float64\n\nCalculates the azimuth angle of the launch velocity vector v, or similarly its cosine.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.eccentric_anomaly","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.eccentric_anomaly","text":"eccentric_anomaly(e::Real, theta::Real) -> Float64\n\nCalculates the eccentric anomaly, given the orbit's eccentricity e and the true anomaly theta.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.eccentricity","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.eccentricity","text":"eccentricity(f2::Real, alpha::Real) -> Float64\neccentricity(f2::Real, v::AbstractVector) -> Float64 \neccentricity(R::Real, m::Real, v::AbstractVector) -> Float64\n\nCalculates the eccentricity of an elliptical trajetory based on the squared escape velocity fraction f2, and the zenith launch angle alpha. Can also be called using the launch velocity vector v directly, or using the radius R and mass m of the respective body from which the particle is launched.\n\nSpecialized Function Calls\n\neccentricity_moon(v::AbstractVector)\n\nNotes\n\ne = 0: circular orbit\n0 < e < 1: elliptical orbit\ne = 1: parabolic trjectory\ne > 1: hyperbolic trajectory\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.escape_velocity","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.escape_velocity","text":"escape_velocity(R::Real, m::Real) -> Float64\n\nCalculates the magnitude of the escape velocity for a body of radius R and mass m.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.fvesc2","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.fvesc2","text":"fvesc2(v_esc::Real, v::AbstractVector) -> Float64\nfvesc2(R::Real, m::Real, v::AbstractVector) -> Float64\n\nCalculates the squared fraction of the velocity vector v with respect to the escape velocity v_esc. Can also be called based on the respective body's radius R and mass m.\n\nSpecialized Function Calls\n\nfvesc2_moon(v::AbstractVector)\n\nNotes\n\n>= 1: no orbit, particle escape gravitational field\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.ground_distance","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.ground_distance","text":"ground_distance(R::Real, dTheta::Real) -> Float64\nground_distance(R::Real, a::Real, e::Real) -> Float64\n\nCalculates the ground flight distance covered by an angle dtheta of an elliptical orbit,  which intersects with a body of radius R. Can be called using the orbit's semi-major axis a, and its eccentricity e.\n\nSpecialized Function Calls\n\nground_distance_moon(dtheta::Real)\nground_distance_moon(a::Real, e::Real)\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.landing_coords","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.landing_coords","text":"landing_coords(R::Real, d::Real, coords::Tuple, v::AbstractVector) -> Tuple{Float64, Float64}\nlanding_coords(R::Real, a::Real, e::Real, coords::Tuple, v::AbstractVector) -> Tuple{Float64, Float64}\n\nCalculates the landing coordinates in SSE degree. Input variables are:\n\nVariable Description Unit\nR body's radius and radial launch distance [m]\nd ground flight distance [m]\na semi-major axis of elliptical trajectory [m]\ne eccentricity of elliptical trajectors [-]\ncoords launch coordinates ([rad], [rad])\nv launch velocity vector [m s-1]\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.mean_anomaly","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.mean_anomaly","text":"mean_anomaly(e::Real, E::Real) -> Float64\n\nCalculates the mean anomaly, given the orbit's eccentricity e and the eccentric anomaly E.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.orbit_period","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.orbit_period","text":"orbit_period(a::Real, m::Real) -> Float64\n\nCalculates the period of an elliptical orbit, based on the semi-major axis a, and the body's mass u.\n\nSpecialized Function Calls\n\norbit_period_moon(a::Real)\norbit_period_moon(v::AbstractVector)\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.photo_time","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.photo_time","text":"photo_time(traj::BallisticTrajectory2D; N=5) -> Float64\n\nCalculates the time a particle spends in direct line of sight of the Sun, during its  trajectory traj. The optional input N controls the number of iteration steps during  the calculations.\n\nThe algorithm differntiates between four different szenarios:\n\nlaunch and landing position are on the day-side,\nlaunch and landing position are on the night-side,\nlaunch position is on the day-side, landing position is on the night-side, and\nlaunch position is on the night-side, landing position is on the day-side.\n\nEach one of these szenarios is handled differently, with increasing numerical effort. Generally, the last three szenarios' calculation is based upon a bi-section method to find the true anomaly at which the particles enters the shadow.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.semi_latus_rectum","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.semi_latus_rectum","text":"semi_latus_rectum(a::Real, e::Real) -> Float64\n\nCalculates the semi-latus-rectum of the elliptical trajetory defined through the semi-major axis a and the eccentricity e.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.semi_major_axis","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.semi_major_axis","text":"semi_major_axis(R::Real, f2::Real) -> Float64\nsemi_major_axis(R::Real, m::Real, v::AbstractVector) -> Float64\n\nCalculates the semi-major axis of an elliptical orbit, which starts on the surface of a body with radius R, based on the trajectory's squared escape velocity fraction f2. Can also be called using the mass of the body m and the launch velocity vector v.\n\nSpecialized Function Calls\n\nsemi_major_axis_moon(f2::Real)\nsemi_major_axis_moon(v::AbstractVector)\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.time_E","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.time_E","text":"time_E(e::Real, E::Real, P::Real) -> Float64\n\nCalculates the time at the position of an orbit defined through the eccentric anomaly E, as  well as the orbit's eccentricity e, and the orbital period P.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.time_flight","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.time_flight","text":"time_flight(t0::Real, P::Real) -> Float64\ntime_flight(e::Real, theta0::Real, P::Real) -> Float64\n\nCalculates the time of flight of a particle on an elliptical trajectory with eccentricity e, symmetrically intersecting a body at the true anomaly theta0. Additionally requires the orbital period P.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.time_M","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.time_M","text":"time_M(M::Real, P::Real) -> Float64\n\nCalculates the time at the position of an orbit defined through the mean anomaly M, as  well as the orbital period P.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.time_theta","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.time_theta","text":"time_theta(e::Real, theta::Real, P::Real) -> Float64\n\nCalculates the time at the position of an orbit defined through the true anomaly theta, as  well as the orbit's eccentricity e, and the orbital period P.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.true_anomaly","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.true_anomaly","text":"true_anomaly(r::Real, a::Real, e::Real) -> Float64\n\nCalculates the true anomaly at the radial position r based on the semi-major axis a, and the eccentricity of the orbit e. \n\nSpecialized Function Calls\n\ntrue_anomaly_0_moon(a::Real, e::Real)\ntrue_anomaly_0_moon(v::AbstractVector)\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html#ExosphereSimulations.zenith_angle","page":"Ballistic Flight - 2D","title":"ExosphereSimulations.zenith_angle","text":"zenith_angle(v::AbstractVector) -> Float64\nzenith_angle(traj::BallisticTrajectory2D) -> Float64\n\nCalculates the zenith launch angle based on the launch velocity vector v.\n\n\n\n\n\n","category":"function"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"[Schorghofer2021]: N. Schorghofer, 2021 \"Planetary-Code-Collection: Thermal and Ice Evolution Models for Planetary Surfaces\" DOI: 10.5281/zenodo.594268, Last Accessed: 2022/04/01","category":"page"},{"location":"ballistic_2d.html","page":"Ballistic Flight - 2D","title":"Ballistic Flight - 2D","text":"[Walter2018]: U. Walter, 2018 \"Astronautics\", 3rd Edition, DOI: 10.1007/978-3-319-74373-8 ","category":"page"},{"location":"utils.html#Utility-Functions","page":"Utility","title":"Utility Functions","text":"","category":"section"},{"location":"utils.html","page":"Utility","title":"Utility","text":"Coordinate transformation implemented in spherical2cartesian:","category":"page"},{"location":"utils.html","page":"Utility","title":"Utility","text":"(R theta phi )^T rightarrow (x y z)^T = Rcdot (cos theta cos phi sin theta cos phi sin phi)^T","category":"page"},{"location":"utils.html#API","page":"Utility","title":"API","text":"","category":"section"},{"location":"utils.html","page":"Utility","title":"Utility","text":"limit_acos\r\nmodidx\r\nspherical2cartesian","category":"page"},{"location":"utils.html#ExosphereSimulations.limit_acos","page":"Utility","title":"ExosphereSimulations.limit_acos","text":"limit_acos(x::Real) -> Float64\n\nCustom acos function to handle illegal inputs of x. Those inputs are all limited to return either acos(1) = 0.0 or acos(-1) = pi, depending on the sign of the input.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#ExosphereSimulations.modidx","page":"Utility","title":"ExosphereSimulations.modidx","text":"modidx(n::Int64, N::Int64) -> Int64\n\nCustom mod function to work for indeces starting at 1.\n\n\n\n\n\n","category":"function"},{"location":"utils.html#ExosphereSimulations.spherical2cartesian","page":"Utility","title":"ExosphereSimulations.spherical2cartesian","text":"spherical2cartesian(R::Real, theta::Real, phi::Real) -> Vector{Float64}\nspherical2cartesian(R::Real, coords::Tuple) -> Vector{Float64}\nspherical2cartesian(coords::Tuple) -> Vector{Float64}\n\nConverts spherical coordinates (R, θ, ϕ) into cartesian coordinates (x, y, z).\n\n\n\n\n\n","category":"function"},{"location":"spherical_grids.html#Spherical-Grids","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"For many functionalities of the ExosphereSimulations package, an underlying numerical grid is necessary. Such a grid discretizes the spherical body which hosts the surface-bounded exosphere into N grid elements, which are then used for all calculations.","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"The current hierarchically structure of numerical spherical grids features the following grids:","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"SGrid\n├── SGrid2D\n│   ├── StructuredFullSGrid\n│   ├── StructuredHalfSGrid\n│   ├── FSpiralFullSGrid\n│   ├── FSpiralHalfSGrid\n│   └── HEALPixFullSGrid\n└── SGrid3D","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"page"},{"location":"spherical_grids.html#Physical-Background-and-Implementation","page":"Spherical Grids","title":"Physical Background & Implementation","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"The main task of the grid creation is the construction of the grid points on the surface of the sphere. These points can be expressed in spherical coordinates (R theta phi), which are the radial distance from the sphere's center, and the two angular variables, the longitude and the latitude. For the two-dimensional grids, only the two angular positions are necessary. In the code implementation, all grid types have fields for the radius at grid.R, as well as the longitudes grid.lngs and the latitudes grid.lats.","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"page"},{"location":"spherical_grids.html#Two-Dimensional-Spherical-Grids","page":"Spherical Grids","title":"Two-Dimensional Spherical Grids","text":"","category":"section"},{"location":"spherical_grids.html#Structured-Grid-[StructuredFullSGrid](@ref)-and-[StructuredHalfSGrid](@ref)","page":"Spherical Grids","title":"Structured Grid > StructuredFullSGrid & StructuredHalfSGrid","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"grid = StructuredFullSGrid(R, N_lng, N_lat)\ngrid = StructuredHalfSGrid(R, N_lng, N_lat)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"These grids construct a structured numerical grid, either on the entire sphere (full), or on just the upper hemisphere (half), thus assuming equatorial symmetry. Both constructors require three inputs, the radius R (R), as well as the number of  structured elements in longitudinal direction N_lng (N_lng) as well as in latitudinal direction N_lat (N_lat). Thus, the total number of grid elements is equal to","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"N = N_lng cdot N_lat","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Due to the structure of the grid, the creation of the grid points is fairly straightforward:","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"theta_i = pi cdot left( frac2i-1N_lng - 1 right) qquad phi_j = fracpi2 cdot left( frac2j-1N_lat - 1 right)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"for 1 leq i leq N_lng longitudes theta_i, and 1 leq j leq N_lat latitudes phi_j.","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"note: Vectorization\nThe package ExosphereSimulations works exclusively with vectorized quantities for the grid elements. Thus, the created lngs (see theta_i) and lats (see phi_j) have to be properly repeated, using the repeat command in Julia:lngs = repeat(lngs, inner=N_lat)\nlats = repeat(lats, outer=N_lng)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Another field of any grid is containing information about the surface area of each grid element, here saved as a vector of size (N,) in grid.areas. For every grid element with coordinates (theta phi) the angular element sizes","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Deltatheta = frac2piN_lng qquad Deltaphi = fracpiN_lat","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"can be used to calculate the respective size A","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"A = int_theta^theta+Deltatheta int_phi^phi+Deltaphi R^2 cos left( theta right) dtheta dphi 3mm\nRightarrow A = Deltatheta cdot R^2 cdot left( sin(phi + Deltaphi) - sin(phi) right)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"(Image: quadgrid)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"page"},{"location":"spherical_grids.html#Fibonnaci-Based-Spiral-Grid-[FSpiralFullSGrid](@ref)-and-[FSpiralHalfSGrid](@ref)","page":"Spherical Grids","title":"Fibonnaci-Based Spiral Grid > FSpiralFullSGrid & FSpiralHalfSGrid","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"grid = FSpiralFullSGrid(R, N)\ngrid = FSpiralHalfSGrid(R, N)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Points on a spherical surface mathcalS^2 = left x in mathcalR^3 x = 1 right  which form a path in form of a spiral can be expressed in spherical coordinates of the form","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"theta=Lphi qquad 0 leq phi leq pi","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"for a unit sphere (R=1), with the polar angle phi and the azimuth theta, or the  latitude and longitude, respectively. The factor L gives the slope of the spiral. One  generation method of N (N) points defines the two spherical coordinates as","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"L = sqrtNpi qquad h_k = 1 -frac2k-1N qquad phi_k = cos^-1(h_k) qquad theta_k = Lphi_k qquad k = 1dots N","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"where the slope L is chosen in order to equalize the distance between adjacent points on the same level of the spiral and points on adjacent levels which differ by 2pi in theta. [Hardin2016]","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"A specialized method of creating a set of spiral points implements the Fibonacci sequence","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"left F_k right = left1 1 2 3 5 8 13 dots right","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"and the golden ratio  varphi = frac1 + sqrt52 The general algorithm defines a lattice of points on  the square left 01 right)^2, which is subsequently mapped to a unit sphere using  the Lambert cylindrical equal area projection Lambda:","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Lambda(xy) = left( sqrt1-(2y-1)^2cdotcosleft(2pi xright) sqrt1-(2y-1)^2cdotsinleft(2pi xright) 2y-1 right)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"in Cartesian coordinates, and","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"Lambda(xy) = left(cos^-1(2y-1) 2pi x right) = left( phi theta right)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"in spherical coordinates. The points (x y) on the square left 01 right)^2 are created through","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"(tilde x y)_F_k = left( fraciF_k-1F_k  fraciF_k right) qquad 0 leq i leq F_k","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"where x = tilde x - lfloor tilde x rfloor as just the fractional part of tilde x. [Hardin2016]","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"While this implementation can only be applied for N+1 elements, where N in  F_k , a more general approach involves the golden ratio varphi. Based on Binet's formula, the calculation of (x y) can be changed to","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"(tilde x y)_N = left( fracivarphi fraciN right) qquad 0 leq i leq N","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"(Image: fspiralgrid)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"note: $N+1 \\rightarrow N$\nSince the implementation always indexes i from 0 to N, a total of N+1 points are created. In order to equalize the users input in the constructor methods with the actually created number of grid points, the code iterates from 0:N-1.","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"page"},{"location":"spherical_grids.html#HEALPix-Grid-[HEALPixFullSGrid](@ref)","page":"Spherical Grids","title":"HEALPix Grid > HEALPixFullSGrid","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"grid = HEALPixFullSGrid(R, k)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"HEALPix, Hierarchical Equal Area iso-Latitude Pixelization, was developed by NASA to have  three distinct properties, which are that","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"the sphere is hierarchically tessellated into curvilinear quadrilaterals,\nthe pixelization is an equal area partition of mathcalS^2, and\nthe point sets are distributed along fixed lines of latitude.","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"The generation of such points firstly requires a division of the sphere into twelve equal area, four sided pixels defined by:","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"cosphifrac23 qquad theta=mfracpi2 qquad m = 0123 3mm\ncosphi = frac-2-4m3 + frac8theta3pi qquad fracmpi2 leq theta leq frac(m+1)pi2 qquad m=0123 3mm\ncosphi=frac2-4m3-frac8theta3pi qquad frac-(m+1)pi2 leq theta leq frac-mpi2 qquad m=0123","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"These pixels can be further partitioned into a k times k grid of sub-pixels of the same  shape and area. The points of the set are located in the centers of each pixel. The subdivision  leads to k iso-latitudinal rings at the polar region cosphi23, with","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"cosphi_i=1-fraci^23k^2 qquad theta_j=fracpi2i left( j - frac12 right)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"thus, every i-th ring has 4i equally spaced points. Closer to the equatorial region,  2k-1 iso-latitudinal rings with 4k points each emerge. These points are indexed by  k leq i leq 2k and 1 leq j leq 4k:","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"cosphi_i = frac43 - frac2i3k qquad theta_j = fracpi2k left( j - fracs2 right) qquad s = (i-k+1) mod 2","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"The last index, s, describes the phase shift between the rings. Finally, this configuration  produces a set of N=12k^2 points. [Hardin2016]","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"(Image: healpixgrid)","category":"page"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"","category":"page"},{"location":"spherical_grids.html#API","page":"Spherical Grids","title":"API","text":"","category":"section"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"StructuredFullSGrid\nStructuredHalfSGrid\nFSpiralFullSGrid\nFSpiralHalfSGrid\nHEALPixFullSGrid\n\nareas\ncoord2idx","category":"page"},{"location":"spherical_grids.html#ExosphereSimulations.StructuredFullSGrid","page":"Spherical Grids","title":"ExosphereSimulations.StructuredFullSGrid","text":"StructuredFullSGrid(R::Real, N_lng::Int64, N_lat::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, areas::Vector{Float64})\nStructuredFullSGrid(R::Real, N_lng::Int64, N_lat::Int64)\n\nCreates a container object referring to a regular, cell-centered, structured  numerical grid projected onto a sphere. The number of equally sized  cells in longitudinal direction N_lng is saved alongside N_lat, which gives the number of latitudinal cells with same angular height. The resulting vectors  lngs and lats hold the respective SSE coordinates. The passed radius R is  used to compute the surface area of the grid elements, which are stored in areas.\n\nIt is not recommended to create a StructuredFullSGrid directly but use the alternative constructor, which subsequently handles the calculation of lngs, lats, and areas.\n\nSpecialized Constructors\n\nStructuredFullSGridMoon(N_lng::Int64, N_lat::Int64)\n\n\n\n\n\n","category":"type"},{"location":"spherical_grids.html#ExosphereSimulations.StructuredHalfSGrid","page":"Spherical Grids","title":"ExosphereSimulations.StructuredHalfSGrid","text":"StructuredHalfSGrid(R::Real, N_lng::Int64, N_lat::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, areas::Vector{Float64})\nStructuredHalfSGrid(R::Real, N_lng::Int64, N_lat::Int64)\n\nCreates a container object referring to a cell-centered, structured  numerical grid projected onto a hemisphere. The number of equally sized  cells in longitudinal direction N_lng is saved alongside N_lat, which gives the number of latitudinal cells with same angular height. The resulting vectors  lngs and lats hold the respective SSE coordinates. The passed radius R is  used to compute the surface area of the grid elements, which are stored in areas.\n\nIt is not recommended to create a StructuredFullSGrid directly but use the alternative constructor, which subsequently handles the calculation of lngs, lats, and areas.\n\nSpecialized Constructors\n\nStructuredHalfSGridMoon(N_lng::Int64, N_lat::Int64)\n\n\n\n\n\n","category":"type"},{"location":"spherical_grids.html#ExosphereSimulations.FSpiralFullSGrid","page":"Spherical Grids","title":"ExosphereSimulations.FSpiralFullSGrid","text":"FSprialFullSGrid(R::Real, N::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)\nFSpiralFullSGrid(R::Real, N::Int64)\n\nContainer object containing a spherical grid of N tri-elements of both hemisphere  of a perfect sphere of radius R. Field lngs, and lats hold the angular SSE  coordinates of each element in a vector of size (N, ). Note that this corresponds to the cell-center and not one of the verticies. The surface area of each element area is approximated to be equal for all elements as one N-th of the entire surface area.  For numerically efficient look-ups of this grid, a KDTree in cartesian coordinates is saved in tree.\n\nIt is not advised to use the base-constructor directly, but the secondary, outer constructor, which builds all inferred field directly.\n\nSpecialized Constructors\n\nFSpiralFullSGridMoon(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"spherical_grids.html#ExosphereSimulations.FSpiralHalfSGrid","page":"Spherical Grids","title":"ExosphereSimulations.FSpiralHalfSGrid","text":"FSpiralHalfSGrid(R::Real, N::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)\nFSpiralHalfSGrid(R::Real, N::Int64)\n\nContainer object containing a spherical grid of N tri-elements of the upper hemisphere  of a perfect sphere of radius R. Field lngs, and lats hold the angular SSE  coordinates of each element in a vector of size (N, ). Note that this corresponds to the cell-center and not one of the verticies. The surface area of each element area is approximated to be equal for all elements as one N-th of the entire surface area of one hemisphere. For numerically efficient look-ups of this grid, a KDTree in cartesian coordinates is saved in tree.\n\nIt is not advised to use the base-constructor directly, but the secondary, outer constructor, which builds all inferred field directly.\n\nSpecialized Constructors\n\nFSpiralHalfSGridMoon(N::Int64)\n\n\n\n\n\n","category":"type"},{"location":"spherical_grids.html#ExosphereSimulations.HEALPixFullSGrid","page":"Spherical Grids","title":"ExosphereSimulations.HEALPixFullSGrid","text":"HEALPixFullSGrid(R::Float64, k::Int64, lngs::Vector{Float64}, lats::Vector{Float64}, area::Float64, tree::KDTree)\nHEALPixFullSGrid(R::Real, k::Int64)\n\nContainer struct describing a spherical grid of equally distributed points based on the HEALPix algorithm. It holds the radius of the sphere R, the subdivisions of the twelve main pixels k, the resulting longitudinal and latitudinal coordinates lngs and lats, the area which is associated to each grid element area, and a KDTree structure for fast lookup of the grids coordinates tree.\n\nThe total number of grid elements is mainly based on the number of sub-pixels k, which further refines the twelve main HEALPix pixels: N=12*k^2.\n\nIt is not recommended to use the constructor directly but to build the grid using the outer constructor method, which correctly builds up all field information based purely on the sphere's radius and the number of subdivisions.\n\nSpecialized Constructors\n\nHEALPixFullSGridMoon(k::Int64)\n\n\n\n\n\n","category":"type"},{"location":"spherical_grids.html#ExosphereSimulations.areas","page":"Spherical Grids","title":"ExosphereSimulations.areas","text":"areas(grid::StructuredFullSGrid) -> Vector{Float64}\nareas(grid::StructuredHalfSGrid) -> Vector{Float64}\nareas(grid::FSpiralFullSGrid) -> Vector{Float64}\nareas(grid::FSpiralHalfSGrid) -> Vector{Float64}\nareas(grid::HEALPixFullSGrid) -> Vector{Float64}\nareas(grid::HEALPixHalfSGrid) -> Vector{Float64}\n\nReturns the surface areas of each grid element as a vector in [m2].\n\n\n\n\n\n","category":"function"},{"location":"spherical_grids.html#ExosphereSimulations.coord2idx","page":"Spherical Grids","title":"ExosphereSimulations.coord2idx","text":"coord2idx(grid::StructuredFullSGrid, lng::Real, lat::Real) -> Int64\ncoord2idx(grid::StructuredHalfSGrid, lng::Real, lat::Real) -> Int64\ncoord2idx(grid::FSpiralFullSGrid, lng::Real, lat::Real) -> Int64\ncoord2idx(grid::FSpiralHalfSGrid, lng::Real, lat::Real) -> Int64\ncoord2idx(grid::HEALPixFullSGrid, lng::Real, lat::Real) -> Int64\ncoord2idx(grid::SGrid2D, coords::Tuple) -> Int64\n\nReturns the index of the grid element of grid that contains the point defined by the coordinates lng and lat.\n\n\n\n\n\n","category":"function"},{"location":"spherical_grids.html","page":"Spherical Grids","title":"Spherical Grids","text":"[Hardin2016]: Hardin et al., 2016, \"A Comparison of Popular Point Configurations on S2\", doug.hardin@vanderbilt.edu","category":"page"},{"location":"residence_time.html#Residence-Time","page":"Residence Time","title":"Residence Time","text":"","category":"section"},{"location":"residence_time.html","page":"Residence Time","title":"Residence Time","text":"residence_time","category":"page"},{"location":"residence_time.html#ExosphereSimulations.residence_time","page":"Residence Time","title":"ExosphereSimulations.residence_time","text":"residence_time(T::Real, Q::Real) -> Float64\n\nCalculates residence time of a particle inside lunar regolith based on the local surface temperature T and the heat of adsorption Q.\n\n\n\n\n\n","category":"function"},{"location":"LunarSurfaceDensity/input.html#lunar_exosphere_simulation_input","page":"Input","title":"Input","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"This page presents compiled lists of input parameters for several different constituents of the lunar exosphere, including some physical background with their respective references.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"The usage of these input parameters is directly connected to the LSDPhysics command. For each element, some examples are given, how the respective element could be implemented.  To use the command, the ExosphereSimulations.jl package has to be loaded into the REPL:","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"include(joinpath(path, to, repository, \"src\", \"ExosphereSimulations.jl\"))\nusing .ExosphereSimulations","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Atomic-Hydrogen","page":"Input","title":"Atomic Hydrogen","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"The main source of atomic hydrogen in the lunar exosphere is coming through the solar wind proton flux. Those positively charged protons neutralize upon contact with the lunar surface,  at which the fates of the H atoms branch out. A certain fraction will backscatter, a process  after which the particle did not thermally accommodated itself with the surface. With incoming  kinetic energies in the order of roughly 10 keV, all backscattered atoms will overshoot the  lunar escape velocity. The trajectory will remove the atom from the lunar exosphere.  Backscattering is assumed to happen to about 1 of the incoming protons, leaving 99 to  be implanted into the regolith as a source mechanism for hydrogen. [Crider2002]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Assuming that the lunar surface is saturated with hydrogen atoms, every incident proton of the 99 that do not backscatter either sputters, desorbs, or chemically reacts with a local atom. The fractions of each branch are:","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Reaction Incoming Flux Probability\nBackscatter H 30 times 10^6 cm^-2 s^-1 10\nSputter H 30 times 10^4 cm^-2 s^-1 001\nDesorb H 81 times 10^7 cm^-2 s^-1 210\nConvert to H_2 90 times 10^7 cm^-2 s^-1 600\nConvert to OH 30 times 10^7 cm^-2 s^-1 100\nConvert to H_2O 30 times 10^6 cm^-2 s^-1 20","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Note that the rates are based on a solar wind proton flux of 30 times 10^8  cm^-2 s^-1, and that the rates for H_2 and H_2O have been halved to  accommodate the fact that two protons are required to form that molecule. [Crider2002] [Hoffman1975]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Sputtering occurs when a incident proton initiates a collision cascade in the grain lattice,  after which a particle caught in the cascade might be released from the surface. Implanted  hydrogen atoms are preferably released as their mass is equal to that of the incident proton. The damage done to the lattice is a preferred reaction site for chemical processes, where the  implanted hydrogen can react with local oxygen to form OH, or with another hydrogen atom to  form H_2. Water can also be produced fromOHthrough further reactions with incoming protons.  These processes are also called \"chemical sputtering\" as the emission includes new molecules  from the surface. With all the derived branching fractions of the reactions described  above given in Tab. 4.3, the one remaining process, desorption, must account for the remaining protons. Once diffusion takes the particle to the surface, it desorbs with a thermal velocity  distribution. Note that these values are derived with a lot of uncertainties and are subject to improvement. [Crider2002]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"While the main loss mechanism for hydrogen is the gravitational loss, as the extremely  light particles often get launched with velocities exceeding the escape velocity of the Moon,  another loss mechanism is the photo-ionization:","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"H + nu rightarrow H^ + e","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"with rates of 073 - 172times10^-7 s^-1 for active and quiet Sun conditions,  respectively, and excess energies of 354 eV to 397 eV for the photo-reaction. [Huebner1992]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Parameter Value Unit Reference\nAtomic Mass Unit 1008 u Ptable\nSun-Side Source Rate 81times10^7 cm^-2 s^-1 [Crider2002]\nGlobal Source Rate - cm^-2 s^-1 \nPhoto-Destruction Rate 073 - 172times10^-7 s^-1 [Huebner1992]\nHeat of Adsorption - J mol^-1 \nIon Recycling Fraction -  ","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Example Setups","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"LSDPhysics(1.008, 0.0, 8.1e7, 1.72e-7, 0.0, 0.0, :MaxwellBoltzmannFlux) # minimum\nLSDPhysics(1.008, 0.0, 8.1e7, 0.73e-7, 0.0, 0.0, :Maxwell) # maximum","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Molecular-Hydrogen","page":"Input","title":"Molecular Hydrogen","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Parameter Value Unit Reference\nAtomic Mass Unit 2016 u Ptable\nSun-Side Source Rate 90times10^7 cm^-2 s^-1 [Crider2002]\nGlobal Source Rate - cm^-2 s^-1 \nPhoto-Destruction Rate 146 - 334times10^-7 s^-1 [Huebner1992]\nHeat of Adsorption - J mol^-1 \nIon Recycling Fraction -  ","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Example Setups","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"LSDPhysics(2.016, 0.0, 9.0e7, 3.34e-7, 0.0, 0.0, :MaxwellBoltzmannFlux) # minimum\nLSDPhysics(2.016, 0.0, 9.0e7, 1.46e-7, 0.0, 0.0, :Maxwell) # maximum","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Helium","page":"Input","title":"Helium","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Parameter Value Unit Reference\nAtomic Mass Unit 40026 u Ptable\nSun-Side Source Rate 29 - 37times10^6 cm^-2 s^-1 [Hurley2015]\n 80times10^6 cm^-2 s^-1 [Grava2020]\nGlobal Source Rate 15 - 20times10^6 cm^-2 s^-1 [Hurley2015] [Benna2015]\n 141 - 157times10^6 cm^-2 s^-1 [Grava2020]\nPhoto-Destruction Rate 0525 - 164times10^-7 s^-1 [Huebner1992]\nHeat of Adsorption - J mol^-1 \nIon Recycling Fraction 30 - 39  [Poppe2013]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Example Setups","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"LSDPhysics(4.0026, 1.41e6, 2.9e6, 0.525e-7, 0.0, 0.39, :MaxwellBoltzmannFlux) # minimum\nLSDPhysics(4.0026, 2.0e6, 8.0e6, 1.64e-7, 0.0, 0.3, :Maxwell) # maximum","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Methane","page":"Input","title":"Methane","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Parameter Value Unit Reference\nAtomic Mass Unit 16043 u Ptable\nSun-Side Source Rate 75times10^4 cm^-2 s^-1 [Hodges2016]\nGlobal Source Rate - cm^-2 s^-1 \nPhoto-Destruction Rate 076 - 130times10^-5 s^-1 [Huebner1992]\nHeat of Adsorption - J mol^-1 \nIon Recycling Fraction 42 - 46  [Poppe2013]","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"Example Setups","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"LSDPhysics(16.043, 0.0, 7.5e4, 0.76e-5, 0.0, 0.42, :MaxwellBoltzmannFlux) # minimum\nLSDPhysics(16.043, 0.0, 7.5e4, 1.30e-5, 0.0, 0.46, :Maxwell) # maximum","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Hydroxyl","page":"Input","title":"Hydroxyl","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Water","page":"Input","title":"Water","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Neon","page":"Input","title":"Neon","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Argon","page":"Input","title":"Argon","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Krypton","page":"Input","title":"Krypton","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"","category":"page"},{"location":"LunarSurfaceDensity/input.html#Xenon","page":"Input","title":"Xenon","text":"","category":"section"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Benna2015]: M. Benna, P. R. Mahaffy, et al., “Variability of helium, neon, and argon in the lunar exosphere as observed by the LADEE NMS instrument,” Geophysical Research Letters, vol. 42, pp. 3723–3729, May 2015.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Crider2002]: D. Crider and R. Vondrak, “Hydrogen migration to the lunar poles by solar wind bombardment of the moon”, Advances in Space Research, vol. 30, no. 8, pp. 1869–1874, 2002.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Grava2020]: C. Grava, D. M. Hurley, et al., “LRO/LAMP observations of the lunar helium exosphere: constraints on thermal accommodation and outgassing rate,” Monthly Notices of the Royal Astronomical Society, ol. 501, pp. 4438–4451, Dec. 2020.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Hodges2016]: R. R. Hodges, “Methane in the lunar exosphere: Implications for solar wind carbon escape,” Geophysical Research Letters, vol. 43, pp. 6742–6748, July 2016.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Hoffman1975]: J. Hoffman and R. Hodges, “Molecular gas species in the lunar atmosphere,” The Moon, vol. 14, no. 1, pp. 159–167, 1975.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Huebner1992]: W. F. Huebner et al., \"Solar Photo Rates for Planetary Atmospheres and Atmospheric Pollutants.\", Springer Netherlands, 1992.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Hurley2015]: D. M. Hurley, J. C. Cook, et al., “Understanding temporal and spatial variability of the lunar helium atmosphere using  simultaneous observations from LRO, LADEE, and ARTEMIS,” Icarus, vol. 273, pp. 45–52, Sept. 2015.","category":"page"},{"location":"LunarSurfaceDensity/input.html","page":"Input","title":"Input","text":"[Poppe2013]: A. R. Poppe, J. S. Halekas, et al., “The self-sputtered contribution to the lunar exosphere,” Journal of Geophysical Research: Planets, vol. 118, pp. 1934–1944, Sept. 2013.","category":"page"},{"location":"index.html#ExosphereSimulations-Package","page":"Home","title":"ExosphereSimulations Package","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The ExosphereSimuations package provides the code-base for several studies of surface-bounded exospheres.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html#Author-Information","page":"Home","title":"Author Information","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Alexander Smolka - alexander.smolka@tum.de","category":"page"}]
}
